//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function(){var n=this,t=n._,r={},e=Array.prototype,u=Object.prototype,i=Function.prototype,a=e.push,o=e.slice,c=e.concat,l=u.toString,f=u.hasOwnProperty,s=e.forEach,p=e.map,h=e.reduce,v=e.reduceRight,g=e.filter,d=e.every,m=e.some,y=e.indexOf,b=e.lastIndexOf,x=Array.isArray,w=Object.keys,_=i.bind,j=function(n){return n instanceof j?n:this instanceof j?void(this._wrapped=n):new j(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=j),exports._=j):n._=j,j.VERSION="1.6.0";var A=j.each=j.forEach=function(n,t,e){if(null==n)return n;if(s&&n.forEach===s)n.forEach(t,e);else if(n.length===+n.length){for(var u=0,i=n.length;i>u;u++)if(t.call(e,n[u],u,n)===r)return}else for(var a=j.keys(n),u=0,i=a.length;i>u;u++)if(t.call(e,n[a[u]],a[u],n)===r)return;return n};j.map=j.collect=function(n,t,r){var e=[];return null==n?e:p&&n.map===p?n.map(t,r):(A(n,function(n,u,i){e.push(t.call(r,n,u,i))}),e)};var O="Reduce of empty array with no initial value";j.reduce=j.foldl=j.inject=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),h&&n.reduce===h)return e&&(t=j.bind(t,e)),u?n.reduce(t,r):n.reduce(t);if(A(n,function(n,i,a){u?r=t.call(e,r,n,i,a):(r=n,u=!0)}),!u)throw new TypeError(O);return r},j.reduceRight=j.foldr=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),v&&n.reduceRight===v)return e&&(t=j.bind(t,e)),u?n.reduceRight(t,r):n.reduceRight(t);var i=n.length;if(i!==+i){var a=j.keys(n);i=a.length}if(A(n,function(o,c,l){c=a?a[--i]:--i,u?r=t.call(e,r,n[c],c,l):(r=n[c],u=!0)}),!u)throw new TypeError(O);return r},j.find=j.detect=function(n,t,r){var e;return k(n,function(n,u,i){return t.call(r,n,u,i)?(e=n,!0):void 0}),e},j.filter=j.select=function(n,t,r){var e=[];return null==n?e:g&&n.filter===g?n.filter(t,r):(A(n,function(n,u,i){t.call(r,n,u,i)&&e.push(n)}),e)},j.reject=function(n,t,r){return j.filter(n,function(n,e,u){return!t.call(r,n,e,u)},r)},j.every=j.all=function(n,t,e){t||(t=j.identity);var u=!0;return null==n?u:d&&n.every===d?n.every(t,e):(A(n,function(n,i,a){return(u=u&&t.call(e,n,i,a))?void 0:r}),!!u)};var k=j.some=j.any=function(n,t,e){t||(t=j.identity);var u=!1;return null==n?u:m&&n.some===m?n.some(t,e):(A(n,function(n,i,a){return u||(u=t.call(e,n,i,a))?r:void 0}),!!u)};j.contains=j.include=function(n,t){return null==n?!1:y&&n.indexOf===y?n.indexOf(t)!=-1:k(n,function(n){return n===t})},j.invoke=function(n,t){var r=o.call(arguments,2),e=j.isFunction(t);return j.map(n,function(n){return(e?t:n[t]).apply(n,r)})},j.pluck=function(n,t){return j.map(n,j.property(t))},j.where=function(n,t){return j.filter(n,j.matches(t))},j.findWhere=function(n,t){return j.find(n,j.matches(t))},j.max=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0]&&n.length<65535)return Math.max.apply(Math,n);var e=-1/0,u=-1/0;return A(n,function(n,i,a){var o=t?t.call(r,n,i,a):n;o>u&&(e=n,u=o)}),e},j.min=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0]&&n.length<65535)return Math.min.apply(Math,n);var e=1/0,u=1/0;return A(n,function(n,i,a){var o=t?t.call(r,n,i,a):n;u>o&&(e=n,u=o)}),e},j.shuffle=function(n){var t,r=0,e=[];return A(n,function(n){t=j.random(r++),e[r-1]=e[t],e[t]=n}),e},j.sample=function(n,t,r){return null==t||r?(n.length!==+n.length&&(n=j.values(n)),n[j.random(n.length-1)]):j.shuffle(n).slice(0,Math.max(0,t))};var E=function(n){return null==n?j.identity:j.isFunction(n)?n:j.property(n)};j.sortBy=function(n,t,r){return t=E(t),j.pluck(j.map(n,function(n,e,u){return{value:n,index:e,criteria:t.call(r,n,e,u)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index-t.index}),"value")};var F=function(n){return function(t,r,e){var u={};return r=E(r),A(t,function(i,a){var o=r.call(e,i,a,t);n(u,o,i)}),u}};j.groupBy=F(function(n,t,r){j.has(n,t)?n[t].push(r):n[t]=[r]}),j.indexBy=F(function(n,t,r){n[t]=r}),j.countBy=F(function(n,t){j.has(n,t)?n[t]++:n[t]=1}),j.sortedIndex=function(n,t,r,e){r=E(r);for(var u=r.call(e,t),i=0,a=n.length;a>i;){var o=i+a>>>1;r.call(e,n[o])<u?i=o+1:a=o}return i},j.toArray=function(n){return n?j.isArray(n)?o.call(n):n.length===+n.length?j.map(n,j.identity):j.values(n):[]},j.size=function(n){return null==n?0:n.length===+n.length?n.length:j.keys(n).length},j.first=j.head=j.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:0>t?[]:o.call(n,0,t)},j.initial=function(n,t,r){return o.call(n,0,n.length-(null==t||r?1:t))},j.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:o.call(n,Math.max(n.length-t,0))},j.rest=j.tail=j.drop=function(n,t,r){return o.call(n,null==t||r?1:t)},j.compact=function(n){return j.filter(n,j.identity)};var M=function(n,t,r){return t&&j.every(n,j.isArray)?c.apply(r,n):(A(n,function(n){j.isArray(n)||j.isArguments(n)?t?a.apply(r,n):M(n,t,r):r.push(n)}),r)};j.flatten=function(n,t){return M(n,t,[])},j.without=function(n){return j.difference(n,o.call(arguments,1))},j.partition=function(n,t){var r=[],e=[];return A(n,function(n){(t(n)?r:e).push(n)}),[r,e]},j.uniq=j.unique=function(n,t,r,e){j.isFunction(t)&&(e=r,r=t,t=!1);var u=r?j.map(n,r,e):n,i=[],a=[];return A(u,function(r,e){(t?e&&a[a.length-1]===r:j.contains(a,r))||(a.push(r),i.push(n[e]))}),i},j.union=function(){return j.uniq(j.flatten(arguments,!0))},j.intersection=function(n){var t=o.call(arguments,1);return j.filter(j.uniq(n),function(n){return j.every(t,function(t){return j.contains(t,n)})})},j.difference=function(n){var t=c.apply(e,o.call(arguments,1));return j.filter(n,function(n){return!j.contains(t,n)})},j.zip=function(){for(var n=j.max(j.pluck(arguments,"length").concat(0)),t=new Array(n),r=0;n>r;r++)t[r]=j.pluck(arguments,""+r);return t},j.object=function(n,t){if(null==n)return{};for(var r={},e=0,u=n.length;u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},j.indexOf=function(n,t,r){if(null==n)return-1;var e=0,u=n.length;if(r){if("number"!=typeof r)return e=j.sortedIndex(n,t),n[e]===t?e:-1;e=0>r?Math.max(0,u+r):r}if(y&&n.indexOf===y)return n.indexOf(t,r);for(;u>e;e++)if(n[e]===t)return e;return-1},j.lastIndexOf=function(n,t,r){if(null==n)return-1;var e=null!=r;if(b&&n.lastIndexOf===b)return e?n.lastIndexOf(t,r):n.lastIndexOf(t);for(var u=e?r:n.length;u--;)if(n[u]===t)return u;return-1},j.range=function(n,t,r){arguments.length<=1&&(t=n||0,n=0),r=arguments[2]||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=0,i=new Array(e);e>u;)i[u++]=n,n+=r;return i};var R=function(){};j.bind=function(n,t){var r,e;if(_&&n.bind===_)return _.apply(n,o.call(arguments,1));if(!j.isFunction(n))throw new TypeError;return r=o.call(arguments,2),e=function(){if(!(this instanceof e))return n.apply(t,r.concat(o.call(arguments)));R.prototype=n.prototype;var u=new R;R.prototype=null;var i=n.apply(u,r.concat(o.call(arguments)));return Object(i)===i?i:u}},j.partial=function(n){var t=o.call(arguments,1);return function(){for(var r=0,e=t.slice(),u=0,i=e.length;i>u;u++)e[u]===j&&(e[u]=arguments[r++]);for(;r<arguments.length;)e.push(arguments[r++]);return n.apply(this,e)}},j.bindAll=function(n){var t=o.call(arguments,1);if(0===t.length)throw new Error("bindAll must be passed function names");return A(t,function(t){n[t]=j.bind(n[t],n)}),n},j.memoize=function(n,t){var r={};return t||(t=j.identity),function(){var e=t.apply(this,arguments);return j.has(r,e)?r[e]:r[e]=n.apply(this,arguments)}},j.delay=function(n,t){var r=o.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},j.defer=function(n){return j.delay.apply(j,[n,1].concat(o.call(arguments,1)))},j.throttle=function(n,t,r){var e,u,i,a=null,o=0;r||(r={});var c=function(){o=r.leading===!1?0:j.now(),a=null,i=n.apply(e,u),e=u=null};return function(){var l=j.now();o||r.leading!==!1||(o=l);var f=t-(l-o);return e=this,u=arguments,0>=f?(clearTimeout(a),a=null,o=l,i=n.apply(e,u),e=u=null):a||r.trailing===!1||(a=setTimeout(c,f)),i}},j.debounce=function(n,t,r){var e,u,i,a,o,c=function(){var l=j.now()-a;t>l?e=setTimeout(c,t-l):(e=null,r||(o=n.apply(i,u),i=u=null))};return function(){i=this,u=arguments,a=j.now();var l=r&&!e;return e||(e=setTimeout(c,t)),l&&(o=n.apply(i,u),i=u=null),o}},j.once=function(n){var t,r=!1;return function(){return r?t:(r=!0,t=n.apply(this,arguments),n=null,t)}},j.wrap=function(n,t){return j.partial(t,n)},j.compose=function(){var n=arguments;return function(){for(var t=arguments,r=n.length-1;r>=0;r--)t=[n[r].apply(this,t)];return t[0]}},j.after=function(n,t){return function(){return--n<1?t.apply(this,arguments):void 0}},j.keys=function(n){if(!j.isObject(n))return[];if(w)return w(n);var t=[];for(var r in n)j.has(n,r)&&t.push(r);return t},j.values=function(n){for(var t=j.keys(n),r=t.length,e=new Array(r),u=0;r>u;u++)e[u]=n[t[u]];return e},j.pairs=function(n){for(var t=j.keys(n),r=t.length,e=new Array(r),u=0;r>u;u++)e[u]=[t[u],n[t[u]]];return e},j.invert=function(n){for(var t={},r=j.keys(n),e=0,u=r.length;u>e;e++)t[n[r[e]]]=r[e];return t},j.functions=j.methods=function(n){var t=[];for(var r in n)j.isFunction(n[r])&&t.push(r);return t.sort()},j.extend=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]=t[r]}),n},j.pick=function(n){var t={},r=c.apply(e,o.call(arguments,1));return A(r,function(r){r in n&&(t[r]=n[r])}),t},j.omit=function(n){var t={},r=c.apply(e,o.call(arguments,1));for(var u in n)j.contains(r,u)||(t[u]=n[u]);return t},j.defaults=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]===void 0&&(n[r]=t[r])}),n},j.clone=function(n){return j.isObject(n)?j.isArray(n)?n.slice():j.extend({},n):n},j.tap=function(n,t){return t(n),n};var S=function(n,t,r,e){if(n===t)return 0!==n||1/n==1/t;if(null==n||null==t)return n===t;n instanceof j&&(n=n._wrapped),t instanceof j&&(t=t._wrapped);var u=l.call(n);if(u!=l.call(t))return!1;switch(u){case"[object String]":return n==String(t);case"[object Number]":return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case"[object Date]":case"[object Boolean]":return+n==+t;case"[object RegExp]":return n.source==t.source&&n.global==t.global&&n.multiline==t.multiline&&n.ignoreCase==t.ignoreCase}if("object"!=typeof n||"object"!=typeof t)return!1;for(var i=r.length;i--;)if(r[i]==n)return e[i]==t;var a=n.constructor,o=t.constructor;if(a!==o&&!(j.isFunction(a)&&a instanceof a&&j.isFunction(o)&&o instanceof o)&&"constructor"in n&&"constructor"in t)return!1;r.push(n),e.push(t);var c=0,f=!0;if("[object Array]"==u){if(c=n.length,f=c==t.length)for(;c--&&(f=S(n[c],t[c],r,e)););}else{for(var s in n)if(j.has(n,s)&&(c++,!(f=j.has(t,s)&&S(n[s],t[s],r,e))))break;if(f){for(s in t)if(j.has(t,s)&&!c--)break;f=!c}}return r.pop(),e.pop(),f};j.isEqual=function(n,t){return S(n,t,[],[])},j.isEmpty=function(n){if(null==n)return!0;if(j.isArray(n)||j.isString(n))return 0===n.length;for(var t in n)if(j.has(n,t))return!1;return!0},j.isElement=function(n){return!(!n||1!==n.nodeType)},j.isArray=x||function(n){return"[object Array]"==l.call(n)},j.isObject=function(n){return n===Object(n)},A(["Arguments","Function","String","Number","Date","RegExp"],function(n){j["is"+n]=function(t){return l.call(t)=="[object "+n+"]"}}),j.isArguments(arguments)||(j.isArguments=function(n){return!(!n||!j.has(n,"callee"))}),"function"!=typeof/./&&(j.isFunction=function(n){return"function"==typeof n}),j.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},j.isNaN=function(n){return j.isNumber(n)&&n!=+n},j.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"==l.call(n)},j.isNull=function(n){return null===n},j.isUndefined=function(n){return n===void 0},j.has=function(n,t){return f.call(n,t)},j.noConflict=function(){return n._=t,this},j.identity=function(n){return n},j.constant=function(n){return function(){return n}},j.property=function(n){return function(t){return t[n]}},j.matches=function(n){return function(t){if(t===n)return!0;for(var r in n)if(n[r]!==t[r])return!1;return!0}},j.times=function(n,t,r){for(var e=Array(Math.max(0,n)),u=0;n>u;u++)e[u]=t.call(r,u);return e},j.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))},j.now=Date.now||function(){return(new Date).getTime()};var T={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;"}};T.unescape=j.invert(T.escape);var I={escape:new RegExp("["+j.keys(T.escape).join("")+"]","g"),unescape:new RegExp("("+j.keys(T.unescape).join("|")+")","g")};j.each(["escape","unescape"],function(n){j[n]=function(t){return null==t?"":(""+t).replace(I[n],function(t){return T[n][t]})}}),j.result=function(n,t){if(null==n)return void 0;var r=n[t];return j.isFunction(r)?r.call(n):r},j.mixin=function(n){A(j.functions(n),function(t){var r=j[t]=n[t];j.prototype[t]=function(){var n=[this._wrapped];return a.apply(n,arguments),z.call(this,r.apply(j,n))}})};var N=0;j.uniqueId=function(n){var t=++N+"";return n?n+t:t},j.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var q=/(.)^/,B={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},D=/\\|'|\r|\n|\t|\u2028|\u2029/g;j.template=function(n,t,r){var e;r=j.defaults({},r,j.templateSettings);var u=new RegExp([(r.escape||q).source,(r.interpolate||q).source,(r.evaluate||q).source].join("|")+"|$","g"),i=0,a="__p+='";n.replace(u,function(t,r,e,u,o){return a+=n.slice(i,o).replace(D,function(n){return"\\"+B[n]}),r&&(a+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'"),e&&(a+="'+\n((__t=("+e+"))==null?'':__t)+\n'"),u&&(a+="';\n"+u+"\n__p+='"),i=o+t.length,t}),a+="';\n",r.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{e=new Function(r.variable||"obj","_",a)}catch(o){throw o.source=a,o}if(t)return e(t,j);var c=function(n){return e.call(this,n,j)};return c.source="function("+(r.variable||"obj")+"){\n"+a+"}",c},j.chain=function(n){return j(n).chain()};var z=function(n){return this._chain?j(n).chain():n};j.mixin(j),A(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=e[n];j.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!=n&&"splice"!=n||0!==r.length||delete r[0],z.call(this,r)}}),A(["concat","join","slice"],function(n){var t=e[n];j.prototype[n]=function(){return z.call(this,t.apply(this._wrapped,arguments))}}),j.extend(j.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}}),"function"==typeof define&&define.amd&&define("underscore",[],function(){return j})}).call(this);
//# sourceMappingURL=underscore-min.map
/*!
 * Knockout JavaScript library v3.2.0
 * (c) Steven Sanderson - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(p){var s=this||(0,eval)("this"),v=s.document,L=s.navigator,w=s.jQuery,D=s.JSON;(function(p){"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?p(module.exports||exports,require):"function"===typeof define&&define.amd?define(["exports","require"],p):p(s.ko={})})(function(M,N){function H(a,d){return null===a||typeof a in R?a===d:!1}function S(a,d){var c;return function(){c||(c=setTimeout(function(){c=p;a()},d))}}function T(a,d){var c;return function(){clearTimeout(c);
    c=setTimeout(a,d)}}function I(b,d,c,e){a.d[b]={init:function(b,h,k,f,m){var l,q;a.s(function(){var f=a.a.c(h()),k=!c!==!f,z=!q;if(z||d||k!==l)z&&a.Y.la()&&(q=a.a.ia(a.f.childNodes(b),!0)),k?(z||a.f.T(b,a.a.ia(q)),a.Ca(e?e(m,f):m,b)):a.f.ja(b),l=k},null,{o:b});return{controlsDescendantBindings:!0}}};a.h.ha[b]=!1;a.f.Q[b]=!0}var a="undefined"!==typeof M?M:{};a.b=function(b,d){for(var c=b.split("."),e=a,g=0;g<c.length-1;g++)e=e[c[g]];e[c[c.length-1]]=d};a.A=function(a,d,c){a[d]=c};a.version="3.2.0";
    a.b("version",a.version);a.a=function(){function b(a,b){for(var c in a)a.hasOwnProperty(c)&&b(c,a[c])}function d(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function c(a,b){a.__proto__=b;return a}var e={__proto__:[]}instanceof Array,g={},h={};g[L&&/Firefox\/2/i.test(L.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];g.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(g,function(a,b){if(b.length)for(var c=
        0,d=b.length;c<d;c++)h[b[c]]=a});var k={propertychange:!0},f=v&&function(){for(var a=3,b=v.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:p}();return{vb:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],u:function(a,b){for(var c=0,d=a.length;c<d;c++)b(a[c],c)},m:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,d=a.length;c<d;c++)if(a[c]===
        b)return c;return-1},qb:function(a,b,c){for(var d=0,f=a.length;d<f;d++)if(b.call(c,a[d],d))return a[d];return null},ua:function(m,b){var c=a.a.m(m,b);0<c?m.splice(c,1):0===c&&m.shift()},rb:function(m){m=m||[];for(var b=[],c=0,d=m.length;c<d;c++)0>a.a.m(b,m[c])&&b.push(m[c]);return b},Da:function(a,b){a=a||[];for(var c=[],d=0,f=a.length;d<f;d++)c.push(b(a[d],d));return c},ta:function(a,b){a=a||[];for(var c=[],d=0,f=a.length;d<f;d++)b(a[d],d)&&c.push(a[d]);return c},ga:function(a,b){if(b instanceof
        Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},ea:function(b,c,d){var f=a.a.m(a.a.Xa(b),c);0>f?d&&b.push(c):d||b.splice(f,1)},xa:e,extend:d,za:c,Aa:e?c:d,G:b,na:function(a,b){if(!a)return a;var c={},d;for(d in a)a.hasOwnProperty(d)&&(c[d]=b(a[d],d,a));return c},Ka:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},oc:function(b){b=a.a.S(b);for(var c=v.createElement("div"),d=0,f=b.length;d<f;d++)c.appendChild(a.R(b[d]));return c},ia:function(b,c){for(var d=
        0,f=b.length,e=[];d<f;d++){var k=b[d].cloneNode(!0);e.push(c?a.R(k):k)}return e},T:function(b,c){a.a.Ka(b);if(c)for(var d=0,f=c.length;d<f;d++)b.appendChild(c[d])},Lb:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var f=d[0],e=f.parentNode,k=0,g=c.length;k<g;k++)e.insertBefore(c[k],f);k=0;for(g=d.length;k<g;k++)a.removeNode(d[k])}},ka:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.shift();if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0;c!==d;)if(a.push(c),c=c.nextSibling,!c)return;a.push(d)}}return a},Nb:function(a,b){7>f?a.setAttribute("selected",b):a.selected=b},cb:function(a){return null===a||a===p?"":a.trim?a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},vc:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},cc:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(3===a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&
        16);for(;a&&a!=b;)a=a.parentNode;return!!a},Ja:function(b){return a.a.cc(b,b.ownerDocument.documentElement)},ob:function(b){return!!a.a.qb(b,a.a.Ja)},t:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},n:function(b,c,d){var e=f&&k[c];if(!e&&w)w(b).bind(c,d);else if(e||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var g=function(a){d.call(b,a)},h="on"+c;b.attachEvent(h,g);a.a.w.da(b,function(){b.detachEvent(h,g)})}else throw Error("Browser doesn't support addEventListener or attachEvent");
    else b.addEventListener(c,d,!1)},oa:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.t(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(w&&!d)w(b).trigger(c);else if("function"==typeof v.createEvent)if("function"==typeof b.dispatchEvent)d=v.createEvent(h[c]||"HTMLEvents"),d.initEvent(c,!0,!0,s,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");
    else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");},c:function(b){return a.C(b)?b():b},Xa:function(b){return a.C(b)?b.v():b},Ba:function(b,c,d){if(c){var f=/\S+/g,e=b.className.match(f)||[];a.a.u(c.match(f),function(b){a.a.ea(e,b,d)});b.className=e.join(" ")}},bb:function(b,c){var d=a.a.c(c);if(null===d||d===p)d="";var f=a.f.firstChild(b);!f||3!=f.nodeType||a.f.nextSibling(f)?a.f.T(b,[b.ownerDocument.createTextNode(d)]):
        f.data=d;a.a.fc(b)},Mb:function(a,b){a.name=b;if(7>=f)try{a.mergeAttributes(v.createElement("<input name='"+a.name+"'/>"),!1)}catch(c){}},fc:function(a){9<=f&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},dc:function(a){if(f){var b=a.style.width;a.style.width=0;a.style.width=b}},sc:function(b,c){b=a.a.c(b);c=a.a.c(c);for(var d=[],f=b;f<=c;f++)d.push(f);return d},S:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},yc:6===f,zc:7===f,L:f,xb:function(b,c){for(var d=
        a.a.S(b.getElementsByTagName("input")).concat(a.a.S(b.getElementsByTagName("textarea"))),f="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},e=[],k=d.length-1;0<=k;k--)f(d[k])&&e.push(d[k]);return e},pc:function(b){return"string"==typeof b&&(b=a.a.cb(b))?D&&D.parse?D.parse(b):(new Function("return "+b))():null},eb:function(b,c,d){if(!D||!D.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
        return D.stringify(a.a.c(b),c,d)},qc:function(c,d,f){f=f||{};var e=f.params||{},k=f.includeFields||this.vb,g=c;if("object"==typeof c&&"form"===a.a.t(c))for(var g=c.action,h=k.length-1;0<=h;h--)for(var r=a.a.xb(c,k[h]),E=r.length-1;0<=E;E--)e[r[E].name]=r[E].value;d=a.a.c(d);var y=v.createElement("form");y.style.display="none";y.action=g;y.method="post";for(var p in d)c=v.createElement("input"),c.type="hidden",c.name=p,c.value=a.a.eb(a.a.c(d[p])),y.appendChild(c);b(e,function(a,b){var c=v.createElement("input");
        c.type="hidden";c.name=a;c.value=b;y.appendChild(c)});v.body.appendChild(y);f.submitter?f.submitter(y):y.submit();setTimeout(function(){y.parentNode.removeChild(y)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.u);a.b("utils.arrayFirst",a.a.qb);a.b("utils.arrayFilter",a.a.ta);a.b("utils.arrayGetDistinctValues",a.a.rb);a.b("utils.arrayIndexOf",a.a.m);a.b("utils.arrayMap",a.a.Da);a.b("utils.arrayPushAll",a.a.ga);a.b("utils.arrayRemoveItem",a.a.ua);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",
        a.a.vb);a.b("utils.getFormFields",a.a.xb);a.b("utils.peekObservable",a.a.Xa);a.b("utils.postJson",a.a.qc);a.b("utils.parseJson",a.a.pc);a.b("utils.registerEventHandler",a.a.n);a.b("utils.stringifyJson",a.a.eb);a.b("utils.range",a.a.sc);a.b("utils.toggleDomNodeCssClass",a.a.Ba);a.b("utils.triggerEvent",a.a.oa);a.b("utils.unwrapObservable",a.a.c);a.b("utils.objectForEach",a.a.G);a.b("utils.addOrRemoveItem",a.a.ea);a.b("unwrap",a.a.c);Function.prototype.bind||(Function.prototype.bind=function(a){var d=
        this,c=Array.prototype.slice.call(arguments);a=c.shift();return function(){return d.apply(a,c.concat(Array.prototype.slice.call(arguments)))}});a.a.e=new function(){function a(b,h){var k=b[c];if(!k||"null"===k||!e[k]){if(!h)return p;k=b[c]="ko"+d++;e[k]={}}return e[k]}var d=0,c="__ko__"+(new Date).getTime(),e={};return{get:function(c,d){var e=a(c,!1);return e===p?p:e[d]},set:function(c,d,e){if(e!==p||a(c,!1)!==p)a(c,!0)[d]=e},clear:function(a){var b=a[c];return b?(delete e[b],a[c]=null,!0):!1},F:function(){return d++ +
        c}}};a.b("utils.domData",a.a.e);a.b("utils.domData.clear",a.a.e.clear);a.a.w=new function(){function b(b,d){var f=a.a.e.get(b,c);f===p&&d&&(f=[],a.a.e.set(b,c,f));return f}function d(c){var e=b(c,!1);if(e)for(var e=e.slice(0),f=0;f<e.length;f++)e[f](c);a.a.e.clear(c);a.a.w.cleanExternalData(c);if(g[c.nodeType])for(e=c.firstChild;c=e;)e=c.nextSibling,8===c.nodeType&&d(c)}var c=a.a.e.F(),e={1:!0,8:!0,9:!0},g={1:!0,9:!0};return{da:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");
        b(a,!0).push(c)},Kb:function(d,e){var f=b(d,!1);f&&(a.a.ua(f,e),0==f.length&&a.a.e.set(d,c,p))},R:function(b){if(e[b.nodeType]&&(d(b),g[b.nodeType])){var c=[];a.a.ga(c,b.getElementsByTagName("*"));for(var f=0,m=c.length;f<m;f++)d(c[f])}return b},removeNode:function(b){a.R(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){w&&"function"==typeof w.cleanData&&w.cleanData([a])}}};a.R=a.a.w.R;a.removeNode=a.a.w.removeNode;a.b("cleanNode",a.R);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",
        a.a.w);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.w.da);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.w.Kb);(function(){a.a.ba=function(b){var d;if(w)if(w.parseHTML)d=w.parseHTML(b)||[];else{if((d=w.clean([b]))&&d[0]){for(b=d[0];b.parentNode&&11!==b.parentNode.nodeType;)b=b.parentNode;b.parentNode&&b.parentNode.removeChild(b)}}else{var c=a.a.cb(b).toLowerCase();d=v.createElement("div");c=c.match(/^<(thead|tbody|tfoot)/)&&[1,"<table>","</table>"]||!c.indexOf("<tr")&&[2,"<table><tbody>",
        "</tbody></table>"]||(!c.indexOf("<td")||!c.indexOf("<th"))&&[3,"<table><tbody><tr>","</tr></tbody></table>"]||[0,"",""];b="ignored<div>"+c[1]+b+c[2]+"</div>";for("function"==typeof s.innerShiv?d.appendChild(s.innerShiv(b)):d.innerHTML=b;c[0]--;)d=d.lastChild;d=a.a.S(d.lastChild.childNodes)}return d};a.a.$a=function(b,d){a.a.Ka(b);d=a.a.c(d);if(null!==d&&d!==p)if("string"!=typeof d&&(d=d.toString()),w)w(b).html(d);else for(var c=a.a.ba(d),e=0;e<c.length;e++)b.appendChild(c[e])}})();a.b("utils.parseHtmlFragment",
        a.a.ba);a.b("utils.setHtml",a.a.$a);a.D=function(){function b(c,d){if(c)if(8==c.nodeType){var g=a.D.Gb(c.nodeValue);null!=g&&d.push({bc:c,mc:g})}else if(1==c.nodeType)for(var g=0,h=c.childNodes,k=h.length;g<k;g++)b(h[g],d)}var d={};return{Ua:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);d[b]=a;return"\x3c!--[ko_memo:"+
        b+"]--\x3e"},Rb:function(a,b){var g=d[a];if(g===p)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return g.apply(null,b||[]),!0}finally{delete d[a]}},Sb:function(c,d){var g=[];b(c,g);for(var h=0,k=g.length;h<k;h++){var f=g[h].bc,m=[f];d&&a.a.ga(m,d);a.D.Rb(g[h].mc,m);f.nodeValue="";f.parentNode&&f.parentNode.removeChild(f)}},Gb:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.D);a.b("memoization.memoize",a.D.Ua);
    a.b("memoization.unmemoize",a.D.Rb);a.b("memoization.parseMemoText",a.D.Gb);a.b("memoization.unmemoizeDomNodeAndDescendants",a.D.Sb);a.La={throttle:function(b,d){b.throttleEvaluation=d;var c=null;return a.j({read:b,write:function(a){clearTimeout(c);c=setTimeout(function(){b(a)},d)}})},rateLimit:function(a,d){var c,e,g;"number"==typeof d?c=d:(c=d.timeout,e=d.method);g="notifyWhenChangesStop"==e?T:S;a.Ta(function(a){return g(a,c)})},notify:function(a,d){a.equalityComparer="always"==d?null:H}};var R=
    {undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.La);a.Pb=function(b,d,c){this.target=b;this.wa=d;this.ac=c;this.Cb=!1;a.A(this,"dispose",this.K)};a.Pb.prototype.K=function(){this.Cb=!0;this.ac()};a.P=function(){a.a.Aa(this,a.P.fn);this.M={}};var G="change",A={U:function(b,d,c){var e=this;c=c||G;var g=new a.Pb(e,d?b.bind(d):b,function(){a.a.ua(e.M[c],g);e.nb&&e.nb()});e.va&&e.va(c);e.M[c]||(e.M[c]=[]);e.M[c].push(g);return g},notifySubscribers:function(b,d){d=d||G;if(this.Ab(d))try{a.k.Ea();
        for(var c=this.M[d].slice(0),e=0,g;g=c[e];++e)g.Cb||g.wa(b)}finally{a.k.end()}},Ta:function(b){var d=this,c=a.C(d),e,g,h;d.qa||(d.qa=d.notifySubscribers,d.notifySubscribers=function(a,b){b&&b!==G?"beforeChange"===b?d.kb(a):d.qa(a,b):d.lb(a)});var k=b(function(){c&&h===d&&(h=d());e=!1;d.Pa(g,h)&&d.qa(g=h)});d.lb=function(a){e=!0;h=a;k()};d.kb=function(a){e||(g=a,d.qa(a,"beforeChange"))}},Ab:function(a){return this.M[a]&&this.M[a].length},yb:function(){var b=0;a.a.G(this.M,function(a,c){b+=c.length});
        return b},Pa:function(a,d){return!this.equalityComparer||!this.equalityComparer(a,d)},extend:function(b){var d=this;b&&a.a.G(b,function(b,e){var g=a.La[b];"function"==typeof g&&(d=g(d,e)||d)});return d}};a.A(A,"subscribe",A.U);a.A(A,"extend",A.extend);a.A(A,"getSubscriptionsCount",A.yb);a.a.xa&&a.a.za(A,Function.prototype);a.P.fn=A;a.Db=function(a){return null!=a&&"function"==typeof a.U&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.P);a.b("isSubscribable",a.Db);a.Y=a.k=function(){function b(a){c.push(e);
        e=a}function d(){e=c.pop()}var c=[],e,g=0;return{Ea:b,end:d,Jb:function(b){if(e){if(!a.Db(b))throw Error("Only subscribable things can act as dependencies");e.wa(b,b.Vb||(b.Vb=++g))}},B:function(a,c,f){try{return b(),a.apply(c,f||[])}finally{d()}},la:function(){if(e)return e.s.la()},ma:function(){if(e)return e.ma}}}();a.b("computedContext",a.Y);a.b("computedContext.getDependenciesCount",a.Y.la);a.b("computedContext.isInitial",a.Y.ma);a.b("computedContext.isSleeping",a.Y.Ac);a.p=function(b){function d(){if(0<
        arguments.length)return d.Pa(c,arguments[0])&&(d.X(),c=arguments[0],d.W()),this;a.k.Jb(d);return c}var c=b;a.P.call(d);a.a.Aa(d,a.p.fn);d.v=function(){return c};d.W=function(){d.notifySubscribers(c)};d.X=function(){d.notifySubscribers(c,"beforeChange")};a.A(d,"peek",d.v);a.A(d,"valueHasMutated",d.W);a.A(d,"valueWillMutate",d.X);return d};a.p.fn={equalityComparer:H};var F=a.p.rc="__ko_proto__";a.p.fn[F]=a.p;a.a.xa&&a.a.za(a.p.fn,a.P.fn);a.Ma=function(b,d){return null===b||b===p||b[F]===p?!1:b[F]===
        d?!0:a.Ma(b[F],d)};a.C=function(b){return a.Ma(b,a.p)};a.Ra=function(b){return"function"==typeof b&&b[F]===a.p||"function"==typeof b&&b[F]===a.j&&b.hc?!0:!1};a.b("observable",a.p);a.b("isObservable",a.C);a.b("isWriteableObservable",a.Ra);a.b("isWritableObservable",a.Ra);a.aa=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.p(b);a.a.Aa(b,a.aa.fn);return b.extend({trackArrayChanges:!0})};
    a.aa.fn={remove:function(b){for(var d=this.v(),c=[],e="function"!=typeof b||a.C(b)?function(a){return a===b}:b,g=0;g<d.length;g++){var h=d[g];e(h)&&(0===c.length&&this.X(),c.push(h),d.splice(g,1),g--)}c.length&&this.W();return c},removeAll:function(b){if(b===p){var d=this.v(),c=d.slice(0);this.X();d.splice(0,d.length);this.W();return c}return b?this.remove(function(c){return 0<=a.a.m(b,c)}):[]},destroy:function(b){var d=this.v(),c="function"!=typeof b||a.C(b)?function(a){return a===b}:b;this.X();
        for(var e=d.length-1;0<=e;e--)c(d[e])&&(d[e]._destroy=!0);this.W()},destroyAll:function(b){return b===p?this.destroy(function(){return!0}):b?this.destroy(function(d){return 0<=a.a.m(b,d)}):[]},indexOf:function(b){var d=this();return a.a.m(d,b)},replace:function(a,d){var c=this.indexOf(a);0<=c&&(this.X(),this.v()[c]=d,this.W())}};a.a.u("pop push reverse shift sort splice unshift".split(" "),function(b){a.aa.fn[b]=function(){var a=this.v();this.X();this.sb(a,b,arguments);a=a[b].apply(a,arguments);this.W();
        return a}});a.a.u(["slice"],function(b){a.aa.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.a.xa&&a.a.za(a.aa.fn,a.p.fn);a.b("observableArray",a.aa);var J="arrayChange";a.La.trackArrayChanges=function(b){function d(){if(!c){c=!0;var d=b.notifySubscribers;b.notifySubscribers=function(a,b){b&&b!==G||++g;return d.apply(this,arguments)};var f=[].concat(b.v()||[]);e=null;b.U(function(c){c=[].concat(c||[]);if(b.Ab(J)){var d;if(!e||1<g)e=a.a.Fa(f,c,{sparse:!0});d=e;d.length&&b.notifySubscribers(d,
        J)}f=c;e=null;g=0})}}if(!b.sb){var c=!1,e=null,g=0,h=b.U;b.U=b.subscribe=function(a,b,c){c===J&&d();return h.apply(this,arguments)};b.sb=function(b,d,m){function l(a,b,c){return q[q.length]={status:a,value:b,index:c}}if(c&&!g){var q=[],h=b.length,t=m.length,z=0;switch(d){case "push":z=h;case "unshift":for(d=0;d<t;d++)l("added",m[d],z+d);break;case "pop":z=h-1;case "shift":h&&l("deleted",b[z],z);break;case "splice":d=Math.min(Math.max(0,0>m[0]?h+m[0]:m[0]),h);for(var h=1===t?h:Math.min(d+(m[1]||0),
        h),t=d+t-2,z=Math.max(h,t),u=[],r=[],E=2;d<z;++d,++E)d<h&&r.push(l("deleted",b[d],d)),d<t&&u.push(l("added",m[E],d));a.a.wb(r,u);break;default:return}e=q}}}};a.s=a.j=function(b,d,c){function e(){a.a.G(v,function(a,b){b.K()});v={}}function g(){e();C=0;u=!0;n=!1}function h(){var a=f.throttleEvaluation;a&&0<=a?(clearTimeout(P),P=setTimeout(k,a)):f.ib?f.ib():k()}function k(b){if(t){if(E)throw Error("A 'pure' computed must not be called recursively");}else if(!u){if(w&&w()){if(!z){s();return}}else z=!1;
        t=!0;if(y)try{var c={};a.k.Ea({wa:function(a,b){c[b]||(c[b]=1,++C)},s:f,ma:p});C=0;q=r.call(d)}finally{a.k.end(),t=!1}else try{var e=v,m=C;a.k.Ea({wa:function(a,b){u||(m&&e[b]?(v[b]=e[b],++C,delete e[b],--m):v[b]||(v[b]=a.U(h),++C))},s:f,ma:E?p:!C});v={};C=0;try{var l=d?r.call(d):r()}finally{a.k.end(),m&&a.a.G(e,function(a,b){b.K()}),n=!1}f.Pa(q,l)&&(f.notifySubscribers(q,"beforeChange"),q=l,!0!==b&&f.notifySubscribers(q))}finally{t=!1}C||s()}}function f(){if(0<arguments.length){if("function"===typeof O)O.apply(d,
        arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}a.k.Jb(f);n&&k(!0);return q}function m(){n&&!C&&k(!0);return q}function l(){return n||0<C}var q,n=!0,t=!1,z=!1,u=!1,r=b,E=!1,y=!1;r&&"object"==typeof r?(c=r,r=c.read):(c=c||{},r||(r=c.read));if("function"!=typeof r)throw Error("Pass a function that returns the value of the ko.computed");var O=c.write,x=c.disposeWhenNodeIsRemoved||
        c.o||null,B=c.disposeWhen||c.Ia,w=B,s=g,v={},C=0,P=null;d||(d=c.owner);a.P.call(f);a.a.Aa(f,a.j.fn);f.v=m;f.la=function(){return C};f.hc="function"===typeof c.write;f.K=function(){s()};f.Z=l;var A=f.Ta;f.Ta=function(a){A.call(f,a);f.ib=function(){f.kb(q);n=!0;f.lb(f)}};c.pure?(y=E=!0,f.va=function(){y&&(y=!1,k(!0))},f.nb=function(){f.yb()||(e(),y=n=!0)}):c.deferEvaluation&&(f.va=function(){m();delete f.va});a.A(f,"peek",f.v);a.A(f,"dispose",f.K);a.A(f,"isActive",f.Z);a.A(f,"getDependenciesCount",
        f.la);x&&(z=!0,x.nodeType&&(w=function(){return!a.a.Ja(x)||B&&B()}));y||c.deferEvaluation||k();x&&l()&&x.nodeType&&(s=function(){a.a.w.Kb(x,s);g()},a.a.w.da(x,s));return f};a.jc=function(b){return a.Ma(b,a.j)};A=a.p.rc;a.j[A]=a.p;a.j.fn={equalityComparer:H};a.j.fn[A]=a.j;a.a.xa&&a.a.za(a.j.fn,a.P.fn);a.b("dependentObservable",a.j);a.b("computed",a.j);a.b("isComputed",a.jc);a.Ib=function(b,d){if("function"===typeof b)return a.s(b,d,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.s(b,d)};a.b("pureComputed",
        a.Ib);(function(){function b(a,g,h){h=h||new c;a=g(a);if("object"!=typeof a||null===a||a===p||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var k=a instanceof Array?[]:{};h.save(a,k);d(a,function(c){var d=g(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":k[c]=d;break;case "object":case "undefined":var l=h.get(d);k[c]=l!==p?l:b(d,g,h)}});return k}function d(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==
        typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function c(){this.keys=[];this.hb=[]}a.Qb=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.C(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.Qb(b);return a.a.eb(b,c,d)};c.prototype={save:function(b,c){var d=a.a.m(this.keys,b);0<=d?this.hb[d]=c:(this.keys.push(b),this.hb.push(c))},get:function(b){b=a.a.m(this.keys,b);return 0<=b?this.hb[b]:p}}})();
    a.b("toJS",a.Qb);a.b("toJSON",a.toJSON);(function(){a.i={q:function(b){switch(a.a.t(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?a.a.e.get(b,a.d.options.Va):7>=a.a.L?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.i.q(b.options[b.selectedIndex]):p;default:return b.value}},ca:function(b,d,c){switch(a.a.t(b)){case "option":switch(typeof d){case "string":a.a.e.set(b,a.d.options.Va,p);"__ko__hasDomDataOptionValue__"in
        b&&delete b.__ko__hasDomDataOptionValue__;b.value=d;break;default:a.a.e.set(b,a.d.options.Va,d),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===typeof d?d:""}break;case "select":if(""===d||null===d)d=p;for(var e=-1,g=0,h=b.options.length,k;g<h;++g)if(k=a.i.q(b.options[g]),k==d||""==k&&d===p){e=g;break}if(c||0<=e||d===p&&1<b.size)b.selectedIndex=e;break;default:if(null===d||d===p)d="";b.value=d}}}})();a.b("selectExtensions",a.i);a.b("selectExtensions.readValue",a.i.q);a.b("selectExtensions.writeValue",
        a.i.ca);a.h=function(){function b(b){b=a.a.cb(b);123===b.charCodeAt(0)&&(b=b.slice(1,-1));var c=[],d=b.match(e),k,n,t=0;if(d){d.push(",");for(var z=0,u;u=d[z];++z){var r=u.charCodeAt(0);if(44===r){if(0>=t){k&&c.push(n?{key:k,value:n.join("")}:{unknown:k});k=n=t=0;continue}}else if(58===r){if(!n)continue}else if(47===r&&z&&1<u.length)(r=d[z-1].match(g))&&!h[r[0]]&&(b=b.substr(b.indexOf(u)+1),d=b.match(e),d.push(","),z=-1,u="/");else if(40===r||123===r||91===r)++t;else if(41===r||125===r||93===r)--t;
    else if(!k&&!n){k=34===r||39===r?u.slice(1,-1):u;continue}n?n.push(u):n=[u]}}return c}var d=["true","false","null","undefined"],c=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]","g"),g=/[\])"'A-Za-z0-9_$]+$/,h={"in":1,"return":1,"typeof":1},k={};return{ha:[],V:k,Wa:b,ya:function(f,m){function e(b,m){var f;if(!z){var u=a.getBindingHandler(b);if(u&&u.preprocess&&
        !(m=u.preprocess(m,b,e)))return;if(u=k[b])f=m,0<=a.a.m(d,f)?f=!1:(u=f.match(c),f=null===u?!1:u[1]?"Object("+u[1]+")"+u[2]:f),u=f;u&&h.push("'"+b+"':function(_z){"+f+"=_z}")}t&&(m="function(){return "+m+" }");g.push("'"+b+"':"+m)}m=m||{};var g=[],h=[],t=m.valueAccessors,z=m.bindingParams,u="string"===typeof f?b(f):f;a.a.u(u,function(a){e(a.key||a.unknown,a.value)});h.length&&e("_ko_property_writers","{"+h.join(",")+" }");return g.join(",")},lc:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==
        b)return!0;return!1},pa:function(b,c,d,e,k){if(b&&a.C(b))!a.Ra(b)||k&&b.v()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.h);a.b("expressionRewriting.bindingRewriteValidators",a.h.ha);a.b("expressionRewriting.parseObjectLiteral",a.h.Wa);a.b("expressionRewriting.preProcessBindings",a.h.ya);a.b("expressionRewriting._twoWayBindings",a.h.V);a.b("jsonExpressionRewriting",a.h);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.h.ya);(function(){function b(a){return 8==
        a.nodeType&&h.test(g?a.text:a.nodeValue)}function d(a){return 8==a.nodeType&&k.test(g?a.text:a.nodeValue)}function c(a,c){for(var f=a,e=1,k=[];f=f.nextSibling;){if(d(f)&&(e--,0===e))return k;k.push(f);b(f)&&e++}if(!c)throw Error("Cannot find closing comment tag to match: "+a.nodeValue);return null}function e(a,b){var d=c(a,b);return d?0<d.length?d[d.length-1].nextSibling:a.nextSibling:null}var g=v&&"\x3c!--test--\x3e"===v.createComment("test").text,h=g?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,
        k=g?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,f={ul:!0,ol:!0};a.f={Q:{},childNodes:function(a){return b(a)?c(a):a.childNodes},ja:function(c){if(b(c)){c=a.f.childNodes(c);for(var d=0,f=c.length;d<f;d++)a.removeNode(c[d])}else a.a.Ka(c)},T:function(c,d){if(b(c)){a.f.ja(c);for(var f=c.nextSibling,e=0,k=d.length;e<k;e++)f.parentNode.insertBefore(d[e],f)}else a.a.T(c,d)},Hb:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},Bb:function(c,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     d,f){f?b(c)?c.parentNode.insertBefore(d,f.nextSibling):f.nextSibling?c.insertBefore(d,f.nextSibling):c.appendChild(d):a.f.Hb(c,d)},firstChild:function(a){return b(a)?!a.nextSibling||d(a.nextSibling)?null:a.nextSibling:a.firstChild},nextSibling:function(a){b(a)&&(a=e(a));return a.nextSibling&&d(a.nextSibling)?null:a.nextSibling},gc:b,xc:function(a){return(a=(g?a.text:a.nodeValue).match(h))?a[1]:null},Fb:function(c){if(f[a.a.t(c)]){var k=c.firstChild;if(k){do if(1===k.nodeType){var g;g=k.firstChild;
        var h=null;if(g){do if(h)h.push(g);else if(b(g)){var t=e(g,!0);t?g=t:h=[g]}else d(g)&&(h=[g]);while(g=g.nextSibling)}if(g=h)for(h=k.nextSibling,t=0;t<g.length;t++)h?c.insertBefore(g[t],h):c.appendChild(g[t])}while(k=k.nextSibling)}}}}})();a.b("virtualElements",a.f);a.b("virtualElements.allowedBindings",a.f.Q);a.b("virtualElements.emptyNode",a.f.ja);a.b("virtualElements.insertAfter",a.f.Bb);a.b("virtualElements.prepend",a.f.Hb);a.b("virtualElements.setDomNodeChildren",a.f.T);(function(){a.J=function(){this.Yb=
    {}};a.a.extend(a.J.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute("data-bind")||a.g.getComponentNameForNode(b);case 8:return a.f.gc(b);default:return!1}},getBindings:function(b,d){var c=this.getBindingsString(b,d),c=c?this.parseBindingsString(c,d,b):null;return a.g.mb(c,b,d,!1)},getBindingAccessors:function(b,d){var c=this.getBindingsString(b,d),c=c?this.parseBindingsString(c,d,b,{valueAccessors:!0}):null;return a.g.mb(c,b,d,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");
        case 8:return a.f.xc(b);default:return null}},parseBindingsString:function(b,d,c,e){try{var g=this.Yb,h=b+(e&&e.valueAccessors||""),k;if(!(k=g[h])){var f,m="with($context){with($data||{}){return{"+a.h.ya(b,e)+"}}}";f=new Function("$context","$element",m);k=g[h]=f}return k(d,c)}catch(l){throw l.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+l.message,l;}}});a.J.instance=new a.J})();a.b("bindingProvider",a.J);(function(){function b(a){return function(){return a}}function d(a){return a()}
        function c(b){return a.a.na(a.k.B(b),function(a,c){return function(){return b()[c]}})}function e(a,b){return c(this.getBindings.bind(this,a,b))}function g(b,c,d){var f,e=a.f.firstChild(c),k=a.J.instance,g=k.preprocessNode;if(g){for(;f=e;)e=a.f.nextSibling(f),g.call(k,f);e=a.f.firstChild(c)}for(;f=e;)e=a.f.nextSibling(f),h(b,f,d)}function h(b,c,d){var e=!0,k=1===c.nodeType;k&&a.f.Fb(c);if(k&&d||a.J.instance.nodeHasBindings(c))e=f(c,null,b,d).shouldBindDescendants;e&&!l[a.a.t(c)]&&g(b,c,!k)}function k(b){var c=
            [],d={},f=[];a.a.G(b,function y(e){if(!d[e]){var k=a.getBindingHandler(e);k&&(k.after&&(f.push(e),a.a.u(k.after,function(c){if(b[c]){if(-1!==a.a.m(f,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+f.join(", "));y(c)}}),f.length--),c.push({key:e,zb:k}));d[e]=!0}});return c}function f(b,c,f,g){var m=a.a.e.get(b,q);if(!c){if(m)throw Error("You cannot apply bindings multiple times to the same element.");a.a.e.set(b,q,!0)}!m&&g&&a.Ob(b,f);var l;if(c&&"function"!==
            typeof c)l=c;else{var h=a.J.instance,n=h.getBindingAccessors||e,s=a.j(function(){(l=c?c(f,b):n.call(h,b,f))&&f.I&&f.I();return l},null,{o:b});l&&s.Z()||(s=null)}var v;if(l){var w=s?function(a){return function(){return d(s()[a])}}:function(a){return l[a]},A=function(){return a.a.na(s?s():l,d)};A.get=function(a){return l[a]&&d(w(a))};A.has=function(a){return a in l};g=k(l);a.a.u(g,function(c){var d=c.zb.init,e=c.zb.update,k=c.key;if(8===b.nodeType&&!a.f.Q[k])throw Error("The binding '"+k+"' cannot be used with virtual elements");
            try{"function"==typeof d&&a.k.B(function(){var a=d(b,w(k),A,f.$data,f);if(a&&a.controlsDescendantBindings){if(v!==p)throw Error("Multiple bindings ("+v+" and "+k+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");v=k}}),"function"==typeof e&&a.j(function(){e(b,w(k),A,f.$data,f)},null,{o:b})}catch(g){throw g.message='Unable to process binding "'+k+": "+l[k]+'"\nMessage: '+g.message,g;}})}return{shouldBindDescendants:v===p}}
        function m(b){return b&&b instanceof a.N?b:new a.N(b)}a.d={};var l={script:!0};a.getBindingHandler=function(b){return a.d[b]};a.N=function(b,c,d,f){var e=this,k="function"==typeof b&&!a.C(b),g,m=a.j(function(){var g=k?b():b,l=a.a.c(g);c?(c.I&&c.I(),a.a.extend(e,c),m&&(e.I=m)):(e.$parents=[],e.$root=l,e.ko=a);e.$rawData=g;e.$data=l;d&&(e[d]=l);f&&f(e,c,l);return e.$data},null,{Ia:function(){return g&&!a.a.ob(g)},o:!0});m.Z()&&(e.I=m,m.equalityComparer=null,g=[],m.Tb=function(b){g.push(b);a.a.w.da(b,
            function(b){a.a.ua(g,b);g.length||(m.K(),e.I=m=p)})})};a.N.prototype.createChildContext=function(b,c,d){return new a.N(b,this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)})};a.N.prototype.extend=function(b){return new a.N(this.I||this.$data,this,null,function(c,d){c.$rawData=d.$rawData;a.a.extend(c,"function"==typeof b?b():b)})};var q=a.a.e.F(),n=a.a.e.F();a.Ob=function(b,c){if(2==arguments.length)a.a.e.set(b,n,c),
            c.I&&c.I.Tb(b);else return a.a.e.get(b,n)};a.ra=function(b,c,d){1===b.nodeType&&a.f.Fb(b);return f(b,c,m(d),!0)};a.Wb=function(d,f,e){e=m(e);return a.ra(d,"function"===typeof f?c(f.bind(null,e,d)):a.a.na(f,b),e)};a.Ca=function(a,b){1!==b.nodeType&&8!==b.nodeType||g(m(a),b,!0)};a.pb=function(a,b){!w&&s.jQuery&&(w=s.jQuery);if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");b=b||s.document.body;h(m(a),
            b,!0)};a.Ha=function(b){switch(b.nodeType){case 1:case 8:var c=a.Ob(b);if(c)return c;if(b.parentNode)return a.Ha(b.parentNode)}return p};a.$b=function(b){return(b=a.Ha(b))?b.$data:p};a.b("bindingHandlers",a.d);a.b("applyBindings",a.pb);a.b("applyBindingsToDescendants",a.Ca);a.b("applyBindingAccessorsToNode",a.ra);a.b("applyBindingsToNode",a.Wb);a.b("contextFor",a.Ha);a.b("dataFor",a.$b)})();(function(b){function d(d,f){var e=g.hasOwnProperty(d)?g[d]:b,l;e||(e=g[d]=new a.P,c(d,function(a){h[d]=a;delete g[d];
        l?e.notifySubscribers(a):setTimeout(function(){e.notifySubscribers(a)},0)}),l=!0);e.U(f)}function c(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a)}):b(null)})}function e(c,d,g,l){l||(l=a.g.loaders.slice(0));var h=l.shift();if(h){var n=h[c];if(n){var t=!1;if(n.apply(h,d.concat(function(a){t?g(null):null!==a?g(a):e(c,d,g,l)}))!==b&&(t=!0,!h.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");
    }else e(c,d,g,l)}else g(null)}var g={},h={};a.g={get:function(a,c){var e=h.hasOwnProperty(a)?h[a]:b;e?setTimeout(function(){c(e)},0):d(a,c)},tb:function(a){delete h[a]},jb:e};a.g.loaders=[];a.b("components",a.g);a.b("components.get",a.g.get);a.b("components.clearCachedDefinition",a.g.tb)})();(function(){function b(b,c,d,e){function k(){0===--u&&e(h)}var h={},u=2,r=d.template;d=d.viewModel;r?g(c,r,function(c){a.g.jb("loadTemplate",[b,c],function(a){h.template=a;k()})}):k();d?g(c,d,function(c){a.g.jb("loadViewModel",
        [b,c],function(a){h[f]=a;k()})}):k()}function d(a,b,c){if("function"===typeof b)c(function(a){return new b(a)});else if("function"===typeof b[f])c(b[f]);else if("instance"in b){var e=b.instance;c(function(){return e})}else"viewModel"in b?d(a,b.viewModel,c):a("Unknown viewModel value: "+b)}function c(b){switch(a.a.t(b)){case "script":return a.a.ba(b.text);case "textarea":return a.a.ba(b.value);case "template":if(e(b.content))return a.a.ia(b.content.childNodes)}return a.a.ia(b.childNodes)}function e(a){return s.DocumentFragment?
        a instanceof DocumentFragment:a&&11===a.nodeType}function g(a,b,c){"string"===typeof b.require?N||s.require?(N||s.require)([b.require],c):a("Uses require, but no AMD loader is present"):c(b)}function h(a){return function(b){throw Error("Component '"+a+"': "+b);}}var k={};a.g.tc=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.g.Qa(b))throw Error("Component "+b+" is already registered");k[b]=c};a.g.Qa=function(a){return a in k};a.g.wc=function(b){delete k[b];a.g.tb(b)};a.g.ub={getConfig:function(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                b){b(k.hasOwnProperty(a)?k[a]:null)},loadComponent:function(a,c,d){var e=h(a);g(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,d,f){b=h(b);if("string"===typeof d)f(a.a.ba(d));else if(d instanceof Array)f(d);else if(e(d))f(a.a.S(d.childNodes));else if(d.element)if(d=d.element,s.HTMLElement?d instanceof HTMLElement:d&&d.tagName&&1===d.nodeType)f(c(d));else if("string"===typeof d){var k=v.getElementById(d);k?f(c(k)):b("Cannot find element with ID "+d)}else b("Unknown element type: "+d);else b("Unknown template value: "+
        d)},loadViewModel:function(a,b,c){d(h(a),b,c)}};var f="createViewModel";a.b("components.register",a.g.tc);a.b("components.isRegistered",a.g.Qa);a.b("components.unregister",a.g.wc);a.b("components.defaultLoader",a.g.ub);a.g.loaders.push(a.g.ub);a.g.Ub=k})();(function(){function b(b,e){var g=b.getAttribute("params");if(g){var g=d.parseBindingsString(g,e,b,{valueAccessors:!0,bindingParams:!0}),g=a.a.na(g,function(d){return a.s(d,null,{o:b})}),h=a.a.na(g,function(d){return d.Z()?a.s(function(){return a.a.c(d())},
        null,{o:b}):d.v()});h.hasOwnProperty("$raw")||(h.$raw=g);return h}return{$raw:{}}}a.g.getComponentNameForNode=function(b){b=a.a.t(b);return a.g.Qa(b)&&b};a.g.mb=function(c,d,g,h){if(1===d.nodeType){var k=a.g.getComponentNameForNode(d);if(k){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');var f={name:k,params:b(d,g)};c.component=h?function(){return f}:f}}return c};var d=new a.J;9>a.a.L&&(a.g.register=function(a){return function(b){v.createElement(b);
        return a.apply(this,arguments)}}(a.g.register),v.createDocumentFragment=function(b){return function(){var d=b(),g=a.g.Ub,h;for(h in g)g.hasOwnProperty(h)&&d.createElement(h);return d}}(v.createDocumentFragment))})();(function(){var b=0;a.d.component={init:function(d,c,e,g,h){function k(){var a=f&&f.dispose;"function"===typeof a&&a.call(f);m=null}var f,m;a.a.w.da(d,k);a.s(function(){var e=a.a.c(c()),g,n;"string"===typeof e?g=e:(g=a.a.c(e.name),n=a.a.c(e.params));if(!g)throw Error("No component name specified");
        var t=m=++b;a.g.get(g,function(b){if(m===t){k();if(!b)throw Error("Unknown component '"+g+"'");var c=b.template;if(!c)throw Error("Component '"+g+"' has no template");c=a.a.ia(c);a.f.T(d,c);var c=n,e=b.createViewModel;b=e?e.call(b,c,{element:d}):c;c=h.createChildContext(b);f=b;a.Ca(c,d)}})},null,{o:d});return{controlsDescendantBindings:!0}}};a.f.Q.component=!0})();var Q={"class":"className","for":"htmlFor"};a.d.attr={update:function(b,d){var c=a.a.c(d())||{};a.a.G(c,function(c,d){d=a.a.c(d);var h=
        !1===d||null===d||d===p;h&&b.removeAttribute(c);8>=a.a.L&&c in Q?(c=Q[c],h?b.removeAttribute(c):b[c]=d):h||b.setAttribute(c,d.toString());"name"===c&&a.a.Mb(b,h?"":d.toString())})}};(function(){a.d.checked={after:["value","attr"],init:function(b,d,c){function e(){var e=b.checked,k=q?h():e;if(!a.Y.ma()&&(!f||e)){var g=a.k.B(d);m?l!==k?(e&&(a.a.ea(g,k,!0),a.a.ea(g,l,!1)),l=k):a.a.ea(g,k,e):a.h.pa(g,c,"checked",k,!0)}}function g(){var c=a.a.c(d());b.checked=m?0<=a.a.m(c,h()):k?c:h()===c}var h=a.Ib(function(){return c.has("checkedValue")?
        a.a.c(c.get("checkedValue")):c.has("value")?a.a.c(c.get("value")):b.value}),k="checkbox"==b.type,f="radio"==b.type;if(k||f){var m=k&&a.a.c(d())instanceof Array,l=m?h():p,q=f||m;f&&!b.name&&a.d.uniqueName.init(b,function(){return!0});a.s(e,null,{o:b});a.a.n(b,"click",e);a.s(g,null,{o:b})}}};a.h.V.checked=!0;a.d.checkedValue={update:function(b,d){b.value=a.a.c(d())}}})();a.d.css={update:function(b,d){var c=a.a.c(d());"object"==typeof c?a.a.G(c,function(c,d){d=a.a.c(d);a.a.Ba(b,c,d)}):(c=String(c||""),
        a.a.Ba(b,b.__ko__cssValue,!1),b.__ko__cssValue=c,a.a.Ba(b,c,!0))}};a.d.enable={update:function(b,d){var c=a.a.c(d());c&&b.disabled?b.removeAttribute("disabled"):c||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,d){a.d.enable.update(b,function(){return!a.a.c(d())})}};a.d.event={init:function(b,d,c,e,g){var h=d()||{};a.a.G(h,function(k){"string"==typeof k&&a.a.n(b,k,function(b){var h,l=d()[k];if(l){try{var q=a.a.S(arguments);e=g.$data;q.unshift(e);h=l.apply(e,q)}finally{!0!==h&&(b.preventDefault?
        b.preventDefault():b.returnValue=!1)}!1===c.get(k+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.d.foreach={Eb:function(b){return function(){var d=b(),c=a.a.Xa(d);if(!c||"number"==typeof c.length)return{foreach:d,templateEngine:a.O.Oa};a.a.c(d);return{foreach:c.data,as:c.as,includeDestroyed:c.includeDestroyed,afterAdd:c.afterAdd,beforeRemove:c.beforeRemove,afterRender:c.afterRender,beforeMove:c.beforeMove,afterMove:c.afterMove,templateEngine:a.O.Oa}}},init:function(b,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              d){return a.d.template.init(b,a.d.foreach.Eb(d))},update:function(b,d,c,e,g){return a.d.template.update(b,a.d.foreach.Eb(d),c,e,g)}};a.h.ha.foreach=!1;a.f.Q.foreach=!0;a.d.hasfocus={init:function(b,d,c){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(h){g=f.body}e=g===b}f=d();a.h.pa(f,c,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var g=e.bind(null,!0),h=e.bind(null,!1);a.a.n(b,"focus",g);a.a.n(b,"focusin",
        g);a.a.n(b,"blur",h);a.a.n(b,"focusout",h)},update:function(b,d){var c=!!a.a.c(d());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===c||(c?b.focus():b.blur(),a.k.B(a.a.oa,null,[b,c?"focusin":"focusout"]))}};a.h.V.hasfocus=!0;a.d.hasFocus=a.d.hasfocus;a.h.V.hasFocus=!0;a.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,d){a.a.$a(b,d())}};I("if");I("ifnot",!1,!0);I("with",!0,!1,function(a,d){return a.createChildContext(d)});var K={};a.d.options={init:function(b){if("select"!==
        a.a.t(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,d,c){function e(){return a.a.ta(b.options,function(a){return a.selected})}function g(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function h(c,d){if(q.length){var e=0<=a.a.m(q,a.i.q(d[0]));a.a.Nb(d[0],e);n&&!e&&a.k.B(a.a.oa,null,[b,"change"])}}var k=0!=b.length&&b.multiple?b.scrollTop:null,f=a.a.c(d()),m=c.get("optionsIncludeDestroyed");
        d={};var l,q;q=b.multiple?a.a.Da(e(),a.i.q):0<=b.selectedIndex?[a.i.q(b.options[b.selectedIndex])]:[];f&&("undefined"==typeof f.length&&(f=[f]),l=a.a.ta(f,function(b){return m||b===p||null===b||!a.a.c(b._destroy)}),c.has("optionsCaption")&&(f=a.a.c(c.get("optionsCaption")),null!==f&&f!==p&&l.unshift(K)));var n=!1;d.beforeRemove=function(a){b.removeChild(a)};f=h;c.has("optionsAfterRender")&&(f=function(b,d){h(0,d);a.k.B(c.get("optionsAfterRender"),null,[d[0],b!==K?b:p])});a.a.Za(b,l,function(d,e,f){f.length&&
        (q=f[0].selected?[a.i.q(f[0])]:[],n=!0);e=b.ownerDocument.createElement("option");d===K?(a.a.bb(e,c.get("optionsCaption")),a.i.ca(e,p)):(f=g(d,c.get("optionsValue"),d),a.i.ca(e,a.a.c(f)),d=g(d,c.get("optionsText"),f),a.a.bb(e,d));return[e]},d,f);a.k.B(function(){c.get("valueAllowUnset")&&c.has("value")?a.i.ca(b,a.a.c(c.get("value")),!0):(b.multiple?q.length&&e().length<q.length:q.length&&0<=b.selectedIndex?a.i.q(b.options[b.selectedIndex])!==q[0]:q.length||0<=b.selectedIndex)&&a.a.oa(b,"change")});
        a.a.dc(b);k&&20<Math.abs(k-b.scrollTop)&&(b.scrollTop=k)}};a.d.options.Va=a.a.e.F();a.d.selectedOptions={after:["options","foreach"],init:function(b,d,c){a.a.n(b,"change",function(){var e=d(),g=[];a.a.u(b.getElementsByTagName("option"),function(b){b.selected&&g.push(a.i.q(b))});a.h.pa(e,c,"selectedOptions",g)})},update:function(b,d){if("select"!=a.a.t(b))throw Error("values binding applies only to SELECT elements");var c=a.a.c(d());c&&"number"==typeof c.length&&a.a.u(b.getElementsByTagName("option"),
        function(b){var d=0<=a.a.m(c,a.i.q(b));a.a.Nb(b,d)})}};a.h.V.selectedOptions=!0;a.d.style={update:function(b,d){var c=a.a.c(d()||{});a.a.G(c,function(c,d){d=a.a.c(d);if(null===d||d===p||!1===d)d="";b.style[c]=d})}};a.d.submit={init:function(b,d,c,e,g){if("function"!=typeof d())throw Error("The value for a submit binding must be a function");a.a.n(b,"submit",function(a){var c,e=d();try{c=e.call(g.$data,b)}finally{!0!==c&&(a.preventDefault?a.preventDefault():a.returnValue=!1)}})}};a.d.text={init:function(){return{controlsDescendantBindings:!0}},
        update:function(b,d){a.a.bb(b,d())}};a.f.Q.text=!0;(function(){if(s&&s.navigator)var b=function(a){if(a)return parseFloat(a[1])},d=s.opera&&s.opera.version&&parseInt(s.opera.version()),c=s.navigator.userAgent,e=b(c.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),g=b(c.match(/Firefox\/([^ ]*)/));if(10>a.a.L)var h=a.a.e.F(),k=a.a.e.F(),f=function(b){var c=this.activeElement;(c=c&&a.a.e.get(c,k))&&c(b)},m=function(b,c){var d=b.ownerDocument;a.a.e.get(d,h)||(a.a.e.set(d,h,!0),a.a.n(d,"selectionchange",
        f));a.a.e.set(b,k,c)};a.d.textInput={init:function(b,c,f){function k(c,d){a.a.n(b,c,d)}function h(){var d=a.a.c(c());if(null===d||d===p)d="";v!==p&&d===v?setTimeout(h,4):b.value!==d&&(s=d,b.value=d)}function u(){y||(v=b.value,y=setTimeout(r,4))}function r(){clearTimeout(y);v=y=p;var d=b.value;s!==d&&(s=d,a.h.pa(c(),f,"textInput",d))}var s=b.value,y,v;10>a.a.L?(k("propertychange",function(a){"value"===a.propertyName&&r()}),8==a.a.L&&(k("keyup",r),k("keydown",r)),8<=a.a.L&&(m(b,r),k("dragend",u))):
        (k("input",r),5>e&&"textarea"===a.a.t(b)?(k("keydown",u),k("paste",u),k("cut",u)):11>d?k("keydown",u):4>g&&(k("DOMAutoComplete",r),k("dragdrop",r),k("drop",r)));k("change",r);a.s(h,null,{o:b})}};a.h.V.textInput=!0;a.d.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.d.uniqueName={init:function(b,d){if(d()){var c="ko_unique_"+ ++a.d.uniqueName.Zb;a.a.Mb(b,c)}}};a.d.uniqueName.Zb=0;a.d.value={after:["options","foreach"],init:function(b,d,c){if("input"!=b.tagName.toLowerCase()||"checkbox"!=
        b.type&&"radio"!=b.type){var e=["change"],g=c.get("valueUpdate"),h=!1,k=null;g&&("string"==typeof g&&(g=[g]),a.a.ga(e,g),e=a.a.rb(e));var f=function(){k=null;h=!1;var e=d(),f=a.i.q(b);a.h.pa(e,c,"value",f)};!a.a.L||"input"!=b.tagName.toLowerCase()||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.m(e,"propertychange")||(a.a.n(b,"propertychange",function(){h=!0}),a.a.n(b,"focus",function(){h=!1}),a.a.n(b,"blur",function(){h&&f()}));a.a.u(e,function(c){var d=f;a.a.vc(c,
        "after")&&(d=function(){k=a.i.q(b);setTimeout(f,0)},c=c.substring(5));a.a.n(b,c,d)});var m=function(){var e=a.a.c(d()),f=a.i.q(b);if(null!==k&&e===k)setTimeout(m,0);else if(e!==f)if("select"===a.a.t(b)){var g=c.get("valueAllowUnset"),f=function(){a.i.ca(b,e,g)};f();g||e===a.i.q(b)?setTimeout(f,0):a.k.B(a.a.oa,null,[b,"change"])}else a.i.ca(b,e)};a.s(m,null,{o:b})}else a.ra(b,{checkedValue:d})},update:function(){}};a.h.V.value=!0;a.d.visible={update:function(b,d){var c=a.a.c(d()),e="none"!=b.style.display;
        c&&!e?b.style.display="":!c&&e&&(b.style.display="none")}};(function(b){a.d[b]={init:function(d,c,e,g,h){return a.d.event.init.call(this,d,function(){var a={};a[b]=c();return a},e,g,h)}}})("click");a.H=function(){};a.H.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.H.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.H.prototype.makeTemplateSource=function(b,d){if("string"==typeof b){d=d||v;var c=
        d.getElementById(b);if(!c)throw Error("Cannot find template with ID "+b);return new a.r.l(c)}if(1==b.nodeType||8==b.nodeType)return new a.r.fa(b);throw Error("Unknown template type: "+b);};a.H.prototype.renderTemplate=function(a,d,c,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,d,c)};a.H.prototype.isTemplateRewritten=function(a,d){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,d).data("isRewritten")};a.H.prototype.rewriteTemplate=function(a,d,c){a=this.makeTemplateSource(a,
        c);d=d(a.text());a.text(d);a.data("isRewritten",!0)};a.b("templateEngine",a.H);a.fb=function(){function b(b,c,d,k){b=a.h.Wa(b);for(var f=a.h.ha,m=0;m<b.length;m++){var l=b[m].key;if(f.hasOwnProperty(l)){var q=f[l];if("function"===typeof q){if(l=q(b[m].value))throw Error(l);}else if(!q)throw Error("This template engine does not support the '"+l+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.h.ya(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+
        "')";return k.createJavaScriptEvaluatorBlock(d)+c}var d=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,c=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{ec:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.fb.nc(b,c)},d)},nc:function(a,g){return a.replace(d,function(a,c,d,e,l){return b(l,c,d,g)}).replace(c,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",g)})},Xb:function(b,c){return a.D.Ua(function(d,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   k){var f=d.nextSibling;f&&f.nodeName.toLowerCase()===c&&a.ra(f,b,k)})}}}();a.b("__tr_ambtns",a.fb.Xb);(function(){a.r={};a.r.l=function(a){this.l=a};a.r.l.prototype.text=function(){var b=a.a.t(this.l),b="script"===b?"text":"textarea"===b?"value":"innerHTML";if(0==arguments.length)return this.l[b];var d=arguments[0];"innerHTML"===b?a.a.$a(this.l,d):this.l[b]=d};var b=a.a.e.F()+"_";a.r.l.prototype.data=function(c){if(1===arguments.length)return a.a.e.get(this.l,b+c);a.a.e.set(this.l,b+c,arguments[1])};
        var d=a.a.e.F();a.r.fa=function(a){this.l=a};a.r.fa.prototype=new a.r.l;a.r.fa.prototype.text=function(){if(0==arguments.length){var b=a.a.e.get(this.l,d)||{};b.gb===p&&b.Ga&&(b.gb=b.Ga.innerHTML);return b.gb}a.a.e.set(this.l,d,{gb:arguments[0]})};a.r.l.prototype.nodes=function(){if(0==arguments.length)return(a.a.e.get(this.l,d)||{}).Ga;a.a.e.set(this.l,d,{Ga:arguments[0]})};a.b("templateSources",a.r);a.b("templateSources.domElement",a.r.l);a.b("templateSources.anonymousTemplate",a.r.fa)})();(function(){function b(b,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                c,d){var e;for(c=a.f.nextSibling(c);b&&(e=b)!==c;)b=a.f.nextSibling(e),d(e,b)}function d(c,d){if(c.length){var e=c[0],g=c[c.length-1],h=e.parentNode,n=a.J.instance,t=n.preprocessNode;if(t){b(e,g,function(a,b){var c=a.previousSibling,d=t.call(n,a);d&&(a===e&&(e=d[0]||b),a===g&&(g=d[d.length-1]||c))});c.length=0;if(!e)return;e===g?c.push(e):(c.push(e,g),a.a.ka(c,h))}b(e,g,function(b){1!==b.nodeType&&8!==b.nodeType||a.pb(d,b)});b(e,g,function(b){1!==b.nodeType&&8!==b.nodeType||a.D.Sb(b,[d])});a.a.ka(c,
        h)}}function c(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,h,l,q){q=q||{};var n=b&&c(b),n=n&&n.ownerDocument,t=q.templateEngine||g;a.fb.ec(h,t,n);h=t.renderTemplate(h,l,q,n);if("number"!=typeof h.length||0<h.length&&"number"!=typeof h[0].nodeType)throw Error("Template engine must return an array of DOM nodes");n=!1;switch(e){case "replaceChildren":a.f.T(b,h);n=!0;break;case "replaceNode":a.a.Lb(b,h);n=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+
        e);}n&&(d(h,l),q.afterRender&&a.k.B(q.afterRender,null,[h,l.$data]));return h}var g;a.ab=function(b){if(b!=p&&!(b instanceof a.H))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.Ya=function(b,d,h,l,q){h=h||{};if((h.templateEngine||g)==p)throw Error("Set a template engine before calling renderTemplate");q=q||"replaceChildren";if(l){var n=c(l);return a.j(function(){var g=d&&d instanceof a.N?d:new a.N(a.a.c(d)),p=a.C(b)?b():"function"===typeof b?b(g.$data,g):b,g=e(l,q,p,g,h);
        "replaceNode"==q&&(l=g,n=c(l))},null,{Ia:function(){return!n||!a.a.Ja(n)},o:n&&"replaceNode"==q?n.parentNode:n})}return a.D.Ua(function(c){a.Ya(b,d,h,c,"replaceNode")})};a.uc=function(b,c,g,h,q){function n(a,b){d(b,s);g.afterRender&&g.afterRender(b,a)}function t(c,d){s=q.createChildContext(c,g.as,function(a){a.$index=d});var f=a.C(b)?b():"function"===typeof b?b(c,s):b;return e(null,"ignoreTargetNode",f,s,g)}var s;return a.j(function(){var b=a.a.c(c)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.ta(b,
        function(b){return g.includeDestroyed||b===p||null===b||!a.a.c(b._destroy)});a.k.B(a.a.Za,null,[h,b,t,g,n])},null,{o:h})};var h=a.a.e.F();a.d.template={init:function(b,c){var d=a.a.c(c());"string"==typeof d||d.name?a.f.ja(b):(d=a.f.childNodes(b),d=a.a.oc(d),(new a.r.fa(b)).nodes(d));return{controlsDescendantBindings:!0}},update:function(b,c,d,e,g){var n=c(),t;c=a.a.c(n);d=!0;e=null;"string"==typeof c?c={}:(n=c.name,"if"in c&&(d=a.a.c(c["if"])),d&&"ifnot"in c&&(d=!a.a.c(c.ifnot)),t=a.a.c(c.data));
        "foreach"in c?e=a.uc(n||b,d&&c.foreach||[],c,b,g):d?(g="data"in c?g.createChildContext(t,c.as):g,e=a.Ya(n||b,g,c,b)):a.f.ja(b);g=e;(t=a.a.e.get(b,h))&&"function"==typeof t.K&&t.K();a.a.e.set(b,h,g&&g.Z()?g:p)}};a.h.ha.template=function(b){b=a.h.Wa(b);return 1==b.length&&b[0].unknown||a.h.lc(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.f.Q.template=!0})();a.b("setTemplateEngine",a.ab);a.b("renderTemplate",a.Ya);a.a.wb=function(a,d,c){if(a.length&&
        d.length){var e,g,h,k,f;for(e=g=0;(!c||e<c)&&(k=a[g]);++g){for(h=0;f=d[h];++h)if(k.value===f.value){k.moved=f.index;f.moved=k.index;d.splice(h,1);e=h=0;break}e+=h}}};a.a.Fa=function(){function b(b,c,e,g,h){var k=Math.min,f=Math.max,m=[],l,q=b.length,n,p=c.length,s=p-q||1,u=q+p+1,r,v,w;for(l=0;l<=q;l++)for(v=r,m.push(r=[]),w=k(p,l+s),n=f(0,l-1);n<=w;n++)r[n]=n?l?b[l-1]===c[n-1]?v[n-1]:k(v[n]||u,r[n-1]||u)+1:n+1:l+1;k=[];f=[];s=[];l=q;for(n=p;l||n;)p=m[l][n]-1,n&&p===m[l][n-1]?f.push(k[k.length]={status:e,
        value:c[--n],index:n}):l&&p===m[l-1][n]?s.push(k[k.length]={status:g,value:b[--l],index:l}):(--n,--l,h.sparse||k.push({status:"retained",value:c[n]}));a.a.wb(f,s,10*q);return k.reverse()}return function(a,c,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];c=c||[];return a.length<=c.length?b(a,c,"added","deleted",e):b(c,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.Fa);(function(){function b(b,d,g,h,k){var f=[],m=a.j(function(){var l=d(g,k,a.a.ka(f,b))||[];0<f.length&&(a.a.Lb(f,
        l),h&&a.k.B(h,null,[g,l,k]));f.length=0;a.a.ga(f,l)},null,{o:b,Ia:function(){return!a.a.ob(f)}});return{$:f,j:m.Z()?m:p}}var d=a.a.e.F();a.a.Za=function(c,e,g,h,k){function f(b,d){x=q[d];r!==d&&(A[b]=x);x.Na(r++);a.a.ka(x.$,c);s.push(x);w.push(x)}function m(b,c){if(b)for(var d=0,e=c.length;d<e;d++)c[d]&&a.a.u(c[d].$,function(a){b(a,d,c[d].sa)})}e=e||[];h=h||{};var l=a.a.e.get(c,d)===p,q=a.a.e.get(c,d)||[],n=a.a.Da(q,function(a){return a.sa}),t=a.a.Fa(n,e,h.dontLimitMoves),s=[],u=0,r=0,v=[],w=[];e=
        [];for(var A=[],n=[],x,B=0,D,F;D=t[B];B++)switch(F=D.moved,D.status){case "deleted":F===p&&(x=q[u],x.j&&x.j.K(),v.push.apply(v,a.a.ka(x.$,c)),h.beforeRemove&&(e[B]=x,w.push(x)));u++;break;case "retained":f(B,u++);break;case "added":F!==p?f(B,F):(x={sa:D.value,Na:a.p(r++)},s.push(x),w.push(x),l||(n[B]=x))}m(h.beforeMove,A);a.a.u(v,h.beforeRemove?a.R:a.removeNode);for(var B=0,l=a.f.firstChild(c),G;x=w[B];B++){x.$||a.a.extend(x,b(c,g,x.sa,k,x.Na));for(u=0;t=x.$[u];l=t.nextSibling,G=t,u++)t!==l&&a.f.Bb(c,
        t,G);!x.ic&&k&&(k(x.sa,x.$,x.Na),x.ic=!0)}m(h.beforeRemove,e);m(h.afterMove,A);m(h.afterAdd,n);a.a.e.set(c,d,s)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Za);a.O=function(){this.allowTemplateRewriting=!1};a.O.prototype=new a.H;a.O.prototype.renderTemplateSource=function(b){var d=(9>a.a.L?0:b.nodes)?b.nodes():null;if(d)return a.a.S(d.cloneNode(!0).childNodes);b=b.text();return a.a.ba(b)};a.O.Oa=new a.O;a.ab(a.O.Oa);a.b("nativeTemplateEngine",a.O);(function(){a.Sa=function(){var a=this.kc=
        function(){if(!w||!w.tmpl)return 0;try{if(0<=w.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,e,g){g=g||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=w.template(null,"{{ko_with $item.koBindingContext}}"+h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=w.extend({koBindingContext:e},g.templateOptions);e=w.tmpl(h,
        b,e);e.appendTo(v.createElement("div"));w.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){v.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(w.tmpl.tag.ko_code={open:"__.push($1 || '');"},w.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.Sa.prototype=new a.H;var b=new a.Sa;0<b.kc&&a.ab(b);a.b("jqueryTmplTemplateEngine",a.Sa)})()})})();})();
/**
 * Knockout UI https://github.com/gvas/knockout-jqueryui
 */
window.kojqui={version:"2.0.0"},function(a,b){"use strict";a.kojqui.utils=b(a.jQuery,a.ko,a.jQuery.ui.core)}(this,function(a,b){"use strict";var c,d,e,f;return c=(a.ui.version||"").match(/^(\d)\.(\d+)/),d=c?{major:parseInt(c[1],10),minor:parseInt(c[2],10)}:null,e=Object.create||function(a){function b(){}return b.prototype=a,new b},f=function(a){var c=new a;b.bindingHandlers[c.widgetName]={init:c.init.bind(c),update:c.update.bind(c)}},{uiVersion:d,createObject:e,register:f}}),function(a,b){"use strict";a.kojqui.BindingHandler=b(a.jQuery,a.ko,a.jQuery.ui.widget)}(this,function(a,b){"use strict";var c,d,e,f;return c="__kojqui_options",d=function(a,c){var d={};return b.utils.arrayForEach(c,function(c){void 0!==a[c]&&(d[c]=b.utils.unwrapObservable(a[c]))}),d},e=function(c,d,e){b.isObservable(e.refreshOn)&&b.computed({read:function(){e.refreshOn(),a(d)[c]("refresh")},disposeWhenNodeIsRemoved:d})},f=function(a){this.widgetName=a,this.widgetEventPrefix=a,this.options=[],this.events=[],this.hasRefresh=!1},f.prototype.init=function(f,g,h,i,j){var k,l,m,n;return k=this.widgetName,l=g(),m=d(l,this.options),n=d(l,this.events),b.applyBindingsToDescendants(j,f),b.utils.domData.set(f,c,m),a.each(n,function(a,b){n[a]=b.bind(i)}),a(f)[k](b.utils.extend(m,n)),this.hasRefresh&&e(k,f,l),b.isWriteableObservable(l.widget)&&l.widget(a(f)),b.utils.domNodeDisposal.addDisposeCallback(f,function(){a(f)[k]("destroy")}),{controlsDescendantBindings:!0}},f.prototype.update=function(e,f){var g,h,i,j;g=this.widgetName,h=f(),i=b.utils.domData.get(e,c),j=d(h,this.options),a.each(j,function(b,c){c!==i[b]&&a(e)[g]("option",b,j[b])}),b.utils.domData.set(e,c,j)},f.prototype.on=function(c,d,e){var f;f=d===this.widgetEventPrefix?d:this.widgetEventPrefix+d,f=[f.toLowerCase(),".",this.widgetName].join(""),a(c).on(f,e),b.utils.domNodeDisposal.addDisposeCallback(c,function(){a(c).off(f)})},f}),function(a,b){"use strict";a.kojqui.Accordion=b(a.jQuery,a.ko,a.kojqui.utils,a.kojqui.BindingHandler,a.jQuery.ui.accordion)}(this,function(a,b,c,d){"use strict";var e=function(){d.call(this,"accordion"),1===c.uiVersion.major&&8===c.uiVersion.minor?(this.options=["active","animated","autoHeight","clearStyle","collapsible","disabled","event","fillSpace","header","icons","navigation","navigationFilter"],this.events=["change","changestart","create"],this.hasRefresh=!1,this.eventToWatch="change"):(this.options=["active","animate","collapsible","disabled","event","header","heightStyle","icons"],this.events=["activate","beforeActivate","create"],this.hasRefresh=!0,this.eventToWatch="activate")};return e.prototype=c.createObject(d.prototype),e.prototype.constructor=e,e.prototype.init=function(c,e){var f,g;return f=this.widgetName,g=e(),d.prototype.init.apply(this,arguments),b.isWriteableObservable(g.active)&&this.on(c,this.eventToWatch,function(){g.active(a(c)[f]("option","active"))}),{controlsDescendantBindings:!0}},c.register(e),e}),function(a,b){"use strict";a.kojqui.Autocomplete=b(a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.autocomplete)}(this,function(a,b){"use strict";var c=function(){a.call(this,"autocomplete"),this.options=["appendTo","autoFocus","delay","disabled","minLength","position","source"],this.events=1===b.uiVersion.major&&8===b.uiVersion.minor?["change","close","create","focus","open","search","select"]:["change","close","create","focus","open","response","search","select"]};return c.prototype=b.createObject(a.prototype),c.prototype.constructor=c,b.register(c),c}),function(a,b){"use strict";a.kojqui.Button=b(a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.button)}(this,function(a,b){"use strict";var c=function(){a.call(this,"button"),this.options=["disabled","icons","label","text"],this.events=["create"],this.hasRefresh=!0};return c.prototype=b.createObject(a.prototype),c.prototype.constructor=c,b.register(c),c}),function(a,b){"use strict";a.kojqui.Buttonset=b(a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.button)}(this,function(a,b){"use strict";var c=function(){a.call(this,"buttonset"),this.options=["items","disabled"],this.events=["create"],this.hasRefresh=!0};return c.prototype=b.createObject(a.prototype),c.prototype.constructor=c,b.register(c),c}),function(a,b){"use strict";a.kojqui.Datepicker=b(a.jQuery,a.ko,a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.datepicker)}(this,function(a,b,c,d){"use strict";var e=function(){c.call(this,"datepicker"),this.options=["altField","altFormat","appendText","autoSize","buttonImage","buttonImageOnly","buttonText","calculateWeek","changeMonth","changeYear","closeText","constrainInput","currentText","dateFormat","dayNames","dayNamesMin","dayNamesShort","defaultDate","duration","firstDay","gotoCurrent","hideIfNoPrevNext","isRTL","maxDate","minDate","monthNames","monthNamesShort","navigationAsDateFormat","nextText","numberOfMonths","prevText","selectOtherMonths","shortYearCutoff","showAnim","showButtonPanel","showCurrentAtPos","showMonthAfterYear","showOn","showOptions","showOtherMonths","showWeek","stepMonths","weekHeader","yearRange","yearSuffix","beforeShow","beforeShowDay","onChangeMonthYear","onClose","onSelect"],this.hasRefresh=!0};return e.prototype=d.createObject(c.prototype),e.prototype.constructor=e,e.prototype.init=function(d,e){var f,g,h,i,j;return c.prototype.init.apply(this,arguments),f=this.widgetName,g=e(),h=b.utils.unwrapObservable(g.value),h&&a(d)[f]("setDate",h),b.isObservable(g.value)&&(i=g.value.subscribe(function(b){a(d)[f]("setDate",b)}),b.utils.domNodeDisposal.addDisposeCallback(d,function(){i.dispose()})),b.isWriteableObservable(g.value)&&(j=a(d)[f]("option","onSelect"),a(d)[f]("option","onSelect",function(b){var c,e;c=a(d)[f]("option","dateFormat"),e=a.datepicker.parseDate(c,b),g.value(e),"function"==typeof j&&j.apply(this,Array.prototype.slice.call(arguments))})),{controlsDescendantBindings:!0}},d.register(e),e}),function(a,b){"use strict";a.kojqui.Dialog=b(a.jQuery,a.ko,a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.dialog)}(this,function(a,b,c,d){"use strict";var e=function(){c.call(this,"dialog"),1===d.uiVersion.major&&8===d.uiVersion.minor?(this.options=["autoOpen","buttons","closeOnEscape","closeText","dialogClass","disabled","draggable","height","maxHeight","maxWidth","minHeight","minWidth","modal","position","resizable","show","stack","title","width","zIndex"],this.events=["beforeClose","create","open","focus","dragStart","drag","dragStop","resizeStart","resize","resizeStop","close"]):1===d.uiVersion.major&&9===d.uiVersion.minor?(this.options=["autoOpen","buttons","closeOnEscape","closeText","dialogClass","draggable","height","hide","maxHeight","maxWidth","minHeight","minWidth","modal","position","resizable","show","stack","title","width","zIndex"],this.events=["beforeClose","create","open","focus","dragStart","drag","dragStop","resizeStart","resize","resizeStop","close"]):(this.options=["appendTo","autoOpen","buttons","closeOnEscape","closeText","dialogClass","draggable","height","hide","maxHeight","maxWidth","minHeight","minWidth","modal","position","resizable","show","title","width"],this.events=["beforeClose","create","open","focus","dragStart","drag","dragStop","resizeStart","resize","resizeStop","close"])};return e.prototype=d.createObject(c.prototype),e.prototype.constructor=e,e.prototype.init=function(d,e){var f,g;return f=document.createElement("DIV"),f.style.display="none",d.parentNode.insertBefore(f,d),b.utils.domNodeDisposal.addDisposeCallback(f,function(){b.removeNode(d)}),c.prototype.init.apply(this,arguments),g=e(),g.isOpen&&b.computed({read:function(){b.utils.unwrapObservable(g.isOpen)?a(d)[this.widgetName]("open"):a(d)[this.widgetName]("close")},disposeWhenNodeIsRemoved:d,owner:this}),b.isWriteableObservable(g.isOpen)&&(this.on(d,"open",function(){g.isOpen(!0)}),this.on(d,"close",function(){g.isOpen(!1)})),b.isWriteableObservable(g.width)&&this.on(d,"resizestop",function(a,b){g.width(Math.round(b.size.width))}),b.isWriteableObservable(g.height)&&this.on(d,"resizestop",function(a,b){g.height(Math.round(b.size.height))}),{controlsDescendantBindings:!0}},d.register(e),e}),function(a,b){"use strict";a.kojqui.Menu=b(a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.menu)}(this,function(a,b){"use strict";var c=function(){a.call(this,"menu"),this.options=1===b.uiVersion.major&&b.uiVersion.minor<11?["disabled","icons","menus","position","role"]:["disabled","icons","items","menus","position","role"],this.events=["blur","create","focus","select"],this.hasRefresh=!0};return c.prototype=b.createObject(a.prototype),c.prototype.constructor=c,b.register(c),c}),function(a,b){"use strict";a.kojqui.Progressbar=b(a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.progressbar)}(this,function(a,b){"use strict";var c=function(){a.call(this,"progressbar"),this.events=["change","create","complete"],this.hasRefresh=!0,this.options=1===b.uiVersion.major&&8===b.uiVersion.minor?["disabled","value"]:["disabled","max","value"]};return c.prototype=b.createObject(a.prototype),c.prototype.constructor=c,b.register(c),c}),function(a,b){"use strict";a.kojqui.Selectmenu=b(a.jQuery,a.ko,a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.selectmenu)}(this,function(a,b,c,d){"use strict";var e=function(){c.call(this,"selectmenu"),this.options=["appendTo","disabled","icons","position","width"],this.events=["change","close","create","focus","open","select"],this.hasRefresh=!0};return e.prototype=d.createObject(c.prototype),e.prototype.constructor=e,e.prototype.init=function(d,e){var f=e();return c.prototype.init.apply(this,arguments),f.isOpen&&b.computed({read:function(){b.utils.unwrapObservable(f.isOpen)?a(d)[this.widgetName]("open"):a(d)[this.widgetName]("close")},disposeWhenNodeIsRemoved:d,owner:this}),b.isWriteableObservable(f.isOpen)&&(this.on(d,"open",function(){f.isOpen(!0)}),this.on(d,"close",function(){f.isOpen(!1)})),{controlsDescendantBindings:!0}},d.register(e),e}),function(a,b){"use strict";a.kojqui.Slider=b(a.jQuery,a.ko,a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.slider)}(this,function(a,b,c,d){"use strict";var e,f;return e="__kojqui_options",f=function(){c.call(this,"slider"),this.widgetEventPrefix="slide",this.options=["animate","disabled","max","min","orientation","range","step","value","values"],this.events=["create","start","slide","change","stop"]},f.prototype=d.createObject(c.prototype),f.prototype.constructor=f,f.prototype.init=function(d,f){var g,h;return c.prototype.init.apply(this,arguments),g=f(),h=g.realtime?"slide":"change",b.isWriteableObservable(g.value)&&this.on(d,h,function(c,f){var h=a(d).find(".ui-slider-handle").index(f.handle);0===h&&(b.utils.domData.get(d,e).value=f.value,g.value(f.value))}),b.isWriteableObservable(g.values)&&this.on(d,h,function(a,c){b.utils.domData.get(d,e).value=c.values,g.values(c.values)}),{controlsDescendantBindings:!0}},d.register(f),f}),function(a,b){"use strict";a.kojqui.Spinner=b(a.jQuery,a.ko,a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.spinner)}(this,function(a,b,c,d){"use strict";var e=function(){c.call(this,"spinner"),this.widgetEventPrefix="spin",this.options=["culture","disabled","icons","incremental","max","min","numberFormat","page","step"],this.events=["create","start","spin","stop","change"]};return e.prototype=d.createObject(c.prototype),e.prototype.constructor=e,e.prototype.init=function(d,e,f){var g,h;return c.prototype.init.apply(this,arguments),g=this.widgetName,h=e(),h.value&&b.computed({read:function(){a(d)[g]("value",b.utils.unwrapObservable(h.value))},disposeWhenNodeIsRemoved:d}),b.isWriteableObservable(h.value)&&(f().valueUpdate?this.on(d,"spin",function(a,b){h.value(b.value)}):this.on(d,"change",function(){h.value(a(d)[g]("value"))})),{controlsDescendantBindings:!0}},d.register(e),e}),function(a,b){"use strict";a.kojqui.Tabs=b(a.jQuery,a.ko,a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.tabs)}(this,function(a,b,c,d){"use strict";var e,f,g;return e=function(c,d){var e=d();b.isWriteableObservable(e.selected)&&this.on(c,"show",function(b,d){a(c)[0]===b.target&&e.selected(d.index)})},f=function(c,d){var e=d();b.isWriteableObservable(e.active)&&this.on(c,"activate",function(b,d){a(c)[0]===b.target&&e.active(d.newTab.index())})},g=function(){c.call(this,"tabs"),this.version=d.uiVersion,1===this.version.major&&8===this.version.minor?(this.options=["ajaxOptions","cache","collapsible","cookie","disabled","event","fx","idPrefix","panelTemplate","selected","spinner","tabTemplate"],this.events=["add","create","disable","enable","load","remove","select","show"],this.hasRefresh=!1):(this.options=["active","collapsible","disabled","event","heightStyle","hide","show"],this.events=["activate","beforeActivate","beforeLoad","create","load"],this.hasRefresh=!0)},g.prototype=d.createObject(c.prototype),g.prototype.constructor=g,g.prototype.init=function(a,b){return c.prototype.init.apply(this,arguments),1===this.version.major&&8===this.version.minor?e.call(this,a,b):f.call(this,a,b),{controlsDescendantBindings:!0}},d.register(g),g}),function(a,b){"use strict";a.kojqui.Tooltip=b(a.jQuery,a.ko,a.kojqui.BindingHandler,a.kojqui.utils,a.jQuery.ui.tooltip)}(this,function(a,b,c,d){"use strict";var e=function(){c.call(this,"tooltip"),this.options=["content","disabled","hide","items","position","show","tooltipClass","track"],this.events=["create","open","close"]};return e.prototype=d.createObject(c.prototype),e.prototype.constructor=e,e.prototype.init=function(d,e){var f=e();return c.prototype.init.apply(this,arguments),f.isOpen&&b.computed({read:function(){b.utils.unwrapObservable(f.isOpen)?a(d)[this.widgetName]("open"):a(d)[this.widgetName]("close")},disposeWhenNodeIsRemoved:d,owner:this}),b.isWriteableObservable(f.isOpen)&&(this.on(d,"open",function(){f.isOpen(!0)}),this.on(d,"close",function(){f.isOpen(!1)})),{controlsDescendantBindings:!0}},d.register(e),e});
// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

var Base64 = (function () {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    var obj = {
        /**
         * Encodes a string in base64
         * @param {String} input The string to encode in base64.
         */
        encode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                keyStr.charAt(enc3) + keyStr.charAt(enc4);
            } while (i < input.length);

            return output;
        },

        /**
         * Decodes a base64 string.
         * @param {String} input The string to decode.
         */
        decode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }
            } while (i < input.length);

            return output;
        }
    };

    return obj;
})();

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/* Some functions and variables have been stripped for use with Strophe */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * 8));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * 8));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
    /* append padding */
    x[len >> 5] |= 0x80 << (24 - len % 32);
    x[((len + 64 >> 9) << 4) + 15] = len;

    var w = new Array(80);
    var a =  1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d =  271733878;
    var e = -1009589776;

    var i, j, t, olda, oldb, oldc, oldd, olde;
    for (i = 0; i < x.length; i += 16)
    {
        olda = a;
        oldb = b;
        oldc = c;
        oldd = d;
        olde = e;

        for (j = 0; j < 80; j++)
        {
            if (j < 16) { w[j] = x[i + j]; }
            else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }
            t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                    safe_add(safe_add(e, w[j]), sha1_kt(j)));
            e = d;
            d = c;
            c = rol(b, 30);
            b = a;
            a = t;
        }

        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
        e = safe_add(e, olde);
    }
    return [a, b, c, d, e];
}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
    if (t < 20) { return (b & c) | ((~b) & d); }
    if (t < 40) { return b ^ c ^ d; }
    if (t < 60) { return (b & c) | (b & d) | (c & d); }
    return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
            (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
    var bkey = str2binb(key);
    if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }

    var ipad = new Array(16), opad = new Array(16);
    for (var i = 0; i < 16; i++)
    {
        ipad[i] = bkey[i] ^ 0x36363636;
        opad[i] = bkey[i] ^ 0x5C5C5C5C;
    }

    var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
    return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
    return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
    var bin = [];
    var mask = 255;
    for (var i = 0; i < str.length * 8; i += 8)
    {
        bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);
    }
    return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
    var str = "";
    var mask = 255;
    for (var i = 0; i < bin.length * 32; i += 8)
    {
        str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);
    }
    return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
    var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var str = "";
    var triplet, j;
    for (var i = 0; i < binarray.length * 4; i += 3)
    {
        triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
        (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
        ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
        for (j = 0; j < 4; j++)
        {
            if (i * 8 + j * 6 > binarray.length * 32) { str += "="; }
            else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
        }
    }
    return str;
}

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Everything that isn't used by Strophe has been stripped here!
 */

var MD5 = (function () {
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    var safe_add = function (x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    };

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    var bit_rol = function (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    };

    /*
     * Convert a string to an array of little-endian words
     */
    var str2binl = function (str) {
        var bin = [];
        for(var i = 0; i < str.length * 8; i += 8)
        {
            bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);
        }
        return bin;
    };

    /*
     * Convert an array of little-endian words to a string
     */
    var binl2str = function (bin) {
        var str = "";
        for(var i = 0; i < bin.length * 32; i += 8)
        {
            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a hex string.
     */
    var binl2hex = function (binarray) {
        var hex_tab = "0123456789abcdef";
        var str = "";
        for(var i = 0; i < binarray.length * 4; i++)
        {
            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
            hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
        }
        return str;
    };

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    var md5_cmn = function (q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
    };

    var md5_ff = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    };

    var md5_gg = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    };

    var md5_hh = function (a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };

    var md5_ii = function (a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    };

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length
     */
    var core_md5 = function (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var a =  1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d =  271733878;

        var olda, oldb, oldc, oldd;
        for (var i = 0; i < x.length; i += 16)
        {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    };


    var obj = {
        /*
         * These are the functions you'll usually want to call.
         * They take string arguments and return either hex or base-64 encoded
         * strings.
         */
        hexdigest: function (s) {
            return binl2hex(core_md5(str2binl(s), s.length * 8));
        },

        hash: function (s) {
            return binl2str(core_md5(str2binl(s), s.length * 8));
        }
    };

    return obj;
})();

/*
 This program is distributed under the terms of the MIT license.
 Please see the LICENSE file for details.

 Copyright 2006-2008, OGG, LLC
 */

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/*global document, window, setTimeout, clearTimeout, console,
 ActiveXObject, Base64, MD5, DOMParser */
// from sha1.js
/*global core_hmac_sha1, binb2str, str_hmac_sha1, str_sha1, b64_hmac_sha1*/

/** File: strophe.js
 *  A JavaScript library for XMPP BOSH/XMPP over Websocket.
 *
 *  This is the JavaScript version of the Strophe library.  Since JavaScript
 *  had no facilities for persistent TCP connections, this library uses
 *  Bidirectional-streams Over Synchronous HTTP (BOSH) to emulate
 *  a persistent, stateful, two-way connection to an XMPP server.  More
 *  information on BOSH can be found in XEP 124.
 *
 *  This version of Strophe also works with WebSockets.
 *  For more information on XMPP-over WebSocket see this RFC draft:
 *  http://tools.ietf.org/html/draft-ietf-xmpp-websocket-00
 */

/** PrivateFunction: Function.prototype.bind
 *  Bind a function to an instance.
 *
 *  This Function object extension method creates a bound method similar
 *  to those in Python.  This means that the 'this' object will point
 *  to the instance you want.  See
 *  <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind'>MDC's bind() documentation</a> and
 *  <a href='http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/'>Bound Functions and Function Imports in JavaScript</a>
 *  for a complete explanation.
 *
 *  This extension already exists in some browsers (namely, Firefox 3), but
 *  we provide it to support those that don't.
 *
 *  Parameters:
 *    (Object) obj - The object that will become 'this' in the bound function.
 *    (Object) argN - An option argument that will be prepended to the
 *      arguments given for the function call
 *
 *  Returns:
 *    The bound function.
 */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (obj /*, arg1, arg2, ... */)
    {
        var func = this;
        var _slice = Array.prototype.slice;
        var _concat = Array.prototype.concat;
        var _args = _slice.call(arguments, 1);

        return function () {
            return func.apply(obj ? obj : this,
                    _concat.call(_args,
                            _slice.call(arguments, 0)));
        };
    };
}

/* All of the Strophe globals are defined in this special function below so
 * that references to the globals become closures.  This will ensure that
 * on page reload, these references will still be available to callbacks
 * that are still executing.
 */

(function (callback) {
    var Strophe;

    /** Function: $build
     *  Create a Strophe.Builder.
     *  This is an alias for 'new Strophe.Builder(name, attrs)'.
     *
     *  Parameters:
     *    (String) name - The root element name.
     *    (Object) attrs - The attributes for the root element in object notation.
     *
     *  Returns:
     *    A new Strophe.Builder object.
     */
    function $build(name, attrs) { return new Strophe.Builder(name, attrs); }
    /** Function: $msg
     *  Create a Strophe.Builder with a <message/> element as the root.
     *
     *  Parmaeters:
     *    (Object) attrs - The <message/> element attributes in object notation.
     *
     *  Returns:
     *    A new Strophe.Builder object.
     */
    function $msg(attrs) { return new Strophe.Builder("message", attrs); }
    /** Function: $iq
     *  Create a Strophe.Builder with an <iq/> element as the root.
     *
     *  Parameters:
     *    (Object) attrs - The <iq/> element attributes in object notation.
     *
     *  Returns:
     *    A new Strophe.Builder object.
     */
    function $iq(attrs) { return new Strophe.Builder("iq", attrs); }
    /** Function: $pres
     *  Create a Strophe.Builder with a <presence/> element as the root.
     *
     *  Parameters:
     *    (Object) attrs - The <presence/> element attributes in object notation.
     *
     *  Returns:
     *    A new Strophe.Builder object.
     */
    function $pres(attrs) { return new Strophe.Builder("presence", attrs); }

    /** Class: Strophe
     *  An object container for all Strophe library functions.
     *
     *  This class is just a container for all the objects and constants
     *  used in the library.  It is not meant to be instantiated, but to
     *  provide a namespace for library objects, constants, and functions.
     */
    Strophe = {
        /** Constant: VERSION
         *  The version of the Strophe library. Unreleased builds will have
         *  a version of head-HASH where HASH is a partial revision.
         */
        VERSION: "1.1.3",

        /** Constants: XMPP Namespace Constants
         *  Common namespace constants from the XMPP RFCs and XEPs.
         *
         *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
         *  NS.BOSH - BOSH namespace from XEP 206.
         *  NS.CLIENT - Main XMPP client namespace.
         *  NS.AUTH - Legacy authentication namespace.
         *  NS.ROSTER - Roster operations namespace.
         *  NS.PROFILE - Profile namespace.
         *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
         *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
         *  NS.MUC - Multi-User Chat namespace from XEP 45.
         *  NS.SASL - XMPP SASL namespace from RFC 3920.
         *  NS.STREAM - XMPP Streams namespace from RFC 3920.
         *  NS.BIND - XMPP Binding namespace from RFC 3920.
         *  NS.SESSION - XMPP Session namespace from RFC 3920.
         *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.
         *  NS.XHTML - XHTML body namespace from XEP 71.
         */
        NS: {
            HTTPBIND: "http://jabber.org/protocol/httpbind",
            BOSH: "urn:xmpp:xbosh",
            CLIENT: "jabber:client",
            AUTH: "jabber:iq:auth",
            ROSTER: "jabber:iq:roster",
            PROFILE: "jabber:iq:profile",
            DISCO_INFO: "http://jabber.org/protocol/disco#info",
            DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
            MUC: "http://jabber.org/protocol/muc",
            SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
            STREAM: "http://etherx.jabber.org/streams",
            BIND: "urn:ietf:params:xml:ns:xmpp-bind",
            SESSION: "urn:ietf:params:xml:ns:xmpp-session",
            VERSION: "jabber:iq:version",
            STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
            XHTML_IM: "http://jabber.org/protocol/xhtml-im",
            XHTML: "http://www.w3.org/1999/xhtml"
        },


        /** Constants: XHTML_IM Namespace
         *  contains allowed tags, tag attributes, and css properties.
         *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.
         *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended
         *  allowed tags and their attributes.
         */
        XHTML: {
            tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],
            attributes: {
                'a':          ['href'],
                'blockquote': ['style'],
                'br':         [],
                'cite':       ['style'],
                'em':         [],
                'img':        ['src', 'alt', 'style', 'height', 'width'],
                'li':         ['style'],
                'ol':         ['style'],
                'p':          ['style'],
                'span':       ['style'],
                'strong':     [],
                'ul':         ['style'],
                'body':       []
            },
            css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],
            validTag: function(tag)
            {
                for(var i = 0; i < Strophe.XHTML.tags.length; i++) {
                    if(tag == Strophe.XHTML.tags[i]) {
                        return true;
                    }
                }
                return false;
            },
            validAttribute: function(tag, attribute)
            {
                if(typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                    for(var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                        if(attribute == Strophe.XHTML.attributes[tag][i]) {
                            return true;
                        }
                    }
                }
                return false;
            },
            validCSS: function(style)
            {
                for(var i = 0; i < Strophe.XHTML.css.length; i++) {
                    if(style == Strophe.XHTML.css[i]) {
                        return true;
                    }
                }
                return false;
            }
        },

        /** Constants: Connection Status Constants
         *  Connection status constants for use by the connection handler
         *  callback.
         *
         *  Status.ERROR - An error has occurred
         *  Status.CONNECTING - The connection is currently being made
         *  Status.CONNFAIL - The connection attempt failed
         *  Status.AUTHENTICATING - The connection is authenticating
         *  Status.AUTHFAIL - The authentication attempt failed
         *  Status.CONNECTED - The connection has succeeded
         *  Status.DISCONNECTED - The connection has been terminated
         *  Status.DISCONNECTING - The connection is currently being terminated
         *  Status.ATTACHED - The connection has been attached
         */
        Status: {
            ERROR: 0,
            CONNECTING: 1,
            CONNFAIL: 2,
            AUTHENTICATING: 3,
            AUTHFAIL: 4,
            CONNECTED: 5,
            DISCONNECTED: 6,
            DISCONNECTING: 7,
            ATTACHED: 8
        },

        /** Constants: Log Level Constants
         *  Logging level indicators.
         *
         *  LogLevel.DEBUG - Debug output
         *  LogLevel.INFO - Informational output
         *  LogLevel.WARN - Warnings
         *  LogLevel.ERROR - Errors
         *  LogLevel.FATAL - Fatal errors
         */
        LogLevel: {
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3,
            FATAL: 4
        },

        /** PrivateConstants: DOM Element Type Constants
         *  DOM element types.
         *
         *  ElementType.NORMAL - Normal element.
         *  ElementType.TEXT - Text data element.
         *  ElementType.FRAGMENT - XHTML fragment element.
         */
        ElementType: {
            NORMAL: 1,
            TEXT: 3,
            CDATA: 4,
            FRAGMENT: 11
        },

        /** PrivateConstants: Timeout Values
         *  Timeout values for error states.  These values are in seconds.
         *  These should not be changed unless you know exactly what you are
         *  doing.
         *
         *  TIMEOUT - Timeout multiplier. A waiting request will be considered
         *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
         *      This defaults to 1.1, and with default wait, 66 seconds.
         *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
         *      Strophe can detect early failure, it will consider the request
         *      failed if it doesn't return after
         *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
         *      This defaults to 0.1, and with default wait, 6 seconds.
         */
        TIMEOUT: 1.1,
        SECONDARY_TIMEOUT: 0.1,

        /** Function: addNamespace
         *  This function is used to extend the current namespaces in
         *  Strophe.NS.  It takes a key and a value with the key being the
         *  name of the new namespace, with its actual value.
         *  For example:
         *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
         *
         *  Parameters:
         *    (String) name - The name under which the namespace will be
         *      referenced under Strophe.NS
         *    (String) value - The actual namespace.
         */
        addNamespace: function (name, value)
        {
            Strophe.NS[name] = value;
        },

        /** Function: forEachChild
         *  Map a function over some or all child elements of a given element.
         *
         *  This is a small convenience function for mapping a function over
         *  some or all of the children of an element.  If elemName is null, all
         *  children will be passed to the function, otherwise only children
         *  whose tag names match elemName will be passed.
         *
         *  Parameters:
         *    (XMLElement) elem - The element to operate on.
         *    (String) elemName - The child element tag name filter.
         *    (Function) func - The function to apply to each child.  This
         *      function should take a single argument, a DOM element.
         */
        forEachChild: function (elem, elemName, func)
        {
            var i, childNode;

            for (i = 0; i < elem.childNodes.length; i++) {
                childNode = elem.childNodes[i];
                if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                        (!elemName || this.isTagEqual(childNode, elemName))) {
                    func(childNode);
                }
            }
        },

        /** Function: isTagEqual
         *  Compare an element's tag name with a string.
         *
         *  This function is case insensitive.
         *
         *  Parameters:
         *    (XMLElement) el - A DOM element.
         *    (String) name - The element name.
         *
         *  Returns:
         *    true if the element's tag name matches _el_, and false
         *    otherwise.
         */
        isTagEqual: function (el, name)
        {
            return el.tagName.toLowerCase() == name.toLowerCase();
        },

        /** PrivateVariable: _xmlGenerator
         *  _Private_ variable that caches a DOM document to
         *  generate elements.
         */
        _xmlGenerator: null,

        /** PrivateFunction: _makeGenerator
         *  _Private_ function that creates a dummy XML DOM document to serve as
         *  an element and text node generator.
         */
        _makeGenerator: function () {
            var doc;

            // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.
            // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be
            // less than 10 in the case of IE9 and below.
            if (document.implementation.createDocument === undefined ||
                    document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
                doc = this._getIEXmlDom();
                doc.appendChild(doc.createElement('strophe'));
            } else {
                doc = document.implementation
                        .createDocument('jabber:client', 'strophe', null);
            }

            return doc;
        },

        /** Function: xmlGenerator
         *  Get the DOM document to generate elements.
         *
         *  Returns:
         *    The currently used DOM document.
         */
        xmlGenerator: function () {
            if (!Strophe._xmlGenerator) {
                Strophe._xmlGenerator = Strophe._makeGenerator();
            }
            return Strophe._xmlGenerator;
        },

        /** PrivateFunction: _getIEXmlDom
         *  Gets IE xml doc object
         *
         *  Returns:
         *    A Microsoft XML DOM Object
         *  See Also:
         *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
         */
        _getIEXmlDom : function() {
            var doc = null;
            var docStrings = [
                "Msxml2.DOMDocument.6.0",
                "Msxml2.DOMDocument.5.0",
                "Msxml2.DOMDocument.4.0",
                "MSXML2.DOMDocument.3.0",
                "MSXML2.DOMDocument",
                "MSXML.DOMDocument",
                "Microsoft.XMLDOM"
            ];

            for (var d = 0; d < docStrings.length; d++) {
                if (doc === null) {
                    try {
                        doc = new ActiveXObject(docStrings[d]);
                    } catch (e) {
                        doc = null;
                    }
                } else {
                    break;
                }
            }

            return doc;
        },

        /** Function: xmlElement
         *  Create an XML DOM element.
         *
         *  This function creates an XML DOM element correctly across all
         *  implementations. Note that these are not HTML DOM elements, which
         *  aren't appropriate for XMPP stanzas.
         *
         *  Parameters:
         *    (String) name - The name for the element.
         *    (Array|Object) attrs - An optional array or object containing
         *      key/value pairs to use as element attributes. The object should
         *      be in the format {'key': 'value'} or {key: 'value'}. The array
         *      should have the format [['key1', 'value1'], ['key2', 'value2']].
         *    (String) text - The text child data for the element.
         *
         *  Returns:
         *    A new XML DOM element.
         */
        xmlElement: function (name)
        {
            if (!name) { return null; }

            var node = Strophe.xmlGenerator().createElement(name);

            // FIXME: this should throw errors if args are the wrong type or
            // there are more than two optional args
            var a, i, k;
            for (a = 1; a < arguments.length; a++) {
                if (!arguments[a]) { continue; }
                if (typeof(arguments[a]) == "string" ||
                        typeof(arguments[a]) == "number") {
                    node.appendChild(Strophe.xmlTextNode(arguments[a]));
                } else if (typeof(arguments[a]) == "object" &&
                        typeof(arguments[a].sort) == "function") {
                    for (i = 0; i < arguments[a].length; i++) {
                        if (typeof(arguments[a][i]) == "object" &&
                                typeof(arguments[a][i].sort) == "function") {
                            node.setAttribute(arguments[a][i][0],
                                    arguments[a][i][1]);
                        }
                    }
                } else if (typeof(arguments[a]) == "object") {
                    for (k in arguments[a]) {
                        if (arguments[a].hasOwnProperty(k)) {
                            node.setAttribute(k, arguments[a][k]);
                        }
                    }
                }
            }

            return node;
        },

        /*  Function: xmlescape
         *  Excapes invalid xml characters.
         *
         *  Parameters:
         *     (String) text - text to escape.
         *
         *  Returns:
         *      Escaped text.
         */
        xmlescape: function(text)
        {
            text = text.replace(/\&/g, "&amp;");
            text = text.replace(/</g,  "&lt;");
            text = text.replace(/>/g,  "&gt;");
            text = text.replace(/'/g,  "&apos;");
            text = text.replace(/"/g,  "&quot;");
            return text;
        },

        /** Function: xmlTextNode
         *  Creates an XML DOM text node.
         *
         *  Provides a cross implementation version of document.createTextNode.
         *
         *  Parameters:
         *    (String) text - The content of the text node.
         *
         *  Returns:
         *    A new XML DOM text node.
         */
        xmlTextNode: function (text)
        {
            return Strophe.xmlGenerator().createTextNode(text);
        },

        /** Function: xmlHtmlNode
         *  Creates an XML DOM html node.
         *
         *  Parameters:
         *    (String) html - The content of the html node.
         *
         *  Returns:
         *    A new XML DOM text node.
         */
        xmlHtmlNode: function (html)
        {
            var node;
            //ensure text is escaped
            if (window.DOMParser) {
                var parser = new DOMParser();
                node = parser.parseFromString(html, "text/xml");
            } else {
                node = new ActiveXObject("Microsoft.XMLDOM");
                node.async="false";
                node.loadXML(html);
            }
            return node;
        },

        /** Function: getText
         *  Get the concatenation of all text children of an element.
         *
         *  Parameters:
         *    (XMLElement) elem - A DOM element.
         *
         *  Returns:
         *    A String with the concatenated text of all text element children.
         */
        getText: function (elem)
        {
            if (!elem) { return null; }

            var str = "";
            if (elem.childNodes.length === 0 && elem.nodeType ==
                    Strophe.ElementType.TEXT) {
                str += elem.nodeValue;
            }

            for (var i = 0; i < elem.childNodes.length; i++) {
                if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                    str += elem.childNodes[i].nodeValue;
                }
            }

            return Strophe.xmlescape(str);
        },

        /** Function: copyElement
         *  Copy an XML DOM element.
         *
         *  This function copies a DOM element and all its descendants and returns
         *  the new copy.
         *
         *  Parameters:
         *    (XMLElement) elem - A DOM element.
         *
         *  Returns:
         *    A new, copied DOM element tree.
         */
        copyElement: function (elem)
        {
            var i, el;
            if (elem.nodeType == Strophe.ElementType.NORMAL) {
                el = Strophe.xmlElement(elem.tagName);

                for (i = 0; i < elem.attributes.length; i++) {
                    el.setAttribute(elem.attributes[i].nodeName.toLowerCase(),
                            elem.attributes[i].value);
                }

                for (i = 0; i < elem.childNodes.length; i++) {
                    el.appendChild(Strophe.copyElement(elem.childNodes[i]));
                }
            } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
            }

            return el;
        },


        /** Function: createHtml
         *  Copy an HTML DOM element into an XML DOM.
         *
         *  This function copies a DOM element and all its descendants and returns
         *  the new copy.
         *
         *  Parameters:
         *    (HTMLElement) elem - A DOM element.
         *
         *  Returns:
         *    A new, copied DOM element tree.
         */
        createHtml: function (elem)
        {
            var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;
            if (elem.nodeType == Strophe.ElementType.NORMAL) {
                tag = elem.nodeName.toLowerCase();
                if(Strophe.XHTML.validTag(tag)) {
                    try {
                        el = Strophe.xmlElement(tag);
                        for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                            attribute = Strophe.XHTML.attributes[tag][i];
                            value = elem.getAttribute(attribute);
                            if(typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {
                                continue;
                            }
                            if(attribute == 'style' && typeof value == 'object') {
                                if(typeof value.cssText != 'undefined') {
                                    value = value.cssText; // we're dealing with IE, need to get CSS out
                                }
                            }
                            // filter out invalid css styles
                            if(attribute == 'style') {
                                css = [];
                                cssAttrs = value.split(';');
                                for(j = 0; j < cssAttrs.length; j++) {
                                    attr = cssAttrs[j].split(':');
                                    cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                    if(Strophe.XHTML.validCSS(cssName)) {
                                        cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                        css.push(cssName + ': ' + cssValue);
                                    }
                                }
                                if(css.length > 0) {
                                    value = css.join('; ');
                                    el.setAttribute(attribute, value);
                                }
                            } else {
                                el.setAttribute(attribute, value);
                            }
                        }

                        for (i = 0; i < elem.childNodes.length; i++) {
                            el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                        }
                    } catch(e) { // invalid elements
                        el = Strophe.xmlTextNode('');
                    }
                } else {
                    el = Strophe.xmlGenerator().createDocumentFragment();
                    for (i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                    }
                }
            } else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
                el = Strophe.xmlGenerator().createDocumentFragment();
                for (i = 0; i < elem.childNodes.length; i++) {
                    el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                }
            } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                el = Strophe.xmlTextNode(elem.nodeValue);
            }

            return el;
        },

        /** Function: escapeNode
         *  Escape the node part (also called local part) of a JID.
         *
         *  Parameters:
         *    (String) node - A node (or local part).
         *
         *  Returns:
         *    An escaped node (or local part).
         */
        escapeNode: function (node)
        {
            return node.replace(/^\s+|\s+$/g, '')
                    .replace(/\\/g,  "\\5c")
                    .replace(/ /g,   "\\20")
                    .replace(/\"/g,  "\\22")
                    .replace(/\&/g,  "\\26")
                    .replace(/\'/g,  "\\27")
                    .replace(/\//g,  "\\2f")
                    .replace(/:/g,   "\\3a")
                    .replace(/</g,   "\\3c")
                    .replace(/>/g,   "\\3e")
                    .replace(/@/g,   "\\40");
        },

        /** Function: unescapeNode
         *  Unescape a node part (also called local part) of a JID.
         *
         *  Parameters:
         *    (String) node - A node (or local part).
         *
         *  Returns:
         *    An unescaped node (or local part).
         */
        unescapeNode: function (node)
        {
            return node.replace(/\\20/g, " ")
                    .replace(/\\22/g, '"')
                    .replace(/\\26/g, "&")
                    .replace(/\\27/g, "'")
                    .replace(/\\2f/g, "/")
                    .replace(/\\3a/g, ":")
                    .replace(/\\3c/g, "<")
                    .replace(/\\3e/g, ">")
                    .replace(/\\40/g, "@")
                    .replace(/\\5c/g, "\\");
        },

        /** Function: getNodeFromJid
         *  Get the node portion of a JID String.
         *
         *  Parameters:
         *    (String) jid - A JID.
         *
         *  Returns:
         *    A String containing the node.
         */
        getNodeFromJid: function (jid)
        {
            if (jid.indexOf("@") < 0) { return null; }
            return jid.split("@")[0];
        },

        /** Function: getDomainFromJid
         *  Get the domain portion of a JID String.
         *
         *  Parameters:
         *    (String) jid - A JID.
         *
         *  Returns:
         *    A String containing the domain.
         */
        getDomainFromJid: function (jid)
        {
            var bare = Strophe.getBareJidFromJid(jid);
            if (bare.indexOf("@") < 0) {
                return bare;
            } else {
                var parts = bare.split("@");
                parts.splice(0, 1);
                return parts.join('@');
            }
        },

        /** Function: getResourceFromJid
         *  Get the resource portion of a JID String.
         *
         *  Parameters:
         *    (String) jid - A JID.
         *
         *  Returns:
         *    A String containing the resource.
         */
        getResourceFromJid: function (jid)
        {
            var s = jid.split("/");
            if (s.length < 2) { return null; }
            s.splice(0, 1);
            return s.join('/');
        },

        /** Function: getBareJidFromJid
         *  Get the bare JID from a JID String.
         *
         *  Parameters:
         *    (String) jid - A JID.
         *
         *  Returns:
         *    A String containing the bare JID.
         */
        getBareJidFromJid: function (jid)
        {
            return jid ? jid.split("/")[0] : null;
        },

        /** Function: log
         *  User overrideable logging function.
         *
         *  This function is called whenever the Strophe library calls any
         *  of the logging functions.  The default implementation of this
         *  function does nothing.  If client code wishes to handle the logging
         *  messages, it should override this with
         *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
         *
         *  Please note that data sent and received over the wire is logged
         *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
         *
         *  The different levels and their meanings are
         *
         *    DEBUG - Messages useful for debugging purposes.
         *    INFO - Informational messages.  This is mostly information like
         *      'disconnect was called' or 'SASL auth succeeded'.
         *    WARN - Warnings about potential problems.  This is mostly used
         *      to report transient connection errors like request timeouts.
         *    ERROR - Some error occurred.
         *    FATAL - A non-recoverable fatal error occurred.
         *
         *  Parameters:
         *    (Integer) level - The log level of the log message.  This will
         *      be one of the values in Strophe.LogLevel.
         *    (String) msg - The log message.
         */
        /* jshint ignore:start */
        log: function (level, msg)
        {
            return;
        },
        /* jshint ignore:end */

        /** Function: debug
         *  Log a message at the Strophe.LogLevel.DEBUG level.
         *
         *  Parameters:
         *    (String) msg - The log message.
         */
        debug: function(msg)
        {
            this.log(this.LogLevel.DEBUG, msg);
        },

        /** Function: info
         *  Log a message at the Strophe.LogLevel.INFO level.
         *
         *  Parameters:
         *    (String) msg - The log message.
         */
        info: function (msg)
        {
            this.log(this.LogLevel.INFO, msg);
        },

        /** Function: warn
         *  Log a message at the Strophe.LogLevel.WARN level.
         *
         *  Parameters:
         *    (String) msg - The log message.
         */
        warn: function (msg)
        {
            this.log(this.LogLevel.WARN, msg);
        },

        /** Function: error
         *  Log a message at the Strophe.LogLevel.ERROR level.
         *
         *  Parameters:
         *    (String) msg - The log message.
         */
        error: function (msg)
        {
            this.log(this.LogLevel.ERROR, msg);
        },

        /** Function: fatal
         *  Log a message at the Strophe.LogLevel.FATAL level.
         *
         *  Parameters:
         *    (String) msg - The log message.
         */
        fatal: function (msg)
        {
            this.log(this.LogLevel.FATAL, msg);
        },

        /** Function: serialize
         *  Render a DOM element and all descendants to a String.
         *
         *  Parameters:
         *    (XMLElement) elem - A DOM element.
         *
         *  Returns:
         *    The serialized element tree as a String.
         */
        serialize: function (elem)
        {
            var result;

            if (!elem) { return null; }

            if (typeof(elem.tree) === "function") {
                elem = elem.tree();
            }

            var nodeName = elem.nodeName;
            var i, child;

            if (elem.getAttribute("_realname")) {
                nodeName = elem.getAttribute("_realname");
            }

            result = "<" + nodeName;
            for (i = 0; i < elem.attributes.length; i++) {
                if(elem.attributes[i].nodeName != "_realname") {
                    result += " " + elem.attributes[i].nodeName.toLowerCase() +
                    "='" + elem.attributes[i].value
                            .replace(/&/g, "&amp;")
                            .replace(/\'/g, "&apos;")
                            .replace(/>/g, "&gt;")
                            .replace(/</g, "&lt;") + "'";
                }
            }

            if (elem.childNodes.length > 0) {
                result += ">";
                for (i = 0; i < elem.childNodes.length; i++) {
                    child = elem.childNodes[i];
                    switch( child.nodeType ){
                        case Strophe.ElementType.NORMAL:
                            // normal element, so recurse
                            result += Strophe.serialize(child);
                            break;
                        case Strophe.ElementType.TEXT:
                            // text element to escape values
                            result += Strophe.xmlescape(child.nodeValue);
                            break;
                        case Strophe.ElementType.CDATA:
                            // cdata section so don't escape values
                            result += "<![CDATA["+child.nodeValue+"]]>";
                    }
                }
                result += "</" + nodeName + ">";
            } else {
                result += "/>";
            }

            return result;
        },

        /** PrivateVariable: _requestId
         *  _Private_ variable that keeps track of the request ids for
         *  connections.
         */
        _requestId: 0,

        /** PrivateVariable: Strophe.connectionPlugins
         *  _Private_ variable Used to store plugin names that need
         *  initialization on Strophe.Connection construction.
         */
        _connectionPlugins: {},

        /** Function: addConnectionPlugin
         *  Extends the Strophe.Connection object with the given plugin.
         *
         *  Parameters:
         *    (String) name - The name of the extension.
         *    (Object) ptype - The plugin's prototype.
         */
        addConnectionPlugin: function (name, ptype)
        {
            Strophe._connectionPlugins[name] = ptype;
        }
    };

    /** Class: Strophe.Builder
     *  XML DOM builder.
     *
     *  This object provides an interface similar to JQuery but for building
     *  DOM element easily and rapidly.  All the functions except for toString()
     *  and tree() return the object, so calls can be chained.  Here's an
     *  example using the $iq() builder helper.
     *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
     *  >     .c('query', {xmlns: 'strophe:example'})
     *  >     .c('example')
     *  >     .toString()
     *  The above generates this XML fragment
     *  > <iq to='you' from='me' type='get' id='1'>
     *  >   <query xmlns='strophe:example'>
     *  >     <example/>
     *  >   </query>
     *  > </iq>
     *  The corresponding DOM manipulations to get a similar fragment would be
     *  a lot more tedious and probably involve several helper variables.
     *
     *  Since adding children makes new operations operate on the child, up()
     *  is provided to traverse up the tree.  To add two children, do
     *  > builder.c('child1', ...).up().c('child2', ...)
     *  The next operation on the Builder will be relative to the second child.
     */

    /** Constructor: Strophe.Builder
     *  Create a Strophe.Builder object.
     *
     *  The attributes should be passed in object notation.  For example
     *  > var b = new Builder('message', {to: 'you', from: 'me'});
     *  or
     *  > var b = new Builder('messsage', {'xml:lang': 'en'});
     *
     *  Parameters:
     *    (String) name - The name of the root element.
     *    (Object) attrs - The attributes for the root element in object notation.
     *
     *  Returns:
     *    A new Strophe.Builder.
     */
    Strophe.Builder = function (name, attrs)
    {
        // Set correct namespace for jabber:client elements
        if (name == "presence" || name == "message" || name == "iq") {
            if (attrs && !attrs.xmlns) {
                attrs.xmlns = Strophe.NS.CLIENT;
            } else if (!attrs) {
                attrs = {xmlns: Strophe.NS.CLIENT};
            }
        }

        // Holds the tree being built.
        this.nodeTree = Strophe.xmlElement(name, attrs);

        // Points to the current operation node.
        this.node = this.nodeTree;
    };

    Strophe.Builder.prototype = {
        /** Function: tree
         *  Return the DOM tree.
         *
         *  This function returns the current DOM tree as an element object.  This
         *  is suitable for passing to functions like Strophe.Connection.send().
         *
         *  Returns:
         *    The DOM tree as a element object.
         */
        tree: function ()
        {
            return this.nodeTree;
        },

        /** Function: toString
         *  Serialize the DOM tree to a String.
         *
         *  This function returns a string serialization of the current DOM
         *  tree.  It is often used internally to pass data to a
         *  Strophe.Request object.
         *
         *  Returns:
         *    The serialized DOM tree in a String.
         */
        toString: function ()
        {
            return Strophe.serialize(this.nodeTree);
        },

        /** Function: up
         *  Make the current parent element the new current element.
         *
         *  This function is often used after c() to traverse back up the tree.
         *  For example, to add two children to the same element
         *  > builder.c('child1', {}).up().c('child2', {});
         *
         *  Returns:
         *    The Stophe.Builder object.
         */
        up: function ()
        {
            this.node = this.node.parentNode;
            return this;
        },

        /** Function: attrs
         *  Add or modify attributes of the current element.
         *
         *  The attributes should be passed in object notation.  This function
         *  does not move the current element pointer.
         *
         *  Parameters:
         *    (Object) moreattrs - The attributes to add/modify in object notation.
         *
         *  Returns:
         *    The Strophe.Builder object.
         */
        attrs: function (moreattrs)
        {
            for (var k in moreattrs) {
                if (moreattrs.hasOwnProperty(k)) {
                    this.node.setAttribute(k, moreattrs[k]);
                }
            }
            return this;
        },

        /** Function: c
         *  Add a child to the current element and make it the new current
         *  element.
         *
         *  This function moves the current element pointer to the child,
         *  unless text is provided.  If you need to add another child, it
         *  is necessary to use up() to go back to the parent in the tree.
         *
         *  Parameters:
         *    (String) name - The name of the child.
         *    (Object) attrs - The attributes of the child in object notation.
         *    (String) text - The text to add to the child.
         *
         *  Returns:
         *    The Strophe.Builder object.
         */
        c: function (name, attrs, text)
        {
            var child = Strophe.xmlElement(name, attrs, text);
            this.node.appendChild(child);
            if (!text) {
                this.node = child;
            }
            return this;
        },

        /** Function: cnode
         *  Add a child to the current element and make it the new current
         *  element.
         *
         *  This function is the same as c() except that instead of using a
         *  name and an attributes object to create the child it uses an
         *  existing DOM element object.
         *
         *  Parameters:
         *    (XMLElement) elem - A DOM element.
         *
         *  Returns:
         *    The Strophe.Builder object.
         */
        cnode: function (elem)
        {
            var impNode;
            var xmlGen = Strophe.xmlGenerator();
            try {
                impNode = (xmlGen.importNode !== undefined);
            }
            catch (e) {
                impNode = false;
            }
            var newElem = impNode ?
                    xmlGen.importNode(elem, true) :
                    Strophe.copyElement(elem);
            this.node.appendChild(newElem);
            this.node = newElem;
            return this;
        },

        /** Function: t
         *  Add a child text element.
         *
         *  This *does not* make the child the new current element since there
         *  are no children of text elements.
         *
         *  Parameters:
         *    (String) text - The text data to append to the current element.
         *
         *  Returns:
         *    The Strophe.Builder object.
         */
        t: function (text)
        {
            var child = Strophe.xmlTextNode(text);
            this.node.appendChild(child);
            return this;
        },

        /** Function: h
         *  Replace current element contents with the HTML passed in.
         *
         *  This *does not* make the child the new current element
         *
         *  Parameters:
         *    (String) html - The html to insert as contents of current element.
         *
         *  Returns:
         *    The Strophe.Builder object.
         */
        h: function (html)
        {
            var fragment = document.createElement('body');

            // force the browser to try and fix any invalid HTML tags
            fragment.innerHTML = html;

            // copy cleaned html into an xml dom
            var xhtml = Strophe.createHtml(fragment);

            while(xhtml.childNodes.length > 0) {
                this.node.appendChild(xhtml.childNodes[0]);
            }
            return this;
        }
    };

    /** PrivateClass: Strophe.Handler
     *  _Private_ helper class for managing stanza handlers.
     *
     *  A Strophe.Handler encapsulates a user provided callback function to be
     *  executed when matching stanzas are received by the connection.
     *  Handlers can be either one-off or persistant depending on their
     *  return value. Returning true will cause a Handler to remain active, and
     *  returning false will remove the Handler.
     *
     *  Users will not use Strophe.Handler objects directly, but instead they
     *  will use Strophe.Connection.addHandler() and
     *  Strophe.Connection.deleteHandler().
     */

    /** PrivateConstructor: Strophe.Handler
     *  Create and initialize a new Strophe.Handler.
     *
     *  Parameters:
     *    (Function) handler - A function to be executed when the handler is run.
     *    (String) ns - The namespace to match.
     *    (String) name - The element name to match.
     *    (String) type - The element type to match.
     *    (String) id - The element id attribute to match.
     *    (String) from - The element from attribute to match.
     *    (Object) options - Handler options
     *
     *  Returns:
     *    A new Strophe.Handler object.
     */
    Strophe.Handler = function (handler, ns, name, type, id, from, options)
    {
        this.handler = handler;
        this.ns = ns;
        this.name = name;
        this.type = type;
        this.id = id;
        this.options = options || {matchBare: false};

        // default matchBare to false if undefined
        if (!this.options.matchBare) {
            this.options.matchBare = false;
        }

        if (this.options.matchBare) {
            this.from = from ? Strophe.getBareJidFromJid(from) : null;
        } else {
            this.from = from;
        }

        // whether the handler is a user handler or a system handler
        this.user = true;
    };

    Strophe.Handler.prototype = {
        /** PrivateFunction: isMatch
         *  Tests if a stanza matches the Strophe.Handler.
         *
         *  Parameters:
         *    (XMLElement) elem - The XML element to test.
         *
         *  Returns:
         *    true if the stanza matches and false otherwise.
         */
        isMatch: function (elem)
        {
            var nsMatch;
            var from = null;

            if (this.options.matchBare) {
                from = Strophe.getBareJidFromJid(elem.getAttribute('from'));
            } else {
                from = elem.getAttribute('from');
            }

            nsMatch = false;
            if (!this.ns) {
                nsMatch = true;
            } else {
                var that = this;
                Strophe.forEachChild(elem, null, function (elem) {
                    if (elem.getAttribute("xmlns") == that.ns) {
                        nsMatch = true;
                    }
                });

                nsMatch = nsMatch || elem.getAttribute("xmlns") == this.ns;
            }

            if (nsMatch &&
                    (!this.name || Strophe.isTagEqual(elem, this.name)) &&
                    (!this.type || elem.getAttribute("type") == this.type) &&
                    (!this.id || elem.getAttribute("id") == this.id) &&
                    (!this.from || from == this.from)) {
                return true;
            }

            return false;
        },

        /** PrivateFunction: run
         *  Run the callback on a matching stanza.
         *
         *  Parameters:
         *    (XMLElement) elem - The DOM element that triggered the
         *      Strophe.Handler.
         *
         *  Returns:
         *    A boolean indicating if the handler should remain active.
         */
        run: function (elem)
        {
            var result = null;
            try {
                result = this.handler(elem);
            } catch (e) {
                if (e.sourceURL) {
                    Strophe.fatal("error: " + this.handler +
                    " " + e.sourceURL + ":" +
                    e.line + " - " + e.name + ": " + e.message);
                } else if (e.fileName) {
                    if (typeof(console) != "undefined") {
                        console.trace();
                        console.error(this.handler, " - error - ", e, e.message);
                    }
                    Strophe.fatal("error: " + this.handler + " " +
                    e.fileName + ":" + e.lineNumber + " - " +
                    e.name + ": " + e.message);
                } else {
                    Strophe.fatal("error: " + e.message + "\n" + e.stack);
                }

                throw e;
            }

            return result;
        },

        /** PrivateFunction: toString
         *  Get a String representation of the Strophe.Handler object.
         *
         *  Returns:
         *    A String.
         */
        toString: function ()
        {
            return "{Handler: " + this.handler + "(" + this.name + "," +
            this.id + "," + this.ns + ")}";
        }
    };

    /** PrivateClass: Strophe.TimedHandler
     *  _Private_ helper class for managing timed handlers.
     *
     *  A Strophe.TimedHandler encapsulates a user provided callback that
     *  should be called after a certain period of time or at regular
     *  intervals.  The return value of the callback determines whether the
     *  Strophe.TimedHandler will continue to fire.
     *
     *  Users will not use Strophe.TimedHandler objects directly, but instead
     *  they will use Strophe.Connection.addTimedHandler() and
     *  Strophe.Connection.deleteTimedHandler().
     */

    /** PrivateConstructor: Strophe.TimedHandler
     *  Create and initialize a new Strophe.TimedHandler object.
     *
     *  Parameters:
     *    (Integer) period - The number of milliseconds to wait before the
     *      handler is called.
     *    (Function) handler - The callback to run when the handler fires.  This
     *      function should take no arguments.
     *
     *  Returns:
     *    A new Strophe.TimedHandler object.
     */
    Strophe.TimedHandler = function (period, handler)
    {
        this.period = period;
        this.handler = handler;

        this.lastCalled = new Date().getTime();
        this.user = true;
    };

    Strophe.TimedHandler.prototype = {
        /** PrivateFunction: run
         *  Run the callback for the Strophe.TimedHandler.
         *
         *  Returns:
         *    true if the Strophe.TimedHandler should be called again, and false
         *      otherwise.
         */
        run: function ()
        {
            this.lastCalled = new Date().getTime();
            return this.handler();
        },

        /** PrivateFunction: reset
         *  Reset the last called time for the Strophe.TimedHandler.
         */
        reset: function ()
        {
            this.lastCalled = new Date().getTime();
        },

        /** PrivateFunction: toString
         *  Get a string representation of the Strophe.TimedHandler object.
         *
         *  Returns:
         *    The string representation.
         */
        toString: function ()
        {
            return "{TimedHandler: " + this.handler + "(" + this.period +")}";
        }
    };

    /** Class: Strophe.Connection
     *  XMPP Connection manager.
     *
     *  This class is the main part of Strophe.  It manages a BOSH connection
     *  to an XMPP server and dispatches events to the user callbacks as
     *  data arrives.  It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1
     *  and legacy authentication.
     *
     *  After creating a Strophe.Connection object, the user will typically
     *  call connect() with a user supplied callback to handle connection level
     *  events like authentication failure, disconnection, or connection
     *  complete.
     *
     *  The user will also have several event handlers defined by using
     *  addHandler() and addTimedHandler().  These will allow the user code to
     *  respond to interesting stanzas or do something periodically with the
     *  connection.  These handlers will be active once authentication is
     *  finished.
     *
     *  To send data to the connection, use send().
     */

    /** Constructor: Strophe.Connection
     *  Create and initialize a Strophe.Connection object.
     *
     *  The transport-protocol for this connection will be chosen automatically
     *  based on the given service parameter. URLs starting with "ws://" or
     *  "wss://" will use WebSockets, URLs starting with "http://", "https://"
     *  or without a protocol will use BOSH.
     *
     *  To make Strophe connect to the current host you can leave out the protocol
     *  and host part and just pass the path, e.g.
     *
     *  > var conn = new Strophe.Connection("/http-bind/");
     *
     *  WebSocket options:
     *
     *  If you want to connect to the current host with a WebSocket connection you
     *  can tell Strophe to use WebSockets through a "protocol" attribute in the
     *  optional options parameter. Valid values are "ws" for WebSocket and "wss"
     *  for Secure WebSocket.
     *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
     *
     *  > var conn = new Strophe.Connection("/xmpp-websocket/", {protocol: "wss"});
     *
     *  Note that relative URLs _NOT_ starting with a "/" will also include the path
     *  of the current site.
     *
     *  Also because downgrading security is not permitted by browsers, when using
     *  relative URLs both BOSH and WebSocket connections will use their secure
     *  variants if the current connection to the site is also secure (https).
     *
     *  BOSH options:
     *
     *  by adding "sync" to the options, you can control if requests will
     *  be made synchronously or not. The default behaviour is asynchronous.
     *  If you want to make requests synchronous, make "sync" evaluate to true:
     *  > var conn = new Strophe.Connection("/http-bind/", {sync: true});
     *  You can also toggle this on an already established connection:
     *  > conn.options.sync = true;
     *
     *
     *  Parameters:
     *    (String) service - The BOSH or WebSocket service URL.
     *    (Object) options - A hash of configuration options
     *
     *  Returns:
     *    A new Strophe.Connection object.
     */
    Strophe.Connection = function (service, options)
    {
        // The service URL
        this.service = service;

        // Configuration options
        this.options = options || {};
        var proto = this.options.protocol || "";

        // Select protocal based on service or options
        if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 ||
                proto.indexOf("ws") === 0) {
            this._proto = new Strophe.Websocket(this);
        } else {
            this._proto = new Strophe.Bosh(this);
        }
        /* The connected JID. */
        this.jid = "";
        /* the JIDs domain */
        this.domain = null;
        /* stream:features */
        this.features = null;

        // SASL
        this._sasl_data = {};
        this.do_session = false;
        this.do_bind = false;

        // handler lists
        this.timedHandlers = [];
        this.handlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];

        this._authentication = {};
        this._idleTimeout = null;
        this._disconnectTimeout = null;

        this.do_authentication = true;
        this.authenticated = false;
        this.disconnecting = false;
        this.connected = false;

        this.errors = 0;

        this.paused = false;

        this._data = [];
        this._uniqueId = 0;

        this._sasl_success_handler = null;
        this._sasl_failure_handler = null;
        this._sasl_challenge_handler = null;

        // Max retries before disconnecting
        this.maxRetries = 5;

        // setup onIdle callback every 1/10th of a second
        this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);

        // initialize plugins
        for (var k in Strophe._connectionPlugins) {
            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                var ptype = Strophe._connectionPlugins[k];
                // jslint complaints about the below line, but this is fine
                var F = function () {}; // jshint ignore:line
                F.prototype = ptype;
                this[k] = new F();
                this[k].init(this);
            }
        }
    };

    Strophe.Connection.prototype = {
        /** Function: reset
         *  Reset the connection.
         *
         *  This function should be called after a connection is disconnected
         *  before that connection is reused.
         */
        reset: function ()
        {
            this._proto._reset();

            // SASL
            this.do_session = false;
            this.do_bind = false;

            // handler lists
            this.timedHandlers = [];
            this.handlers = [];
            this.removeTimeds = [];
            this.removeHandlers = [];
            this.addTimeds = [];
            this.addHandlers = [];
            this._authentication = {};

            this.authenticated = false;
            this.disconnecting = false;
            this.connected = false;

            this.errors = 0;

            this._requests = [];
            this._uniqueId = 0;
        },

        /** Function: pause
         *  Pause the request manager.
         *
         *  This will prevent Strophe from sending any more requests to the
         *  server.  This is very useful for temporarily pausing
         *  BOSH-Connections while a lot of send() calls are happening quickly.
         *  This causes Strophe to send the data in a single request, saving
         *  many request trips.
         */
        pause: function ()
        {
            this.paused = true;
        },

        /** Function: resume
         *  Resume the request manager.
         *
         *  This resumes after pause() has been called.
         */
        resume: function ()
        {
            this.paused = false;
        },

        /** Function: getUniqueId
         *  Generate a unique ID for use in <iq/> elements.
         *
         *  All <iq/> stanzas are required to have unique id attributes.  This
         *  function makes creating these easy.  Each connection instance has
         *  a counter which starts from zero, and the value of this counter
         *  plus a colon followed by the suffix becomes the unique id. If no
         *  suffix is supplied, the counter is used as the unique id.
         *
         *  Suffixes are used to make debugging easier when reading the stream
         *  data, and their use is recommended.  The counter resets to 0 for
         *  every new connection for the same reason.  For connections to the
         *  same server that authenticate the same way, all the ids should be
         *  the same, which makes it easy to see changes.  This is useful for
         *  automated testing as well.
         *
         *  Parameters:
         *    (String) suffix - A optional suffix to append to the id.
         *
         *  Returns:
         *    A unique string to be used for the id attribute.
         */
        getUniqueId: function (suffix)
        {
            if (typeof(suffix) == "string" || typeof(suffix) == "number") {
                return ++this._uniqueId + ":" + suffix;
            } else {
                return ++this._uniqueId + "";
            }
        },

        /** Function: connect
         *  Starts the connection process.
         *
         *  As the connection process proceeds, the user supplied callback will
         *  be triggered multiple times with status updates.  The callback
         *  should take two arguments - the status code and the error condition.
         *
         *  The status code will be one of the values in the Strophe.Status
         *  constants.  The error condition will be one of the conditions
         *  defined in RFC 3920 or the condition 'strophe-parsererror'.
         *
         *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant
         *  for BOSH connections. Please see XEP 124 for a more detailed explanation
         *  of the optional parameters.
         *
         *  Parameters:
         *    (String) jid - The user's JID.  This may be a bare JID,
         *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
         *      authentication will be attempted.
         *    (String) pass - The user's password.
         *    (Function) callback - The connect callback function.
         *    (Integer) wait - The optional HTTPBIND wait value.  This is the
         *      time the server will wait before returning an empty result for
         *      a request.  The default setting of 60 seconds is recommended.
         *    (Integer) hold - The optional HTTPBIND hold value.  This is the
         *      number of connections the server will hold at one time.  This
         *      should almost always be set to 1 (the default).
         *    (String) route - The optional route value.
         */
        connect: function (jid, pass, callback, wait, hold, route)
        {
            this.jid = jid;
            /** Variable: authzid
             *  Authorization identity.
             */
            this.authzid = Strophe.getBareJidFromJid(this.jid);
            /** Variable: authcid
             *  Authentication identity (User name).
             */
            this.authcid = Strophe.getNodeFromJid(this.jid);
            /** Variable: pass
             *  Authentication identity (User password).
             */
            this.pass = pass;
            /** Variable: servtype
             *  Digest MD5 compatibility.
             */
            this.servtype = "xmpp";
            this.connect_callback = callback;
            this.disconnecting = false;
            this.connected = false;
            this.authenticated = false;
            this.errors = 0;

            // parse jid for domain
            this.domain = Strophe.getDomainFromJid(this.jid);

            this._changeConnectStatus(Strophe.Status.CONNECTING, null);

            this._proto._connect(wait, hold, route);
        },

        /** Function: attach
         *  Attach to an already created and authenticated BOSH session.
         *
         *  This function is provided to allow Strophe to attach to BOSH
         *  sessions which have been created externally, perhaps by a Web
         *  application.  This is often used to support auto-login type features
         *  without putting user credentials into the page.
         *
         *  Parameters:
         *    (String) jid - The full JID that is bound by the session.
         *    (String) sid - The SID of the BOSH session.
         *    (String) rid - The current RID of the BOSH session.  This RID
         *      will be used by the next request.
         *    (Function) callback The connect callback function.
         *    (Integer) wait - The optional HTTPBIND wait value.  This is the
         *      time the server will wait before returning an empty result for
         *      a request.  The default setting of 60 seconds is recommended.
         *      Other settings will require tweaks to the Strophe.TIMEOUT value.
         *    (Integer) hold - The optional HTTPBIND hold value.  This is the
         *      number of connections the server will hold at one time.  This
         *      should almost always be set to 1 (the default).
         *    (Integer) wind - The optional HTTBIND window value.  This is the
         *      allowed range of request ids that are valid.  The default is 5.
         */
        attach: function (jid, sid, rid, callback, wait, hold, wind)
        {
            this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
        },

        /** Function: xmlInput
         *  User overrideable function that receives XML data coming into the
         *  connection.
         *
         *  The default function does nothing.  User code can override this with
         *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
         *
         *  Due to limitations of current Browsers' XML-Parsers the opening and closing
         *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
         *
         *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
         *  <Strophe.Bosh.strip> if you want to strip this tag.
         *
         *  Parameters:
         *    (XMLElement) elem - The XML data received by the connection.
         */
        /* jshint unused:false */
        xmlInput: function (elem)
        {
            return;
        },
        /* jshint unused:true */

        /** Function: xmlOutput
         *  User overrideable function that receives XML data sent to the
         *  connection.
         *
         *  The default function does nothing.  User code can override this with
         *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
         *
         *  Due to limitations of current Browsers' XML-Parsers the opening and closing
         *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
         *
         *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
         *  <Strophe.Bosh.strip> if you want to strip this tag.
         *
         *  Parameters:
         *    (XMLElement) elem - The XMLdata sent by the connection.
         */
        /* jshint unused:false */
        xmlOutput: function (elem)
        {
            return;
        },
        /* jshint unused:true */

        /** Function: rawInput
         *  User overrideable function that receives raw data coming into the
         *  connection.
         *
         *  The default function does nothing.  User code can override this with
         *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
         *
         *  Parameters:
         *    (String) data - The data received by the connection.
         */
        /* jshint unused:false */
        rawInput: function (data)
        {
            return;
        },
        /* jshint unused:true */

        /** Function: rawOutput
         *  User overrideable function that receives raw data sent to the
         *  connection.
         *
         *  The default function does nothing.  User code can override this with
         *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
         *
         *  Parameters:
         *    (String) data - The data sent by the connection.
         */
        /* jshint unused:false */
        rawOutput: function (data)
        {
            return;
        },
        /* jshint unused:true */

        /** Function: send
         *  Send a stanza.
         *
         *  This function is called to push data onto the send queue to
         *  go out over the wire.  Whenever a request is sent to the BOSH
         *  server, all pending data is sent and the queue is flushed.
         *
         *  Parameters:
         *    (XMLElement |
         *     [XMLElement] |
         *     Strophe.Builder) elem - The stanza to send.
         */
        send: function (elem)
        {
            if (elem === null) { return ; }
            if (typeof(elem.sort) === "function") {
                for (var i = 0; i < elem.length; i++) {
                    this._queueData(elem[i]);
                }
            } else if (typeof(elem.tree) === "function") {
                this._queueData(elem.tree());
            } else {
                this._queueData(elem);
            }

            this._proto._send();
        },

        /** Function: flush
         *  Immediately send any pending outgoing data.
         *
         *  Normally send() queues outgoing data until the next idle period
         *  (100ms), which optimizes network use in the common cases when
         *  several send()s are called in succession. flush() can be used to
         *  immediately send all pending data.
         */
        flush: function ()
        {
            // cancel the pending idle period and run the idle function
            // immediately
            clearTimeout(this._idleTimeout);
            this._onIdle();
        },

        /** Function: sendIQ
         *  Helper function to send IQ stanzas.
         *
         *  Parameters:
         *    (XMLElement) elem - The stanza to send.
         *    (Function) callback - The callback function for a successful request.
         *    (Function) errback - The callback function for a failed or timed
         *      out request.  On timeout, the stanza will be null.
         *    (Integer) timeout - The time specified in milliseconds for a
         *      timeout to occur.
         *
         *  Returns:
         *    The id used to send the IQ.
         */
        sendIQ: function(elem, callback, errback, timeout) {
            var timeoutHandler = null;
            var that = this;

            if (typeof(elem.tree) === "function") {
                elem = elem.tree();
            }
            var id = elem.getAttribute('id');

            // inject id if not found
            if (!id) {
                id = this.getUniqueId("sendIQ");
                elem.setAttribute("id", id);
            }

            var handler = this.addHandler(function (stanza) {
                // remove timeout handler if there is one
                if (timeoutHandler) {
                    that.deleteTimedHandler(timeoutHandler);
                }

                var iqtype = stanza.getAttribute('type');
                if (iqtype == 'result') {
                    if (callback) {
                        callback(stanza);
                    }
                } else if (iqtype == 'error') {
                    if (errback) {
                        errback(stanza);
                    }
                } else {
                    throw {
                        name: "StropheError",
                        message: "Got bad IQ type of " + iqtype
                    };
                }
            }, null, 'iq', null, id);

            // if timeout specified, setup timeout handler.
            if (timeout) {
                timeoutHandler = this.addTimedHandler(timeout, function () {
                    // get rid of normal handler
                    that.deleteHandler(handler);

                    // call errback on timeout with null stanza
                    if (errback) {
                        errback(null);
                    }
                    return false;
                });
            }

            this.send(elem);

            return id;
        },

        /** PrivateFunction: _queueData
         *  Queue outgoing data for later sending.  Also ensures that the data
         *  is a DOMElement.
         */
        _queueData: function (element) {
            if (element === null ||
                    !element.tagName ||
                    !element.childNodes) {
                throw {
                    name: "StropheError",
                    message: "Cannot queue non-DOMElement."
                };
            }

            this._data.push(element);
        },

        /** PrivateFunction: _sendRestart
         *  Send an xmpp:restart stanza.
         */
        _sendRestart: function ()
        {
            this._data.push("restart");

            this._proto._sendRestart();

            this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
        },

        /** Function: addTimedHandler
         *  Add a timed handler to the connection.
         *
         *  This function adds a timed handler.  The provided handler will
         *  be called every period milliseconds until it returns false,
         *  the connection is terminated, or the handler is removed.  Handlers
         *  that wish to continue being invoked should return true.
         *
         *  Because of method binding it is necessary to save the result of
         *  this function if you wish to remove a handler with
         *  deleteTimedHandler().
         *
         *  Note that user handlers are not active until authentication is
         *  successful.
         *
         *  Parameters:
         *    (Integer) period - The period of the handler.
         *    (Function) handler - The callback function.
         *
         *  Returns:
         *    A reference to the handler that can be used to remove it.
         */
        addTimedHandler: function (period, handler)
        {
            var thand = new Strophe.TimedHandler(period, handler);
            this.addTimeds.push(thand);
            return thand;
        },

        /** Function: deleteTimedHandler
         *  Delete a timed handler for a connection.
         *
         *  This function removes a timed handler from the connection.  The
         *  handRef parameter is *not* the function passed to addTimedHandler(),
         *  but is the reference returned from addTimedHandler().
         *
         *  Parameters:
         *    (Strophe.TimedHandler) handRef - The handler reference.
         */
        deleteTimedHandler: function (handRef)
        {
            // this must be done in the Idle loop so that we don't change
            // the handlers during iteration
            this.removeTimeds.push(handRef);
        },

        /** Function: addHandler
         *  Add a stanza handler for the connection.
         *
         *  This function adds a stanza handler to the connection.  The
         *  handler callback will be called for any stanza that matches
         *  the parameters.  Note that if multiple parameters are supplied,
         *  they must all match for the handler to be invoked.
         *
         *  The handler will receive the stanza that triggered it as its argument.
         *  The handler should return true if it is to be invoked again;
         *  returning false will remove the handler after it returns.
         *
         *  As a convenience, the ns parameters applies to the top level element
         *  and also any of its immediate children.  This is primarily to make
         *  matching /iq/query elements easy.
         *
         *  The options argument contains handler matching flags that affect how
         *  matches are determined. Currently the only flag is matchBare (a
         *  boolean). When matchBare is true, the from parameter and the from
         *  attribute on the stanza will be matched as bare JIDs instead of
         *  full JIDs. To use this, pass {matchBare: true} as the value of
         *  options. The default value for matchBare is false.
         *
         *  The return value should be saved if you wish to remove the handler
         *  with deleteHandler().
         *
         *  Parameters:
         *    (Function) handler - The user callback.
         *    (String) ns - The namespace to match.
         *    (String) name - The stanza name to match.
         *    (String) type - The stanza type attribute to match.
         *    (String) id - The stanza id attribute to match.
         *    (String) from - The stanza from attribute to match.
         *    (String) options - The handler options
         *
         *  Returns:
         *    A reference to the handler that can be used to remove it.
         */
        addHandler: function (handler, ns, name, type, id, from, options)
        {
            var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
            this.addHandlers.push(hand);
            return hand;
        },

        /** Function: deleteHandler
         *  Delete a stanza handler for a connection.
         *
         *  This function removes a stanza handler from the connection.  The
         *  handRef parameter is *not* the function passed to addHandler(),
         *  but is the reference returned from addHandler().
         *
         *  Parameters:
         *    (Strophe.Handler) handRef - The handler reference.
         */
        deleteHandler: function (handRef)
        {
            // this must be done in the Idle loop so that we don't change
            // the handlers during iteration
            this.removeHandlers.push(handRef);
        },

        /** Function: disconnect
         *  Start the graceful disconnection process.
         *
         *  This function starts the disconnection process.  This process starts
         *  by sending unavailable presence and sending BOSH body of type
         *  terminate.  A timeout handler makes sure that disconnection happens
         *  even if the BOSH server does not respond.
         *
         *  The user supplied connection callback will be notified of the
         *  progress as this process happens.
         *
         *  Parameters:
         *    (String) reason - The reason the disconnect is occuring.
         */
        disconnect: function (reason)
        {
            this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);

            Strophe.info("Disconnect was called because: " + reason);
            if (this.connected) {
                var pres = false;
                this.disconnecting = true;
                if (this.authenticated) {
                    pres = $pres({
                        xmlns: Strophe.NS.CLIENT,
                        type: 'unavailable'
                    });
                }
                // setup timeout handler
                this._disconnectTimeout = this._addSysTimedHandler(
                        3000, this._onDisconnectTimeout.bind(this));
                this._proto._disconnect(pres);
            }
        },

        /** PrivateFunction: _changeConnectStatus
         *  _Private_ helper function that makes sure plugins and the user's
         *  callback are notified of connection status changes.
         *
         *  Parameters:
         *    (Integer) status - the new connection status, one of the values
         *      in Strophe.Status
         *    (String) condition - the error condition or null
         */
        _changeConnectStatus: function (status, condition)
        {
            // notify all plugins listening for status changes
            for (var k in Strophe._connectionPlugins) {
                if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                    var plugin = this[k];
                    if (plugin.statusChanged) {
                        try {
                            plugin.statusChanged(status, condition);
                        } catch (err) {
                            Strophe.error("" + k + " plugin caused an exception " +
                            "changing status: " + err);
                        }
                    }
                }
            }

            // notify the user's callback
            if (this.connect_callback) {
                try {
                    this.connect_callback(status, condition);
                } catch (e) {
                    Strophe.error("User connection callback caused an " +
                    "exception: " + e);
                }
            }
        },

        /** PrivateFunction: _doDisconnect
         *  _Private_ function to disconnect.
         *
         *  This is the last piece of the disconnection logic.  This resets the
         *  connection and alerts the user's connection callback.
         */
        _doDisconnect: function ()
        {
            // Cancel Disconnect Timeout
            if (this._disconnectTimeout !== null) {
                this.deleteTimedHandler(this._disconnectTimeout);
                this._disconnectTimeout = null;
            }

            Strophe.info("_doDisconnect was called");
            this._proto._doDisconnect();

            this.authenticated = false;
            this.disconnecting = false;

            // delete handlers
            this.handlers = [];
            this.timedHandlers = [];
            this.removeTimeds = [];
            this.removeHandlers = [];
            this.addTimeds = [];
            this.addHandlers = [];

            // tell the parent we disconnected
            this._changeConnectStatus(Strophe.Status.DISCONNECTED, null);
            this.connected = false;
        },

        /** PrivateFunction: _dataRecv
         *  _Private_ handler to processes incoming data from the the connection.
         *
         *  Except for _connect_cb handling the initial connection request,
         *  this function handles the incoming data for all requests.  This
         *  function also fires stanza handlers that match each incoming
         *  stanza.
         *
         *  Parameters:
         *    (Strophe.Request) req - The request that has data ready.
         *    (string) req - The stanza a raw string (optiona).
         */
        _dataRecv: function (req, raw)
        {
            Strophe.info("_dataRecv called");
            var elem = this._proto._reqToData(req);
            if (elem === null) { return; }

            if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
                    this.xmlInput(elem.childNodes[0]);
                } else {
                    this.xmlInput(elem);
                }
            }
            if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                if (raw) {
                    this.rawInput(raw);
                } else {
                    this.rawInput(Strophe.serialize(elem));
                }
            }

            // remove handlers scheduled for deletion
            var i, hand;
            while (this.removeHandlers.length > 0) {
                hand = this.removeHandlers.pop();
                i = this.handlers.indexOf(hand);
                if (i >= 0) {
                    this.handlers.splice(i, 1);
                }
            }

            // add handlers scheduled for addition
            while (this.addHandlers.length > 0) {
                this.handlers.push(this.addHandlers.pop());
            }

            // handle graceful disconnect
            if (this.disconnecting && this._proto._emptyQueue()) {
                this._doDisconnect();
                return;
            }

            var typ = elem.getAttribute("type");
            var cond, conflict;
            if (typ !== null && typ == "terminate") {
                // Don't process stanzas that come in after disconnect
                if (this.disconnecting) {
                    return;
                }

                // an error occurred
                cond = elem.getAttribute("condition");
                conflict = elem.getElementsByTagName("conflict");
                if (cond !== null) {
                    if (cond == "remote-stream-error" && conflict.length > 0) {
                        cond = "conflict";
                    }
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                } else {
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                }
                this.disconnect('unknown stream-error');
                return;
            }

            // send each incoming stanza through the handler chain
            var that = this;
            Strophe.forEachChild(elem, null, function (child) {
                var i, newList;
                // process handlers
                newList = that.handlers;
                that.handlers = [];
                for (i = 0; i < newList.length; i++) {
                    var hand = newList[i];
                    // encapsulate 'handler.run' not to lose the whole handler list if
                    // one of the handlers throws an exception
                    try {
                        if (hand.isMatch(child) &&
                                (that.authenticated || !hand.user)) {
                            if (hand.run(child)) {
                                that.handlers.push(hand);
                            }
                        } else {
                            that.handlers.push(hand);
                        }
                    } catch(e) {
                        // if the handler throws an exception, we consider it as false
                        Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message);
                    }
                }
            });
        },


        /** Attribute: mechanisms
         *  SASL Mechanisms available for Conncection.
         */
        mechanisms: {},

        /** PrivateFunction: _connect_cb
         *  _Private_ handler for initial connection request.
         *
         *  This handler is used to process the initial connection request
         *  response from the BOSH server. It is used to set up authentication
         *  handlers and start the authentication process.
         *
         *  SASL authentication will be attempted if available, otherwise
         *  the code will fall back to legacy authentication.
         *
         *  Parameters:
         *    (Strophe.Request) req - The current request.
         *    (Function) _callback - low level (xmpp) connect callback function.
         *      Useful for plugins with their own xmpp connect callback (when their)
         *      want to do something special).
         */
        _connect_cb: function (req, _callback, raw)
        {
            Strophe.info("_connect_cb was called");

            this.connected = true;

            var bodyWrap = this._proto._reqToData(req);
            if (!bodyWrap) { return; }

            if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
                    this.xmlInput(bodyWrap.childNodes[0]);
                } else {
                    this.xmlInput(bodyWrap);
                }
            }
            if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                if (raw) {
                    this.rawInput(raw);
                } else {
                    this.rawInput(Strophe.serialize(bodyWrap));
                }
            }

            var conncheck = this._proto._connect_cb(bodyWrap);
            if (conncheck === Strophe.Status.CONNFAIL) {
                return;
            }

            this._authentication.sasl_scram_sha1 = false;
            this._authentication.sasl_plain = false;
            this._authentication.sasl_digest_md5 = false;
            this._authentication.sasl_anonymous = false;

            this._authentication.legacy_auth = false;

            // Check for the stream:features tag
            var hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0;
            if (!hasFeatures) {
                hasFeatures = bodyWrap.getElementsByTagName("features").length > 0;
            }
            var mechanisms = bodyWrap.getElementsByTagName("mechanism");
            var matched = [];
            var i, mech, found_authentication = false;
            if (!hasFeatures) {
                this._proto._no_auth_received(_callback);
                return;
            }
            if (mechanisms.length > 0) {
                for (i = 0; i < mechanisms.length; i++) {
                    mech = Strophe.getText(mechanisms[i]);
                    if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);
                }
            }
            this._authentication.legacy_auth =
                    bodyWrap.getElementsByTagName("auth").length > 0;
            found_authentication = this._authentication.legacy_auth ||
            matched.length > 0;
            if (!found_authentication) {
                this._proto._no_auth_received(_callback);
                return;
            }
            if (this.do_authentication !== false)
                this.authenticate(matched);
        },

        /** Function: authenticate
         * Set up authentication
         *
         *  Contiunues the initial connection request by setting up authentication
         *  handlers and start the authentication process.
         *
         *  SASL authentication will be attempted if available, otherwise
         *  the code will fall back to legacy authentication.
         *
         */
        authenticate: function (matched)
        {
            var i;
            // Sorting matched mechanisms according to priority.
            for (i = 0; i < matched.length - 1; ++i) {
                var higher = i;
                for (var j = i + 1; j < matched.length; ++j) {
                    if (matched[j].prototype.priority > matched[higher].prototype.priority) {
                        higher = j;
                    }
                }
                if (higher != i) {
                    var swap = matched[i];
                    matched[i] = matched[higher];
                    matched[higher] = swap;
                }
            }

            // run each mechanism
            var mechanism_found = false;
            for (i = 0; i < matched.length; ++i) {
                if (!matched[i].test(this)) continue;

                this._sasl_success_handler = this._addSysHandler(
                        this._sasl_success_cb.bind(this), null,
                        "success", null, null);
                this._sasl_failure_handler = this._addSysHandler(
                        this._sasl_failure_cb.bind(this), null,
                        "failure", null, null);
                this._sasl_challenge_handler = this._addSysHandler(
                        this._sasl_challenge_cb.bind(this), null,
                        "challenge", null, null);

                this._sasl_mechanism = new matched[i]();
                this._sasl_mechanism.onStart(this);

                var request_auth_exchange = $build("auth", {
                    xmlns: Strophe.NS.SASL,
                    mechanism: this._sasl_mechanism.name
                });

                if (this._sasl_mechanism.isClientFirst) {
                    var response = this._sasl_mechanism.onChallenge(this, null);
                    request_auth_exchange.t(Base64.encode(response));
                }

                this.send(request_auth_exchange.tree());

                mechanism_found = true;
                break;
            }

            if (!mechanism_found) {
                // if none of the mechanism worked
                if (Strophe.getNodeFromJid(this.jid) === null) {
                    // we don't have a node, which is required for non-anonymous
                    // client connections
                    this._changeConnectStatus(Strophe.Status.CONNFAIL,
                            'x-strophe-bad-non-anon-jid');
                    this.disconnect('x-strophe-bad-non-anon-jid');
                } else {
                    // fall back to legacy authentication
                    this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
                    this._addSysHandler(this._auth1_cb.bind(this), null, null,
                            null, "_auth_1");

                    this.send($iq({
                        type: "get",
                        to: this.domain,
                        id: "_auth_1"
                    }).c("query", {
                        xmlns: Strophe.NS.AUTH
                    }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree());
                }
            }

        },

        _sasl_challenge_cb: function(elem) {
            var challenge = Base64.decode(Strophe.getText(elem));
            var response = this._sasl_mechanism.onChallenge(this, challenge);

            var stanza = $build('response', {
                xmlns: Strophe.NS.SASL
            });
            if (response !== "") {
                stanza.t(Base64.encode(response));
            }
            this.send(stanza.tree());

            return true;
        },

        /** PrivateFunction: _auth1_cb
         *  _Private_ handler for legacy authentication.
         *
         *  This handler is called in response to the initial <iq type='get'/>
         *  for legacy authentication.  It builds an authentication <iq/> and
         *  sends it, creating a handler (calling back to _auth2_cb()) to
         *  handle the result
         *
         *  Parameters:
         *    (XMLElement) elem - The stanza that triggered the callback.
         *
         *  Returns:
         *    false to remove the handler.
         */
        /* jshint unused:false */
        _auth1_cb: function (elem)
        {
            // build plaintext auth iq
            var iq = $iq({type: "set", id: "_auth_2"})
                    .c('query', {xmlns: Strophe.NS.AUTH})
                    .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
                    .up()
                    .c('password').t(this.pass);

            if (!Strophe.getResourceFromJid(this.jid)) {
                // since the user has not supplied a resource, we pick
                // a default one here.  unlike other auth methods, the server
                // cannot do this for us.
                this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
            }
            iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

            this._addSysHandler(this._auth2_cb.bind(this), null,
                    null, null, "_auth_2");

            this.send(iq.tree());

            return false;
        },
        /* jshint unused:true */

        /** PrivateFunction: _sasl_success_cb
         *  _Private_ handler for succesful SASL authentication.
         *
         *  Parameters:
         *    (XMLElement) elem - The matching stanza.
         *
         *  Returns:
         *    false to remove the handler.
         */
        _sasl_success_cb: function (elem)
        {
            if (this._sasl_data["server-signature"]) {
                var serverSignature;
                var success = Base64.decode(Strophe.getText(elem));
                var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
                var matches = success.match(attribMatch);
                if (matches[1] == "v") {
                    serverSignature = matches[2];
                }

                if (serverSignature != this._sasl_data["server-signature"]) {
                    // remove old handlers
                    this.deleteHandler(this._sasl_failure_handler);
                    this._sasl_failure_handler = null;
                    if (this._sasl_challenge_handler) {
                        this.deleteHandler(this._sasl_challenge_handler);
                        this._sasl_challenge_handler = null;
                    }

                    this._sasl_data = {};
                    return this._sasl_failure_cb(null);
                }
            }

            Strophe.info("SASL authentication succeeded.");

            if(this._sasl_mechanism)
                this._sasl_mechanism.onSuccess();

            // remove old handlers
            this.deleteHandler(this._sasl_failure_handler);
            this._sasl_failure_handler = null;
            if (this._sasl_challenge_handler) {
                this.deleteHandler(this._sasl_challenge_handler);
                this._sasl_challenge_handler = null;
            }

            this._addSysHandler(this._sasl_auth1_cb.bind(this), null,
                    "stream:features", null, null);

            // we must send an xmpp:restart now
            this._sendRestart();

            return false;
        },

        /** PrivateFunction: _sasl_auth1_cb
         *  _Private_ handler to start stream binding.
         *
         *  Parameters:
         *    (XMLElement) elem - The matching stanza.
         *
         *  Returns:
         *    false to remove the handler.
         */
        _sasl_auth1_cb: function (elem)
        {
            // save stream:features for future usage
            this.features = elem;

            var i, child;

            for (i = 0; i < elem.childNodes.length; i++) {
                child = elem.childNodes[i];
                if (child.nodeName == 'bind') {
                    this.do_bind = true;
                }

                if (child.nodeName == 'session') {
                    this.do_session = true;
                }
            }

            if (!this.do_bind) {
                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                return false;
            } else {
                this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,
                        null, "_bind_auth_2");

                var resource = Strophe.getResourceFromJid(this.jid);
                if (resource) {
                    this.send($iq({type: "set", id: "_bind_auth_2"})
                            .c('bind', {xmlns: Strophe.NS.BIND})
                            .c('resource', {}).t(resource).tree());
                } else {
                    this.send($iq({type: "set", id: "_bind_auth_2"})
                            .c('bind', {xmlns: Strophe.NS.BIND})
                            .tree());
                }
            }

            return false;
        },

        /** PrivateFunction: _sasl_bind_cb
         *  _Private_ handler for binding result and session start.
         *
         *  Parameters:
         *    (XMLElement) elem - The matching stanza.
         *
         *  Returns:
         *    false to remove the handler.
         */
        _sasl_bind_cb: function (elem)
        {
            if (elem.getAttribute("type") == "error") {
                Strophe.info("SASL binding failed.");
                var conflict = elem.getElementsByTagName("conflict"), condition;
                if (conflict.length > 0) {
                    condition = 'conflict';
                }
                this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
                return false;
            }

            // TODO - need to grab errors
            var bind = elem.getElementsByTagName("bind");
            var jidNode;
            if (bind.length > 0) {
                // Grab jid
                jidNode = bind[0].getElementsByTagName("jid");
                if (jidNode.length > 0) {
                    this.jid = Strophe.getText(jidNode[0]);

                    if (this.do_session) {
                        this._addSysHandler(this._sasl_session_cb.bind(this),
                                null, null, null, "_session_auth_2");

                        this.send($iq({type: "set", id: "_session_auth_2"})
                                .c('session', {xmlns: Strophe.NS.SESSION})
                                .tree());
                    } else {
                        this.authenticated = true;
                        this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                    }
                }
            } else {
                Strophe.info("SASL binding failed.");
                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                return false;
            }
        },

        /** PrivateFunction: _sasl_session_cb
         *  _Private_ handler to finish successful SASL connection.
         *
         *  This sets Connection.authenticated to true on success, which
         *  starts the processing of user handlers.
         *
         *  Parameters:
         *    (XMLElement) elem - The matching stanza.
         *
         *  Returns:
         *    false to remove the handler.
         */
        _sasl_session_cb: function (elem)
        {
            if (elem.getAttribute("type") == "result") {
                this.authenticated = true;
                this._changeConnectStatus(Strophe.Status.CONNECTED, null);
            } else if (elem.getAttribute("type") == "error") {
                Strophe.info("Session creation failed.");
                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                return false;
            }

            return false;
        },

        /** PrivateFunction: _sasl_failure_cb
         *  _Private_ handler for SASL authentication failure.
         *
         *  Parameters:
         *    (XMLElement) elem - The matching stanza.
         *
         *  Returns:
         *    false to remove the handler.
         */
        /* jshint unused:false */
        _sasl_failure_cb: function (elem)
        {
            // delete unneeded handlers
            if (this._sasl_success_handler) {
                this.deleteHandler(this._sasl_success_handler);
                this._sasl_success_handler = null;
            }
            if (this._sasl_challenge_handler) {
                this.deleteHandler(this._sasl_challenge_handler);
                this._sasl_challenge_handler = null;
            }

            if(this._sasl_mechanism)
                this._sasl_mechanism.onFailure();
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        },
        /* jshint unused:true */

        /** PrivateFunction: _auth2_cb
         *  _Private_ handler to finish legacy authentication.
         *
         *  This handler is called when the result from the jabber:iq:auth
         *  <iq/> stanza is returned.
         *
         *  Parameters:
         *    (XMLElement) elem - The stanza that triggered the callback.
         *
         *  Returns:
         *    false to remove the handler.
         */
        _auth2_cb: function (elem)
        {
            if (elem.getAttribute("type") == "result") {
                this.authenticated = true;
                this._changeConnectStatus(Strophe.Status.CONNECTED, null);
            } else if (elem.getAttribute("type") == "error") {
                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                this.disconnect('authentication failed');
            }

            return false;
        },

        /** PrivateFunction: _addSysTimedHandler
         *  _Private_ function to add a system level timed handler.
         *
         *  This function is used to add a Strophe.TimedHandler for the
         *  library code.  System timed handlers are allowed to run before
         *  authentication is complete.
         *
         *  Parameters:
         *    (Integer) period - The period of the handler.
         *    (Function) handler - The callback function.
         */
        _addSysTimedHandler: function (period, handler)
        {
            var thand = new Strophe.TimedHandler(period, handler);
            thand.user = false;
            this.addTimeds.push(thand);
            return thand;
        },

        /** PrivateFunction: _addSysHandler
         *  _Private_ function to add a system level stanza handler.
         *
         *  This function is used to add a Strophe.Handler for the
         *  library code.  System stanza handlers are allowed to run before
         *  authentication is complete.
         *
         *  Parameters:
         *    (Function) handler - The callback function.
         *    (String) ns - The namespace to match.
         *    (String) name - The stanza name to match.
         *    (String) type - The stanza type attribute to match.
         *    (String) id - The stanza id attribute to match.
         */
        _addSysHandler: function (handler, ns, name, type, id)
        {
            var hand = new Strophe.Handler(handler, ns, name, type, id);
            hand.user = false;
            this.addHandlers.push(hand);
            return hand;
        },

        /** PrivateFunction: _onDisconnectTimeout
         *  _Private_ timeout handler for handling non-graceful disconnection.
         *
         *  If the graceful disconnect process does not complete within the
         *  time allotted, this handler finishes the disconnect anyway.
         *
         *  Returns:
         *    false to remove the handler.
         */
        _onDisconnectTimeout: function ()
        {
            Strophe.info("_onDisconnectTimeout was called");

            this._proto._onDisconnectTimeout();

            // actually disconnect
            this._doDisconnect();

            return false;
        },

        /** PrivateFunction: _onIdle
         *  _Private_ handler to process events during idle cycle.
         *
         *  This handler is called every 100ms to fire timed handlers that
         *  are ready and keep poll requests going.
         */
        _onIdle: function ()
        {
            var i, thand, since, newList;

            // add timed handlers scheduled for addition
            // NOTE: we add before remove in the case a timed handler is
            // added and then deleted before the next _onIdle() call.
            while (this.addTimeds.length > 0) {
                this.timedHandlers.push(this.addTimeds.pop());
            }

            // remove timed handlers that have been scheduled for deletion
            while (this.removeTimeds.length > 0) {
                thand = this.removeTimeds.pop();
                i = this.timedHandlers.indexOf(thand);
                if (i >= 0) {
                    this.timedHandlers.splice(i, 1);
                }
            }

            // call ready timed handlers
            var now = new Date().getTime();
            newList = [];
            for (i = 0; i < this.timedHandlers.length; i++) {
                thand = this.timedHandlers[i];
                if (this.authenticated || !thand.user) {
                    since = thand.lastCalled + thand.period;
                    if (since - now <= 0) {
                        if (thand.run()) {
                            newList.push(thand);
                        }
                    } else {
                        newList.push(thand);
                    }
                }
            }
            this.timedHandlers = newList;

            clearTimeout(this._idleTimeout);

            this._proto._onIdle();

            // reactivate the timer only if connected
            if (this.connected) {
                this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
            }
        }
    };

    if (callback) {
        callback(Strophe, $build, $msg, $iq, $pres);
    }

    /** Class: Strophe.SASLMechanism
     *
     *  encapsulates SASL authentication mechanisms.
     *
     *  User code may override the priority for each mechanism or disable it completely.
     *  See <priority> for information about changing priority and <test> for informatian on
     *  how to disable a mechanism.
     *
     *  By default, all mechanisms are enabled and the priorities are
     *
     *  SCRAM-SHA1 - 40
     *  DIGEST-MD5 - 30
     *  Plain - 20
     */

    /**
     * PrivateConstructor: Strophe.SASLMechanism
     * SASL auth mechanism abstraction.
     *
     *  Parameters:
     *    (String) name - SASL Mechanism name.
     *    (Boolean) isClientFirst - If client should send response first without challenge.
     *    (Number) priority - Priority.
     *
     *  Returns:
     *    A new Strophe.SASLMechanism object.
     */
    Strophe.SASLMechanism = function(name, isClientFirst, priority) {
        /** PrivateVariable: name
         *  Mechanism name.
         */
        this.name = name;
        /** PrivateVariable: isClientFirst
         *  If client sends response without initial server challenge.
         */
        this.isClientFirst = isClientFirst;
        /** Variable: priority
         *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).
         *  Users may override this to prioritize mechanisms differently.
         *
         *  In the default configuration the priorities are
         *
         *  SCRAM-SHA1 - 40
         *  DIGEST-MD5 - 30
         *  Plain - 20
         *
         *  Example: (This will cause Strophe to choose the mechanism that the server sent first)
         *
         *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;
         *
         *  See <SASL mechanisms> for a list of available mechanisms.
         *
         */
        this.priority = priority;
    };

    Strophe.SASLMechanism.prototype = {
        /**
         *  Function: test
         *  Checks if mechanism able to run.
         *  To disable a mechanism, make this return false;
         *
         *  To disable plain authentication run
         *  > Strophe.SASLPlain.test = function() {
   *  >   return false;
   *  > }
         *
         *  See <SASL mechanisms> for a list of available mechanisms.
         *
         *  Parameters:
         *    (Strophe.Connection) connection - Target Connection.
         *
         *  Returns:
         *    (Boolean) If mechanism was able to run.
         */
        /* jshint unused:false */
        test: function(connection) {
            return true;
        },
        /* jshint unused:true */

        /** PrivateFunction: onStart
         *  Called before starting mechanism on some connection.
         *
         *  Parameters:
         *    (Strophe.Connection) connection - Target Connection.
         */
        onStart: function(connection)
        {
            this._connection = connection;
        },

        /** PrivateFunction: onChallenge
         *  Called by protocol implementation on incoming challenge. If client is
         *  first (isClientFirst == true) challenge will be null on the first call.
         *
         *  Parameters:
         *    (Strophe.Connection) connection - Target Connection.
         *    (String) challenge - current challenge to handle.
         *
         *  Returns:
         *    (String) Mechanism response.
         */
        /* jshint unused:false */
        onChallenge: function(connection, challenge) {
            throw new Error("You should implement challenge handling!");
        },
        /* jshint unused:true */

        /** PrivateFunction: onFailure
         *  Protocol informs mechanism implementation about SASL failure.
         */
        onFailure: function() {
            this._connection = null;
        },

        /** PrivateFunction: onSuccess
         *  Protocol informs mechanism implementation about SASL success.
         */
        onSuccess: function() {
            this._connection = null;
        }
    };

    /** Constants: SASL mechanisms
     *  Available authentication mechanisms
     *
     *  Strophe.SASLAnonymous - SASL Anonymous authentication.
     *  Strophe.SASLPlain - SASL Plain authentication.
     *  Strophe.SASLMD5 - SASL Digest-MD5 authentication
     *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication
     */

// Building SASL callbacks

    /** PrivateConstructor: SASLAnonymous
     *  SASL Anonymous authentication.
     */
    Strophe.SASLAnonymous = function() {};

    Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 10);

    Strophe.SASLAnonymous.test = function(connection) {
        return connection.authcid === null;
    };

    Strophe.Connection.prototype.mechanisms[Strophe.SASLAnonymous.prototype.name] = Strophe.SASLAnonymous;

    /** PrivateConstructor: SASLPlain
     *  SASL Plain authentication.
     */
    Strophe.SASLPlain = function() {};

    Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 20);

    Strophe.SASLPlain.test = function(connection) {
        return connection.authcid !== null;
    };

    Strophe.SASLPlain.prototype.onChallenge = function(connection) {
        var auth_str = connection.authzid;
        auth_str = auth_str + "\u0000";
        auth_str = auth_str + connection.authcid;
        auth_str = auth_str + "\u0000";
        auth_str = auth_str + connection.pass;
        return auth_str;
    };

    Strophe.Connection.prototype.mechanisms[Strophe.SASLPlain.prototype.name] = Strophe.SASLPlain;

    /** PrivateConstructor: SASLSHA1
     *  SASL SCRAM SHA 1 authentication.
     */
    Strophe.SASLSHA1 = function() {};

    /* TEST:
     * This is a simple example of a SCRAM-SHA-1 authentication exchange
     * when the client doesn't support channel bindings (username 'user' and
     * password 'pencil' are used):
     *
     * C: n,,n=user,r=fyko+d2lbbFgONRv9qkxdawL
     * S: r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,s=QSXCR+Q6sek8bf92,
     * i=4096
     * C: c=biws,r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,
     * p=v0X8v3Bz2T0CJGbJQyF0X+HI4Ts=
     * S: v=rmF9pqV8S7suAoZWja4dJRkFsKQ=
     *
     */

    Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 40);

    Strophe.SASLSHA1.test = function(connection) {
        return connection.authcid !== null;
    };

    Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
        var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);

        var auth_str = "n=" + connection.authcid;
        auth_str += ",r=";
        auth_str += cnonce;

        connection._sasl_data.cnonce = cnonce;
        connection._sasl_data["client-first-message-bare"] = auth_str;

        auth_str = "n,," + auth_str;

        this.onChallenge = function (connection, challenge)
        {
            var nonce, salt, iter, Hi, U, U_old, i, k;
            var clientKey, serverKey, clientSignature;
            var responseText = "c=biws,";
            var authMessage = connection._sasl_data["client-first-message-bare"] + "," +
                    challenge + ",";
            var cnonce = connection._sasl_data.cnonce;
            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;

            while (challenge.match(attribMatch)) {
                var matches = challenge.match(attribMatch);
                challenge = challenge.replace(matches[0], "");
                switch (matches[1]) {
                    case "r":
                        nonce = matches[2];
                        break;
                    case "s":
                        salt = matches[2];
                        break;
                    case "i":
                        iter = matches[2];
                        break;
                }
            }

            if (nonce.substr(0, cnonce.length) !== cnonce) {
                connection._sasl_data = {};
                return connection._sasl_failure_cb();
            }

            responseText += "r=" + nonce;
            authMessage += responseText;

            salt = Base64.decode(salt);
            salt += "\x00\x00\x00\x01";

            Hi = U_old = core_hmac_sha1(connection.pass, salt);
            for (i = 1; i < iter; i++) {
                U = core_hmac_sha1(connection.pass, binb2str(U_old));
                for (k = 0; k < 5; k++) {
                    Hi[k] ^= U[k];
                }
                U_old = U;
            }
            Hi = binb2str(Hi);

            clientKey = core_hmac_sha1(Hi, "Client Key");
            serverKey = str_hmac_sha1(Hi, "Server Key");
            clientSignature = core_hmac_sha1(str_sha1(binb2str(clientKey)), authMessage);
            connection._sasl_data["server-signature"] = b64_hmac_sha1(serverKey, authMessage);

            for (k = 0; k < 5; k++) {
                clientKey[k] ^= clientSignature[k];
            }

            responseText += ",p=" + Base64.encode(binb2str(clientKey));

            return responseText;
        }.bind(this);

        return auth_str;
    };

    Strophe.Connection.prototype.mechanisms[Strophe.SASLSHA1.prototype.name] = Strophe.SASLSHA1;

    /** PrivateConstructor: SASLMD5
     *  SASL DIGEST MD5 authentication.
     */
    Strophe.SASLMD5 = function() {};

    Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 30);

    Strophe.SASLMD5.test = function(connection) {
        return connection.authcid !== null;
    };

    /** PrivateFunction: _quote
     *  _Private_ utility function to backslash escape and quote strings.
     *
     *  Parameters:
     *    (String) str - The string to be quoted.
     *
     *  Returns:
     *    quoted string
     */
    Strophe.SASLMD5.prototype._quote = function (str)
    {
        return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
        //" end string workaround for emacs
    };


    Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
        var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
        var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
        var realm = "";
        var host = null;
        var nonce = "";
        var qop = "";
        var matches;

        while (challenge.match(attribMatch)) {
            matches = challenge.match(attribMatch);
            challenge = challenge.replace(matches[0], "");
            matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
            switch (matches[1]) {
                case "realm":
                    realm = matches[2];
                    break;
                case "nonce":
                    nonce = matches[2];
                    break;
                case "qop":
                    qop = matches[2];
                    break;
                case "host":
                    host = matches[2];
                    break;
            }
        }

        var digest_uri = connection.servtype + "/" + connection.domain;
        if (host !== null) {
            digest_uri = digest_uri + "/" + host;
        }

        var A1 = MD5.hash(connection.authcid +
                ":" + realm + ":" + this._connection.pass) +
                ":" + nonce + ":" + cnonce;
        var A2 = 'AUTHENTICATE:' + digest_uri;

        var responseText = "";
        responseText += 'charset=utf-8,';
        responseText += 'username=' +
        this._quote(connection.authcid) + ',';
        responseText += 'realm=' + this._quote(realm) + ',';
        responseText += 'nonce=' + this._quote(nonce) + ',';
        responseText += 'nc=00000001,';
        responseText += 'cnonce=' + this._quote(cnonce) + ',';
        responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
        responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + ":" +
        nonce + ":00000001:" +
        cnonce + ":auth:" +
        MD5.hexdigest(A2)) + ",";
        responseText += 'qop=auth';

        this.onChallenge = function ()
        {
            return "";
        }.bind(this);

        return responseText;
    };

    Strophe.Connection.prototype.mechanisms[Strophe.SASLMD5.prototype.name] = Strophe.SASLMD5;

})(function () {
    window.Strophe = arguments[0];
    window.$build = arguments[1];
    window.$msg = arguments[2];
    window.$iq = arguments[3];
    window.$pres = arguments[4];
});

/*
 This program is distributed under the terms of the MIT license.
 Please see the LICENSE file for details.

 Copyright 2006-2008, OGG, LLC
 */

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/*global window, setTimeout, clearTimeout,
 XMLHttpRequest, ActiveXObject,
 Strophe, $build */


/** PrivateClass: Strophe.Request
 *  _Private_ helper class that provides a cross implementation abstraction
 *  for a BOSH related XMLHttpRequest.
 *
 *  The Strophe.Request class is used internally to encapsulate BOSH request
 *  information.  It is not meant to be used from user's code.
 */

/** PrivateConstructor: Strophe.Request
 *  Create and initialize a new Strophe.Request object.
 *
 *  Parameters:
 *    (XMLElement) elem - The XML data to be sent in the request.
 *    (Function) func - The function that will be called when the
 *      XMLHttpRequest readyState changes.
 *    (Integer) rid - The BOSH rid attribute associated with this request.
 *    (Integer) sends - The number of times this same request has been
 *      sent.
 */
Strophe.Request = function (elem, func, rid, sends)
{
    this.id = ++Strophe._requestId;
    this.xmlData = elem;
    this.data = Strophe.serialize(elem);
    // save original function in case we need to make a new request
    // from this one.
    this.origFunc = func;
    this.func = func;
    this.rid = rid;
    this.date = NaN;
    this.sends = sends || 0;
    this.abort = false;
    this.dead = null;

    this.age = function () {
        if (!this.date) { return 0; }
        var now = new Date();
        return (now - this.date) / 1000;
    };
    this.timeDead = function () {
        if (!this.dead) { return 0; }
        var now = new Date();
        return (now - this.dead) / 1000;
    };
    this.xhr = this._newXHR();
};

Strophe.Request.prototype = {
    /** PrivateFunction: getResponse
     *  Get a response from the underlying XMLHttpRequest.
     *
     *  This function attempts to get a response from the request and checks
     *  for errors.
     *
     *  Throws:
     *    "parsererror" - A parser error occured.
     *
     *  Returns:
     *    The DOM element tree of the response.
     */
    getResponse: function ()
    {
        var node = null;
        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
            node = this.xhr.responseXML.documentElement;
            if (node.tagName == "parsererror") {
                Strophe.error("invalid response received");
                Strophe.error("responseText: " + this.xhr.responseText);
                Strophe.error("responseXML: " +
                Strophe.serialize(this.xhr.responseXML));
                throw "parsererror";
            }
        } else if (this.xhr.responseText) {
            Strophe.error("invalid response received");
            Strophe.error("responseText: " + this.xhr.responseText);
            Strophe.error("responseXML: " +
            Strophe.serialize(this.xhr.responseXML));
        }

        return node;
    },

    /** PrivateFunction: _newXHR
     *  _Private_ helper function to create XMLHttpRequests.
     *
     *  This function creates XMLHttpRequests across all implementations.
     *
     *  Returns:
     *    A new XMLHttpRequest.
     */
    _newXHR: function ()
    {
        var xhr = null;
        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
            if (xhr.overrideMimeType) {
                xhr.overrideMimeType("text/xml");
            }
        } else if (window.ActiveXObject) {
            xhr = new ActiveXObject("Microsoft.XMLHTTP");
        }

        // use Function.bind() to prepend ourselves as an argument
        xhr.onreadystatechange = this.func.bind(null, this);

        return xhr;
    }
};

/** Class: Strophe.Bosh
 *  _Private_ helper class that handles BOSH Connections
 *
 *  The Strophe.Bosh class is used internally by Strophe.Connection
 *  to encapsulate BOSH sessions. It is not meant to be used from user's code.
 */

/** File: bosh.js
 *  A JavaScript library to enable BOSH in Strophejs.
 *
 *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)
 *  to emulate a persistent, stateful, two-way connection to an XMPP server.
 *  More information on BOSH can be found in XEP 124.
 */

/** PrivateConstructor: Strophe.Bosh
 *  Create and initialize a Strophe.Bosh object.
 *
 *  Parameters:
 *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.
 *
 *  Returns:
 *    A new Strophe.Bosh object.
 */
Strophe.Bosh = function(connection) {
    this._conn = connection;
    /* request id for body tags */
    this.rid = Math.floor(Math.random() * 4294967295);
    /* The current session ID. */
    this.sid = null;

    // default BOSH values
    this.hold = 1;
    this.wait = 60;
    this.window = 5;

    this._requests = [];
};

Strophe.Bosh.prototype = {
    /** Variable: strip
     *
     *  BOSH-Connections will have all stanzas wrapped in a <body> tag when
     *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.
     *  To strip this tag, User code can set <Strophe.Bosh.strip> to "body":
     *
     *  > Strophe.Bosh.prototype.strip = "body";
     *
     *  This will enable stripping of the body tag in both
     *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.
     */
    strip: null,

    /** PrivateFunction: _buildBody
     *  _Private_ helper function to generate the <body/> wrapper for BOSH.
     *
     *  Returns:
     *    A Strophe.Builder with a <body/> element.
     */
    _buildBody: function ()
    {
        var bodyWrap = $build('body', {
            rid: this.rid++,
            xmlns: Strophe.NS.HTTPBIND
        });

        if (this.sid !== null) {
            bodyWrap.attrs({sid: this.sid});
        }

        return bodyWrap;
    },

    /** PrivateFunction: _reset
     *  Reset the connection.
     *
     *  This function is called by the reset function of the Strophe Connection
     */
    _reset: function ()
    {
        this.rid = Math.floor(Math.random() * 4294967295);
        this.sid = null;
    },

    /** PrivateFunction: _connect
     *  _Private_ function that initializes the BOSH connection.
     *
     *  Creates and sends the Request that initializes the BOSH connection.
     */
    _connect: function (wait, hold, route)
    {
        this.wait = wait || this.wait;
        this.hold = hold || this.hold;

        // build the body tag
        var body = this._buildBody().attrs({
            to: this._conn.domain,
            "xml:lang": "en",
            wait: this.wait,
            hold: this.hold,
            content: "text/xml; charset=utf-8",
            ver: "1.6",
            "xmpp:version": "1.0",
            "xmlns:xmpp": Strophe.NS.BOSH
        });

        if(route){
            body.attrs({
                route: route
            });
        }

        var _connect_cb = this._conn._connect_cb;

        this._requests.push(
                new Strophe.Request(body.tree(),
                        this._onRequestStateChange.bind(
                                this, _connect_cb.bind(this._conn)),
                        body.tree().getAttribute("rid")));
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _attach
     *  Attach to an already created and authenticated BOSH session.
     *
     *  This function is provided to allow Strophe to attach to BOSH
     *  sessions which have been created externally, perhaps by a Web
     *  application.  This is often used to support auto-login type features
     *  without putting user credentials into the page.
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *    (String) sid - The SID of the BOSH session.
     *    (String) rid - The current RID of the BOSH session.  This RID
     *      will be used by the next request.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    _attach: function (jid, sid, rid, callback, wait, hold, wind)
    {
        this._conn.jid = jid;
        this.sid = sid;
        this.rid = rid;

        this._conn.connect_callback = callback;

        this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);

        this._conn.authenticated = true;
        this._conn.connected = true;

        this.wait = wait || this.wait;
        this.hold = hold || this.hold;
        this.window = wind || this.window;

        this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);
    },

    /** PrivateFunction: _connect_cb
     *  _Private_ handler for initial connection request.
     *
     *  This handler is used to process the Bosh-part of the initial request.
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     */
    _connect_cb: function (bodyWrap)
    {
        var typ = bodyWrap.getAttribute("type");
        var cond, conflict;
        if (typ !== null && typ == "terminate") {
            // an error occurred
            Strophe.error("BOSH-Connection failed: " + cond);
            cond = bodyWrap.getAttribute("condition");
            conflict = bodyWrap.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            this._conn._doDisconnect();
            return Strophe.Status.CONNFAIL;
        }

        // check to make sure we don't overwrite these if _connect_cb is
        // called multiple times in the case of missing stream:features
        if (!this.sid) {
            this.sid = bodyWrap.getAttribute("sid");
        }
        var wind = bodyWrap.getAttribute('requests');
        if (wind) { this.window = parseInt(wind, 10); }
        var hold = bodyWrap.getAttribute('hold');
        if (hold) { this.hold = parseInt(hold, 10); }
        var wait = bodyWrap.getAttribute('wait');
        if (wait) { this.wait = parseInt(wait, 10); }
    },

    /** PrivateFunction: _disconnect
     *  _Private_ part of Connection.disconnect for Bosh
     *
     *  Parameters:
     *    (Request) pres - This stanza will be sent before disconnecting.
     */
    _disconnect: function (pres)
    {
        this._sendTerminate(pres);
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  Resets the SID and RID.
     */
    _doDisconnect: function ()
    {
        this.sid = null;
        this.rid = Math.floor(Math.random() * 4294967295);
    },

    /** PrivateFunction: _emptyQueue
     * _Private_ function to check if the Request queue is empty.
     *
     *  Returns:
     *    True, if there are no Requests queued, False otherwise.
     */
    _emptyQueue: function ()
    {
        return this._requests.length === 0;
    },

    /** PrivateFunction: _hitError
     *  _Private_ function to handle the error count.
     *
     *  Requests are resent automatically until their error count reaches
     *  5.  Each time an error is encountered, this function is called to
     *  increment the count and disconnect if the count is too high.
     *
     *  Parameters:
     *    (Integer) reqStatus - The request status.
     */
    _hitError: function (reqStatus)
    {
        this.errors++;
        Strophe.warn("request errored, status: " + reqStatus +
        ", number of errors: " + this.errors);
        if (this.errors > 4) {
            this._onDisconnectTimeout();
        }
    },

    /** PrivateFunction: _no_auth_received
     *
     * Called on stream start/restart when no stream:features
     * has been received and sends a blank poll request.
     */
    _no_auth_received: function (_callback)
    {
        if (_callback) {
            _callback = _callback.bind(this._conn);
        } else {
            _callback = this._conn._connect_cb.bind(this._conn);
        }
        var body = this._buildBody();
        this._requests.push(
                new Strophe.Request(body.tree(),
                        this._onRequestStateChange.bind(
                                this, _callback.bind(this._conn)),
                        body.tree().getAttribute("rid")));
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  Cancels all remaining Requests and clears the queue.
     */
    _onDisconnectTimeout: function ()
    {
        var req;
        while (this._requests.length > 0) {
            req = this._requests.pop();
            req.abort = true;
            req.xhr.abort();
            // jslint complains, but this is fine. setting to empty func
            // is necessary for IE6
            req.xhr.onreadystatechange = function () {}; // jshint ignore:line
        }
    },

    /** PrivateFunction: _onIdle
     *  _Private_ handler called by Strophe.Connection._onIdle
     *
     *  Sends all queued Requests or polls with empty Request if there are none.
     */
    _onIdle: function () {
        var data = this._conn._data;

        // if no requests are in progress, poll
        if (this._conn.authenticated && this._requests.length === 0 &&
                data.length === 0 && !this._conn.disconnecting) {
            Strophe.info("no requests during idle cycle, sending " +
            "blank request");
            data.push(null);
        }

        if (this._requests.length < 2 && data.length > 0 &&
                !this._conn.paused) {
            var body = this._buildBody();
            for (var i = 0; i < data.length; i++) {
                if (data[i] !== null) {
                    if (data[i] === "restart") {
                        body.attrs({
                            to: this._conn.domain,
                            "xml:lang": "en",
                            "xmpp:restart": "true",
                            "xmlns:xmpp": Strophe.NS.BOSH
                        });
                    } else {
                        body.cnode(data[i]).up();
                    }
                }
            }
            delete this._conn._data;
            this._conn._data = [];
            this._requests.push(
                    new Strophe.Request(body.tree(),
                            this._onRequestStateChange.bind(
                                    this, this._conn._dataRecv.bind(this._conn)),
                            body.tree().getAttribute("rid")));
            this._processRequest(this._requests.length - 1);
        }

        if (this._requests.length > 0) {
            var time_elapsed = this._requests[0].age();
            if (this._requests[0].dead !== null) {
                if (this._requests[0].timeDead() >
                        Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                    this._throttledRequestHandler();
                }
            }

            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                Strophe.warn("Request " +
                this._requests[0].id +
                " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                " seconds since last activity");
                this._throttledRequestHandler();
            }
        }
    },

    /** PrivateFunction: _onRequestStateChange
     *  _Private_ handler for Strophe.Request state changes.
     *
     *  This function is called when the XMLHttpRequest readyState changes.
     *  It contains a lot of error handling logic for the many ways that
     *  requests can fail, and calls the request callback when requests
     *  succeed.
     *
     *  Parameters:
     *    (Function) func - The handler for the request.
     *    (Strophe.Request) req - The request that is changing readyState.
     */
    _onRequestStateChange: function (func, req)
    {
        Strophe.debug("request id " + req.id +
        "." + req.sends + " state changed to " +
        req.xhr.readyState);

        if (req.abort) {
            req.abort = false;
            return;
        }

        // request complete
        var reqStatus;
        if (req.xhr.readyState == 4) {
            reqStatus = 0;
            try {
                reqStatus = req.xhr.status;
            } catch (e) {
                // ignore errors from undefined status attribute.  works
                // around a browser bug
            }

            if (typeof(reqStatus) == "undefined") {
                reqStatus = 0;
            }

            if (this.disconnecting) {
                if (reqStatus >= 400) {
                    this._hitError(reqStatus);
                    return;
                }
            }

            var reqIs0 = (this._requests[0] == req);
            var reqIs1 = (this._requests[1] == req);

            if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                // remove from internal queue
                this._removeRequest(req);
                Strophe.debug("request id " +
                req.id +
                " should now be removed");
            }

            // request succeeded
            if (reqStatus == 200) {
                // if request 1 finished, or request 0 finished and request
                // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
                // restart the other - both will be in the first spot, as the
                // completed request has been removed from the queue already
                if (reqIs1 ||
                        (reqIs0 && this._requests.length > 0 &&
                        this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                    this._restartRequest(0);
                }
                // call handler
                Strophe.debug("request id " +
                req.id + "." +
                req.sends + " got 200");
                func(req);
                this.errors = 0;
            } else {
                Strophe.error("request id " +
                req.id + "." +
                req.sends + " error " + reqStatus +
                " happened");
                if (reqStatus === 0 ||
                        (reqStatus >= 400 && reqStatus < 600) ||
                        reqStatus >= 12000) {
                    this._hitError(reqStatus);
                    if (reqStatus >= 400 && reqStatus < 500) {
                        this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING,
                                null);
                        this._conn._doDisconnect();
                    }
                }
            }

            if (!((reqStatus > 0 && reqStatus < 500) ||
                    req.sends > 5)) {
                this._throttledRequestHandler();
            }
        }
    },

    /** PrivateFunction: _processRequest
     *  _Private_ function to process a request in the queue.
     *
     *  This function takes requests off the queue and sends them and
     *  restarts dead requests.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _processRequest: function (i)
    {
        var self = this;
        var req = this._requests[i];
        var reqStatus = -1;

        try {
            if (req.xhr.readyState == 4) {
                reqStatus = req.xhr.status;
            }
        } catch (e) {
            Strophe.error("caught an error in _requests[" + i +
            "], reqStatus: " + reqStatus);
        }

        if (typeof(reqStatus) == "undefined") {
            reqStatus = -1;
        }

        // make sure we limit the number of retries
        if (req.sends > this.maxRetries) {
            this._onDisconnectTimeout();
            return;
        }

        var time_elapsed = req.age();
        var primaryTimeout = (!isNaN(time_elapsed) &&
        time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
        var secondaryTimeout = (req.dead !== null &&
        req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
        var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
        (reqStatus < 1 ||
        reqStatus >= 500));
        if (primaryTimeout || secondaryTimeout ||
                requestCompletedWithServerError) {
            if (secondaryTimeout) {
                Strophe.error("Request " +
                this._requests[i].id +
                " timed out (secondary), restarting");
            }
            req.abort = true;
            req.xhr.abort();
            // setting to null fails on IE6, so set to empty function
            req.xhr.onreadystatechange = function () {};
            this._requests[i] = new Strophe.Request(req.xmlData,
                    req.origFunc,
                    req.rid,
                    req.sends);
            req = this._requests[i];
        }

        if (req.xhr.readyState === 0) {
            Strophe.debug("request id " + req.id +
            "." + req.sends + " posting");

            try {
                req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
            } catch (e2) {
                Strophe.error("XHR open failed.");
                if (!this._conn.connected) {
                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL,
                            "bad-service");
                }
                this._conn.disconnect();
                return;
            }

            // Fires the XHR request -- may be invoked immediately
            // or on a gradually expanding retry window for reconnects
            var sendFunc = function () {
                req.date = new Date();
                if (self._conn.options.customHeaders){
                    var headers = self._conn.options.customHeaders;
                    for (var header in headers) {
                        if (headers.hasOwnProperty(header)) {
                            req.xhr.setRequestHeader(header, headers[header]);
                        }
                    }
                }
                req.xhr.send(req.data);
            };

            // Implement progressive backoff for reconnects --
            // First retry (send == 1) should also be instantaneous
            if (req.sends > 1) {
                // Using a cube of the retry number creates a nicely
                // expanding retry window
                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                Math.pow(req.sends, 3)) * 1000;
                setTimeout(sendFunc, backoff);
            } else {
                sendFunc();
            }

            req.sends++;

            if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                    this._conn.xmlOutput(req.xmlData.childNodes[0]);
                } else {
                    this._conn.xmlOutput(req.xmlData);
                }
            }
            if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                this._conn.rawOutput(req.data);
            }
        } else {
            Strophe.debug("_processRequest: " +
            (i === 0 ? "first" : "second") +
            " request has readyState of " +
            req.xhr.readyState);
        }
    },

    /** PrivateFunction: _removeRequest
     *  _Private_ function to remove a request from the queue.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request to remove.
     */
    _removeRequest: function (req)
    {
        Strophe.debug("removing request");

        var i;
        for (i = this._requests.length - 1; i >= 0; i--) {
            if (req == this._requests[i]) {
                this._requests.splice(i, 1);
            }
        }

        // IE6 fails on setting to null, so set to empty function
        req.xhr.onreadystatechange = function () {};

        this._throttledRequestHandler();
    },

    /** PrivateFunction: _restartRequest
     *  _Private_ function to restart a request that is presumed dead.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _restartRequest: function (i)
    {
        var req = this._requests[i];
        if (req.dead === null) {
            req.dead = new Date();
        }

        this._processRequest(i);
    },

    /** PrivateFunction: _reqToData
     * _Private_ function to get a stanza out of a request.
     *
     * Tries to extract a stanza out of a Request Object.
     * When this fails the current connection will be disconnected.
     *
     *  Parameters:
     *    (Object) req - The Request.
     *
     *  Returns:
     *    The stanza that was passed.
     */
    _reqToData: function (req)
    {
        try {
            return req.getResponse();
        } catch (e) {
            if (e != "parsererror") { throw e; }
            this._conn.disconnect("strophe-parsererror");
        }
    },

    /** PrivateFunction: _sendTerminate
     *  _Private_ function to send initial disconnect sequence.
     *
     *  This is the first step in a graceful disconnect.  It sends
     *  the BOSH server a terminate body and includes an unavailable
     *  presence if authentication has completed.
     */
    _sendTerminate: function (pres)
    {
        Strophe.info("_sendTerminate was called");
        var body = this._buildBody().attrs({type: "terminate"});

        if (pres) {
            body.cnode(pres.tree());
        }

        var req = new Strophe.Request(body.tree(),
                this._onRequestStateChange.bind(
                        this, this._conn._dataRecv.bind(this._conn)),
                body.tree().getAttribute("rid"));

        this._requests.push(req);
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _send
     *  _Private_ part of the Connection.send function for BOSH
     *
     * Just triggers the RequestHandler to send the messages that are in the queue
     */
    _send: function () {
        clearTimeout(this._conn._idleTimeout);
        this._throttledRequestHandler();
        this._conn._idleTimeout = setTimeout(this._conn._onIdle.bind(this._conn), 100);
    },

    /** PrivateFunction: _sendRestart
     *
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function ()
    {
        this._throttledRequestHandler();
        clearTimeout(this._conn._idleTimeout);
    },

    /** PrivateFunction: _throttledRequestHandler
     *  _Private_ function to throttle requests to the connection window.
     *
     *  This function makes sure we don't send requests so fast that the
     *  request ids overflow the connection window in the case that one
     *  request died.
     */
    _throttledRequestHandler: function ()
    {
        if (!this._requests) {
            Strophe.debug("_throttledRequestHandler called with " +
            "undefined requests");
        } else {
            Strophe.debug("_throttledRequestHandler called with " +
            this._requests.length + " requests");
        }

        if (!this._requests || this._requests.length === 0) {
            return;
        }

        if (this._requests.length > 0) {
            this._processRequest(0);
        }

        if (this._requests.length > 1 &&
                Math.abs(this._requests[0].rid -
                this._requests[1].rid) < this.window) {
            this._processRequest(1);
        }
    }
};

/*
 This program is distributed under the terms of the MIT license.
 Please see the LICENSE file for details.

 Copyright 2006-2008, OGG, LLC
 */

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/*global document, window, clearTimeout, WebSocket,
 DOMParser, Strophe, $build */

/** Class: Strophe.WebSocket
 *  _Private_ helper class that handles WebSocket Connections
 *
 *  The Strophe.WebSocket class is used internally by Strophe.Connection
 *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.
 */

/** File: websocket.js
 *  A JavaScript library to enable XMPP over Websocket in Strophejs.
 *
 *  This file implements XMPP over WebSockets for Strophejs.
 *  If a Connection is established with a Websocket url (ws://...)
 *  Strophe will use WebSockets.
 *  For more information on XMPP-over WebSocket see this RFC draft:
 *  http://tools.ietf.org/html/draft-ietf-xmpp-websocket-00
 *
 *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)
 */

/** PrivateConstructor: Strophe.Websocket
 *  Create and initialize a Strophe.WebSocket object.
 *  Currently only sets the connection Object.
 *
 *  Parameters:
 *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.
 *
 *  Returns:
 *    A new Strophe.WebSocket object.
 */
Strophe.Websocket = function(connection) {
    this._conn = connection;
    this.strip = "stream:stream";

    var service = connection.service;
    if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
        // If the service is not an absolute URL, assume it is a path and put the absolute
        // URL together from options, current URL and the path.
        var new_service = "";

        if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
            new_service += "ws";
        } else {
            new_service += "wss";
        }

        new_service += "://" + window.location.host;

        if (service.indexOf("/") !== 0) {
            new_service += window.location.pathname + service;
        } else {
            new_service += service;
        }

        connection.service = new_service;
    }
};

Strophe.Websocket.prototype = {
    /** PrivateFunction: _buildStream
     *  _Private_ helper function to generate the <stream> start tag for WebSockets
     *
     *  Returns:
     *    A Strophe.Builder with a <stream> element.
     */
    _buildStream: function ()
    {
        return $build("stream:stream", {
            "to": this._conn.domain,
            "xmlns": Strophe.NS.CLIENT,
            "xmlns:stream": Strophe.NS.STREAM,
            "version": '1.0'
        });
    },

    /** PrivateFunction: _check_streamerror
     * _Private_ checks a message for stream:error
     *
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     *    connectstatus - The ConnectStatus that will be set on error.
     *  Returns:
     *     true if there was a streamerror, false otherwise.
     */
    _check_streamerror: function (bodyWrap, connectstatus) {
        var errors = bodyWrap.getElementsByTagName("stream:error");
        if (errors.length === 0) {
            return false;
        }
        var error = errors[0];

        var condition = "";
        var text = "";

        var ns = "urn:ietf:params:xml:ns:xmpp-streams";
        for (var i = 0; i < error.childNodes.length; i++) {
            var e = error.childNodes[i];
            if (e.getAttribute("xmlns") !== ns) {
                break;
            } if (e.nodeName === "text") {
                text = e.textContent;
            } else {
                condition = e.nodeName;
            }
        }

        var errorString = "WebSocket stream error: ";

        if (condition) {
            errorString += condition;
        } else {
            errorString += "unknown";
        }

        if (text) {
            errorString += " - " + condition;
        }

        Strophe.error(errorString);

        // close the connection on stream_error
        this._conn._changeConnectStatus(connectstatus, condition);
        this._conn._doDisconnect();
        return true;
    },

    /** PrivateFunction: _reset
     *  Reset the connection.
     *
     *  This function is called by the reset function of the Strophe Connection.
     *  Is not needed by WebSockets.
     */
    _reset: function ()
    {
        return;
    },

    /** PrivateFunction: _connect
     *  _Private_ function called by Strophe.Connection.connect
     *
     *  Creates a WebSocket for a connection and assigns Callbacks to it.
     *  Does nothing if there already is a WebSocket.
     */
    _connect: function () {
        // Ensure that there is no open WebSocket from a previous Connection.
        this._closeSocket();

        // Create the new WobSocket
        this.socket = new WebSocket(this._conn.service, "xmpp");
        this.socket.onopen = this._onOpen.bind(this);
        this.socket.onerror = this._onError.bind(this);
        this.socket.onclose = this._onClose.bind(this);
        this.socket.onmessage = this._connect_cb_wrapper.bind(this);
    },

    /** PrivateFunction: _connect_cb
     *  _Private_ function called by Strophe.Connection._connect_cb
     *
     * checks for stream:error
     *
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     */
    _connect_cb: function(bodyWrap) {
        var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
        if (error) {
            return Strophe.Status.CONNFAIL;
        }
    },

    /** PrivateFunction: _handleStreamStart
     * _Private_ function that checks the opening stream:stream tag for errors.
     *
     * Disconnects if there is an error and returns false, true otherwise.
     *
     *  Parameters:
     *    (Node) message - Stanza containing the stream:stream.
     */
    _handleStreamStart: function(message) {
        var error = false;
        // Check for errors in the stream:stream tag
        var ns = message.getAttribute("xmlns");
        if (typeof ns !== "string") {
            error = "Missing xmlns in stream:stream";
        } else if (ns !== Strophe.NS.CLIENT) {
            error = "Wrong xmlns in stream:stream: " + ns;
        }

        var ns_stream = message.namespaceURI;
        if (typeof ns_stream !== "string") {
            error = "Missing xmlns:stream in stream:stream";
        } else if (ns_stream !== Strophe.NS.STREAM) {
            error = "Wrong xmlns:stream in stream:stream: " + ns_stream;
        }

        var ver = message.getAttribute("version");
        if (typeof ver !== "string") {
            error = "Missing version in stream:stream";
        } else if (ver !== "1.0") {
            error = "Wrong version in stream:stream: " + ver;
        }

        if (error) {
            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
            this._conn._doDisconnect();
            return false;
        }

        return true;
    },

    /** PrivateFunction: _connect_cb_wrapper
     * _Private_ function that handles the first connection messages.
     *
     * On receiving an opening stream tag this callback replaces itself with the real
     * message handler. On receiving a stream error the connection is terminated.
     */
    _connect_cb_wrapper: function(message) {
        if (message.data.indexOf("<stream:stream ") === 0 || message.data.indexOf("<?xml") === 0) {
            // Strip the XML Declaration, if there is one
            var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
            if (data === '') return;

            //Make the initial stream:stream selfclosing to parse it without a SAX parser.
            data = message.data.replace(/<stream:stream (.*[^\/])>/, "<stream:stream $1/>");

            var streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
            this._conn.xmlInput(streamStart);
            this._conn.rawInput(message.data);

            //_handleStreamSteart will check for XML errors and disconnect on error
            if (this._handleStreamStart(streamStart)) {

                //_connect_cb will check for stream:error and disconnect on error
                this._connect_cb(streamStart);

                // ensure received stream:stream is NOT selfclosing and save it for following messages
                this.streamStart = message.data.replace(/^<stream:(.*)\/>$/, "<stream:$1>");
            }
        } else if (message.data === "</stream:stream>") {
            this._conn.rawInput(message.data);
            this._conn.xmlInput(document.createElement("stream:stream"));
            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
            this._conn._doDisconnect();
            return;
        } else {
            var string = this._streamWrap(message.data);
            var elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
            this.socket.onmessage = this._onMessage.bind(this);
            this._conn._connect_cb(elem, null, message.data);
        }
    },

    /** PrivateFunction: _disconnect
     *  _Private_ function called by Strophe.Connection.disconnect
     *
     *  Disconnects and sends a last stanza if one is given
     *
     *  Parameters:
     *    (Request) pres - This stanza will be sent before disconnecting.
     */
    _disconnect: function (pres)
    {
        if (this.socket.readyState !== WebSocket.CLOSED) {
            if (pres) {
                this._conn.send(pres);
            }
            var close = '</stream:stream>';
            this._conn.xmlOutput(document.createElement("stream:stream"));
            this._conn.rawOutput(close);
            try {
                this.socket.send(close);
            } catch (e) {
                Strophe.info("Couldn't send closing stream tag.");
            }
        }

        this._conn._doDisconnect();
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  Just closes the Socket for WebSockets
     */
    _doDisconnect: function ()
    {
        Strophe.info("WebSockets _doDisconnect was called");
        this._closeSocket();
    },

    /** PrivateFunction _streamWrap
     *  _Private_ helper function to wrap a stanza in a <stream> tag.
     *  This is used so Strophe can process stanzas from WebSockets like BOSH
     */
    _streamWrap: function (stanza)
    {
        return this.streamStart + stanza + '</stream:stream>';
    },


    /** PrivateFunction: _closeSocket
     *  _Private_ function to close the WebSocket.
     *
     *  Closes the socket if it is still open and deletes it
     */
    _closeSocket: function ()
    {
        if (this.socket) { try {
            this.socket.close();
        } catch (e) {} }
        this.socket = null;
    },

    /** PrivateFunction: _emptyQueue
     * _Private_ function to check if the message queue is empty.
     *
     *  Returns:
     *    True, because WebSocket messages are send immediately after queueing.
     */
    _emptyQueue: function ()
    {
        return true;
    },

    /** PrivateFunction: _onClose
     * _Private_ function to handle websockets closing.
     *
     * Nothing to do here for WebSockets
     */
    _onClose: function() {
        if(this._conn.connected && !this._conn.disconnecting) {
            Strophe.error("Websocket closed unexcectedly");
            this._conn._doDisconnect();
        } else {
            Strophe.info("Websocket closed");
        }
    },

    /** PrivateFunction: _no_auth_received
     *
     * Called on stream start/restart when no stream:features
     * has been received.
     */
    _no_auth_received: function (_callback)
    {
        Strophe.error("Server did not send any auth methods");
        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
        if (_callback) {
            _callback = _callback.bind(this._conn);
            _callback();
        }
        this._conn._doDisconnect();
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  This does nothing for WebSockets
     */
    _onDisconnectTimeout: function () {},

    /** PrivateFunction: _onError
     * _Private_ function to handle websockets errors.
     *
     * Parameters:
     * (Object) error - The websocket error.
     */
    _onError: function(error) {
        Strophe.error("Websocket error " + error);
        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established was disconnected.");
        this._disconnect();
    },

    /** PrivateFunction: _onIdle
     *  _Private_ function called by Strophe.Connection._onIdle
     *
     *  sends all queued stanzas
     */
    _onIdle: function () {
        var data = this._conn._data;
        if (data.length > 0 && !this._conn.paused) {
            for (var i = 0; i < data.length; i++) {
                if (data[i] !== null) {
                    var stanza, rawStanza;
                    if (data[i] === "restart") {
                        stanza = this._buildStream();
                        rawStanza = this._removeClosingTag(stanza);
                        stanza = stanza.tree();
                    } else {
                        stanza = data[i];
                        rawStanza = Strophe.serialize(stanza);
                    }
                    this._conn.xmlOutput(stanza);
                    this._conn.rawOutput(rawStanza);
                    this.socket.send(rawStanza);
                }
            }
            this._conn._data = [];
        }
    },

    /** PrivateFunction: _onMessage
     * _Private_ function to handle websockets messages.
     *
     * This function parses each of the messages as if they are full documents. [TODO : We may actually want to use a SAX Push parser].
     *
     * Since all XMPP traffic starts with "<stream:stream version='1.0' xml:lang='en' xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' id='3697395463' from='SERVER'>"
     * The first stanza will always fail to be parsed...
     * Addtionnaly, the seconds stanza will always be a <stream:features> with the stream NS defined in the previous stanza... so we need to 'force' the inclusion of the NS in this stanza!
     *
     * Parameters:
     * (string) message - The websocket message.
     */
    _onMessage: function(message) {
        var elem, data;
        // check for closing stream
        if (message.data === "</stream:stream>") {
            var close = "</stream:stream>";
            this._conn.rawInput(close);
            this._conn.xmlInput(document.createElement("stream:stream"));
            if (!this._conn.disconnecting) {
                this._conn._doDisconnect();
            }
            return;
        } else if (message.data.search("<stream:stream ") === 0) {
            //Make the initial stream:stream selfclosing to parse it without a SAX parser.
            data = message.data.replace(/<stream:stream (.*[^\/])>/, "<stream:stream $1/>");
            elem = new DOMParser().parseFromString(data, "text/xml").documentElement;

            if (!this._handleStreamStart(elem)) {
                return;
            }
        } else {
            data = this._streamWrap(message.data);
            elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
        }

        if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
            return;
        }

        //handle unavailable presence stanza before disconnecting
        if (this._conn.disconnecting &&
                elem.firstChild.nodeName === "presence" &&
                elem.firstChild.getAttribute("type") === "unavailable") {
            this._conn.xmlInput(elem);
            this._conn.rawInput(Strophe.serialize(elem));
            // if we are already disconnecting we will ignore the unavailable stanza and
            // wait for the </stream:stream> tag before we close the connection
            return;
        }
        this._conn._dataRecv(elem, message.data);
    },

    /** PrivateFunction: _onOpen
     * _Private_ function to handle websockets connection setup.
     *
     * The opening stream tag is sent here.
     */
    _onOpen: function() {
        Strophe.info("Websocket open");
        var start = this._buildStream();
        this._conn.xmlOutput(start.tree());

        var startString = this._removeClosingTag(start);
        this._conn.rawOutput(startString);
        this.socket.send(startString);
    },

    /** PrivateFunction: _removeClosingTag
     *  _Private_ function to Make the first <stream:stream> non-selfclosing
     *
     *  Parameters:
     *      (Object) elem - The <stream:stream> tag.
     *
     *  Returns:
     *      The stream:stream tag as String
     */
    _removeClosingTag: function(elem) {
        var string = Strophe.serialize(elem);
        string = string.replace(/<(stream:stream .*[^\/])\/>$/, "<$1>");
        return string;
    },

    /** PrivateFunction: _reqToData
     * _Private_ function to get a stanza out of a request.
     *
     * WebSockets don't use requests, so the passed argument is just returned.
     *
     *  Parameters:
     *    (Object) stanza - The stanza.
     *
     *  Returns:
     *    The stanza that was passed.
     */
    _reqToData: function (stanza)
    {
        return stanza;
    },

    /** PrivateFunction: _send
     *  _Private_ part of the Connection.send function for WebSocket
     *
     * Just flushes the messages that are in the queue
     */
    _send: function () {
        this._conn.flush();
    },

    /** PrivateFunction: _sendRestart
     *
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function ()
    {
        clearTimeout(this._conn._idleTimeout);
        this._conn._onIdle.bind(this._conn)();
    }
};

// Generated by CoffeeScript 1.7.1

/*
 *Plugin to implement the MUC extension.
 http://xmpp.org/extensions/xep-0045.html
 *Previous Author:
 Nathan Zorn <nathan.zorn@gmail.com>
 *Complete CoffeeScript rewrite:
 Andreas Guth <guth@dbis.rwth-aachen.de>
 */

(function() {
    var Occupant, RoomConfig, XmppRoom,
            __hasProp = {}.hasOwnProperty,
            __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

    Strophe.addConnectionPlugin('muc', {
        _connection: null,
        rooms: {},
        roomNames: [],

        /*Function
         Initialize the MUC plugin. Sets the correct connection object and
         extends the namesace.
         */
        init: function(conn) {
            this._connection = conn;
            this._muc_handler = null;
            Strophe.addNamespace('MUC_OWNER', Strophe.NS.MUC + "#owner");
            Strophe.addNamespace('MUC_ADMIN', Strophe.NS.MUC + "#admin");
            Strophe.addNamespace('MUC_USER', Strophe.NS.MUC + "#user");
            Strophe.addNamespace('MUC_ROOMCONF', Strophe.NS.MUC + "#roomconfig");
            return Strophe.addNamespace('MUC_REGISTER', "jabber:iq:register");
        },

        /*Function
         Join a multi-user chat room
         Parameters:
         (String) room - The multi-user chat room to join.
         (String) nick - The nickname to use in the chat room. Optional
         (Function) msg_handler_cb - The function call to handle messages from the
         specified chat room.
         (Function) pres_handler_cb - The function call back to handle presence
         in the chat room.
         (Function) roster_cb - The function call to handle roster info in the chat room
         (String) password - The optional password to use. (password protected
         rooms only)
         (Object) history_attrs - Optional attributes for retrieving history
         (XML DOM Element) extended_presence - Optional XML for extending presence
         */
        join: function(room, nick, msg_handler_cb, pres_handler_cb, roster_cb, password, history_attrs) {
            var msg, room_nick;
            room_nick = this.test_append_nick(room, nick);
            msg = $pres({
                from: this._connection.jid,
                to: room_nick
            }).c("x", {
                xmlns: Strophe.NS.MUC
            });
            if (history_attrs != null) {
                msg = msg.c("history", history_attrs).up();
            }
            if (password != null) {
                msg.cnode(Strophe.xmlElement("password", [], password));
            }
            if (typeof extended_presence !== "undefined" && extended_presence !== null) {
                msg.up.cnode(extended_presence);
            }
            if (this._muc_handler == null) {
                this._muc_handler = this._connection.addHandler((function(_this) {
                    return function(stanza) {
                        var from, handler, handlers, id, roomname, x, xmlns, xquery, _i, _len;
                        from = stanza.getAttribute('from');
                        if (!from) {
                            return true;
                        }
                        roomname = from.split("/")[0];
                        if (!_this.rooms[roomname]) {
                            return true;
                        }
                        room = _this.rooms[roomname];
                        handlers = {};
                        if (stanza.nodeName === "message") {
                            handlers = room._message_handlers;
                        } else if (stanza.nodeName === "presence") {
                            xquery = stanza.getElementsByTagName("x");
                            if (xquery.length > 0) {
                                for (_i = 0, _len = xquery.length; _i < _len; _i++) {
                                    x = xquery[_i];
                                    xmlns = x.getAttribute("xmlns");
                                    if (xmlns && xmlns.match(Strophe.NS.MUC)) {
                                        handlers = room._presence_handlers;
                                        break;
                                    }
                                }
                            }
                        }
                        for (id in handlers) {
                            handler = handlers[id];
                            if (!handler(stanza, room)) {
                                delete handlers[id];
                            }
                        }
                        return true;
                    };
                })(this));
            }
            if (!this.rooms.hasOwnProperty(room)) {
                this.rooms[room] = new XmppRoom(this, room, nick, password);
                this.roomNames.push(room);
            }
            if (pres_handler_cb) {
                this.rooms[room].addHandler('presence', pres_handler_cb);
            }
            if (msg_handler_cb) {
                this.rooms[room].addHandler('message', msg_handler_cb);
            }
            if (roster_cb) {
                this.rooms[room].addHandler('roster', roster_cb);
            }
            return this._connection.send(msg);
        },

        /*Function
         Leave a multi-user chat room
         Parameters:
         (String) room - The multi-user chat room to leave.
         (String) nick - The nick name used in the room.
         (Function) handler_cb - Optional function to handle the successful leave.
         (String) exit_msg - optional exit message.
         Returns:
         iqid - The unique id for the room leave.
         */
        leave: function(room, nick, handler_cb, exit_msg) {
            var id, presence, presenceid, room_nick;
            id = this.roomNames.indexOf(room);
            delete this.rooms[room];
            if (id >= 0) {
                this.roomNames.splice(id, 1);
                if (this.roomNames.length === 0) {
                    this._connection.deleteHandler(this._muc_handler);
                    this._muc_handler = null;
                }
            }
            room_nick = this.test_append_nick(room, nick);
            presenceid = this._connection.getUniqueId();
            presence = $pres({
                type: "unavailable",
                id: presenceid,
                from: this._connection.jid,
                to: room_nick
            });
            if (exit_msg != null) {
                presence.c("status", exit_msg);
            }
            if (handler_cb != null) {
                this._connection.addHandler(handler_cb, null, "presence", null, presenceid);
            }
            this._connection.send(presence);
            return presenceid;
        },

        /*Function
         Parameters:
         (String) room - The multi-user chat room name.
         (String) nick - The nick name used in the chat room.
         (String) message - The plaintext message to send to the room.
         (String) html_message - The message to send to the room with html markup.
         (String) type - "groupchat" for group chat messages o
         "chat" for private chat messages
         Returns:
         msgiq - the unique id used to send the message
         */
        message: function(room, nick, message, html_message, type) {
            var msg, msgid, parent, room_nick;
            room_nick = this.test_append_nick(room, nick);
            type = type || (nick != null ? "chat" : "groupchat");
            msgid = this._connection.getUniqueId();
            msg = $msg({
                to: room_nick,
                from: this._connection.jid,
                type: type,
                id: msgid
            }).c("body", {
                xmlns: Strophe.NS.CLIENT
            }).t(message);
            msg.up();
            if (html_message != null) {
                msg.c("html", {
                    xmlns: Strophe.NS.XHTML_IM
                }).c("body", {
                    xmlns: Strophe.NS.XHTML
                }).h(html_message);
                if (msg.node.childNodes.length === 0) {
                    parent = msg.node.parentNode;
                    msg.up().up();
                    msg.node.removeChild(parent);
                } else {
                    msg.up().up();
                }
            }
            msg.c("x", {
                xmlns: "jabber:x:event"
            }).c("composing");
            this._connection.send(msg);
            return msgid;
        },

        /*Function
         Convenience Function to send a Message to all Occupants
         Parameters:
         (String) room - The multi-user chat room name.
         (String) message - The plaintext message to send to the room.
         (String) html_message - The message to send to the room with html markup.
         Returns:
         msgiq - the unique id used to send the message
         */
        groupchat: function(room, message, html_message) {
            return this.message(room, null, message, html_message);
        },

        /*Function
         Send a mediated invitation.
         Parameters:
         (String) room - The multi-user chat room name.
         (String) receiver - The invitation's receiver.
         (String) reason - Optional reason for joining the room.
         Returns:
         msgiq - the unique id used to send the invitation
         */
        invite: function(room, receiver, reason) {
            var invitation, msgid;
            msgid = this._connection.getUniqueId();
            invitation = $msg({
                from: this._connection.jid,
                to: room,
                id: msgid
            }).c('x', {
                xmlns: Strophe.NS.MUC_USER
            }).c('invite', {
                to: receiver
            });
            if (reason != null) {
                invitation.c('reason', reason);
            }
            this._connection.send(invitation);
            return msgid;
        },

        /*Function
         Send a mediated multiple invitation.
         Parameters:
         (String) room - The multi-user chat room name.
         (Array) receivers - The invitation's receivers.
         (String) reason - Optional reason for joining the room.
         Returns:
         msgiq - the unique id used to send the invitation
         */
        multipleInvites: function(room, receivers, reason) {
            var invitation, msgid, receiver, _i, _len;
            msgid = this._connection.getUniqueId();
            invitation = $msg({
                from: this._connection.jid,
                to: room,
                id: msgid
            }).c('x', {
                xmlns: Strophe.NS.MUC_USER
            });
            for (_i = 0, _len = receivers.length; _i < _len; _i++) {
                receiver = receivers[_i];
                invitation.c('invite', {
                    to: receiver
                });
                if (reason != null) {
                    invitation.c('reason', reason);
                    invitation.up();
                }
                invitation.up();
            }
            this._connection.send(invitation);
            return msgid;
        },

        /*Function
         Send a direct invitation.
         Parameters:
         (String) room - The multi-user chat room name.
         (String) receiver - The invitation's receiver.
         (String) reason - Optional reason for joining the room.
         (String) password - Optional password for the room.
         Returns:
         msgiq - the unique id used to send the invitation
         */
        directInvite: function(room, receiver, reason, password) {
            var attrs, invitation, msgid;
            msgid = this._connection.getUniqueId();
            attrs = {
                xmlns: 'jabber:x:conference',
                jid: room
            };
            if (reason != null) {
                attrs.reason = reason;
            }
            if (password != null) {
                attrs.password = password;
            }
            invitation = $msg({
                from: this._connection.jid,
                to: receiver,
                id: msgid
            }).c('x', attrs);
            this._connection.send(invitation);
            return msgid;
        },

        /*Function
         Queries a room for a list of occupants
         (String) room - The multi-user chat room name.
         (Function) success_cb - Optional function to handle the info.
         (Function) error_cb - Optional function to handle an error.
         Returns:
         id - the unique id used to send the info request
         */
        queryOccupants: function(room, success_cb, error_cb) {
            var attrs, info;
            attrs = {
                xmlns: Strophe.NS.DISCO_ITEMS
            };
            info = $iq({
                from: this._connection.jid,
                to: room,
                type: 'get'
            }).c('query', attrs);
            return this._connection.sendIQ(info, success_cb, error_cb);
        },

        /*Function
         Start a room configuration.
         Parameters:
         (String) room - The multi-user chat room name.
         (Function) handler_cb - Optional function to handle the config form.
         Returns:
         id - the unique id used to send the configuration request
         */
        configure: function(room, handler_cb, error_cb) {
            var config, stanza;
            config = $iq({
                to: room,
                type: "get"
            }).c("query", {
                xmlns: Strophe.NS.MUC_OWNER
            });
            stanza = config.tree();
            return this._connection.sendIQ(stanza, handler_cb, error_cb);
        },

        /*Function
         Cancel the room configuration
         Parameters:
         (String) room - The multi-user chat room name.
         Returns:
         id - the unique id used to cancel the configuration.
         */
        cancelConfigure: function(room) {
            var config, stanza;
            config = $iq({
                to: room,
                type: "set"
            }).c("query", {
                xmlns: Strophe.NS.MUC_OWNER
            }).c("x", {
                xmlns: "jabber:x:data",
                type: "cancel"
            });
            stanza = config.tree();
            return this._connection.sendIQ(stanza);
        },

        /*Function
         Save a room configuration.
         Parameters:
         (String) room - The multi-user chat room name.
         (Array) config- Form Object or an array of form elements used to configure the room.
         Returns:
         id - the unique id used to save the configuration.
         */
        saveConfiguration: function(room, config, success_cb, error_cb) {
            var conf, iq, stanza, _i, _len;
            iq = $iq({
                to: room,
                type: "set"
            }).c("query", {
                xmlns: Strophe.NS.MUC_OWNER
            });
            if (typeof Form !== "undefined" && config instanceof Form) {
                config.type = "submit";
                iq.cnode(config.toXML());
            } else {
                iq.c("x", {
                    xmlns: "jabber:x:data",
                    type: "submit"
                });
                for (_i = 0, _len = config.length; _i < _len; _i++) {
                    conf = config[_i];
                    iq.cnode(conf).up();
                }
            }
            stanza = iq.tree();
            return this._connection.sendIQ(stanza, success_cb, error_cb);
        },

        /*Function
         Parameters:
         (String) room - The multi-user chat room name.
         Returns:
         id - the unique id used to create the chat room.
         */
        createInstantRoom: function(room, success_cb, error_cb) {
            var roomiq;
            roomiq = $iq({
                to: room,
                type: "set"
            }).c("query", {
                xmlns: Strophe.NS.MUC_OWNER
            }).c("x", {
                xmlns: "jabber:x:data",
                type: "submit"
            });
            return this._connection.sendIQ(roomiq.tree(), success_cb, error_cb);
        },

        /*Function
         Parameters:
         (String) room - The multi-user chat room name.
         (Object) config - the configuration. ex: {"muc#roomconfig_publicroom": "0", "muc#roomconfig_persistentroom": "1"}
         Returns:
         id - the unique id used to create the chat room.
         */
        createConfiguredRoom: function(room, config, success_cb, error_cb) {
            var k, roomiq, v;
            roomiq = $iq({
                to: room,
                type: "set"
            }).c("query", {
                xmlns: Strophe.NS.MUC_OWNER
            }).c("x", {
                xmlns: "jabber:x:data",
                type: "submit"
            });
            roomiq.c('field', {
                'var': 'FORM_TYPE'
            }).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up();
            for (k in config) {
                if (!__hasProp.call(config, k)) continue;
                v = config[k];
                roomiq.c('field', {
                    'var': k
                }).c('value').t(v).up().up();
            }
            return this._connection.sendIQ(roomiq.tree(), success_cb, error_cb);
        },

        /*Function
         Set the topic of the chat room.
         Parameters:
         (String) room - The multi-user chat room name.
         (String) topic - Topic message.
         */
        setTopic: function(room, topic) {
            var msg;
            msg = $msg({
                to: room,
                from: this._connection.jid,
                type: "groupchat"
            }).c("subject", {
                xmlns: "jabber:client"
            }).t(topic);
            return this._connection.send(msg.tree());
        },

        /*Function
         Internal Function that Changes the role or affiliation of a member
         of a MUC room. This function is used by modifyRole and modifyAffiliation.
         The modification can only be done by a room moderator. An error will be
         returned if the user doesn't have permission.
         Parameters:
         (String) room - The multi-user chat room name.
         (Object) item - Object with nick and role or jid and affiliation attribute
         (String) reason - Optional reason for the change.
         (Function) handler_cb - Optional callback for success
         (Function) error_cb - Optional callback for error
         Returns:
         iq - the id of the mode change request.
         */
        _modifyPrivilege: function(room, item, reason, handler_cb, error_cb) {
            var iq;
            iq = $iq({
                to: room,
                type: "set"
            }).c("query", {
                xmlns: Strophe.NS.MUC_ADMIN
            }).cnode(item.node);
            if (reason != null) {
                iq.c("reason", reason);
            }
            return this._connection.sendIQ(iq.tree(), handler_cb, error_cb);
        },

        /*Function
         Changes the role of a member of a MUC room.
         The modification can only be done by a room moderator. An error will be
         returned if the user doesn't have permission.
         Parameters:
         (String) room - The multi-user chat room name.
         (String) nick - The nick name of the user to modify.
         (String) role - The new role of the user.
         (String) affiliation - The new affiliation of the user.
         (String) reason - Optional reason for the change.
         (Function) handler_cb - Optional callback for success
         (Function) error_cb - Optional callback for error
         Returns:
         iq - the id of the mode change request.
         */
        modifyRole: function(room, nick, role, reason, handler_cb, error_cb) {
            var item;
            item = $build("item", {
                nick: nick,
                role: role
            });
            return this._modifyPrivilege(room, item, reason, handler_cb, error_cb);
        },
        kick: function(room, nick, reason, handler_cb, error_cb) {
            return this.modifyRole(room, nick, 'none', reason, handler_cb, error_cb);
        },
        voice: function(room, nick, reason, handler_cb, error_cb) {
            return this.modifyRole(room, nick, 'participant', reason, handler_cb, error_cb);
        },
        mute: function(room, nick, reason, handler_cb, error_cb) {
            return this.modifyRole(room, nick, 'visitor', reason, handler_cb, error_cb);
        },
        op: function(room, nick, reason, handler_cb, error_cb) {
            return this.modifyRole(room, nick, 'moderator', reason, handler_cb, error_cb);
        },
        deop: function(room, nick, reason, handler_cb, error_cb) {
            return this.modifyRole(room, nick, 'participant', reason, handler_cb, error_cb);
        },

        /*Function
         Changes the affiliation of a member of a MUC room.
         The modification can only be done by a room moderator. An error will be
         returned if the user doesn't have permission.
         Parameters:
         (String) room - The multi-user chat room name.
         (String) jid  - The jid of the user to modify.
         (String) affiliation - The new affiliation of the user.
         (String) reason - Optional reason for the change.
         (Function) handler_cb - Optional callback for success
         (Function) error_cb - Optional callback for error
         Returns:
         iq - the id of the mode change request.
         */
        modifyAffiliation: function(room, jid, affiliation, reason, handler_cb, error_cb) {
            var item;
            item = $build("item", {
                jid: jid,
                affiliation: affiliation
            });
            return this._modifyPrivilege(room, item, reason, handler_cb, error_cb);
        },
        ban: function(room, jid, reason, handler_cb, error_cb) {
            return this.modifyAffiliation(room, jid, 'outcast', reason, handler_cb, error_cb);
        },
        member: function(room, jid, reason, handler_cb, error_cb) {
            return this.modifyAffiliation(room, jid, 'member', reason, handler_cb, error_cb);
        },
        revoke: function(room, jid, reason, handler_cb, error_cb) {
            return this.modifyAffiliation(room, jid, 'none', reason, handler_cb, error_cb);
        },
        owner: function(room, jid, reason, handler_cb, error_cb) {
            return this.modifyAffiliation(room, jid, 'owner', reason, handler_cb, error_cb);
        },
        admin: function(room, jid, reason, handler_cb, error_cb) {
            return this.modifyAffiliation(room, jid, 'admin', reason, handler_cb, error_cb);
        },

        /*Function
         Change the current users nick name.
         Parameters:
         (String) room - The multi-user chat room name.
         (String) user - The new nick name.
         */
        changeNick: function(room, user) {
            var presence, room_nick;
            room_nick = this.test_append_nick(room, user);
            presence = $pres({
                from: this._connection.jid,
                to: room_nick,
                id: this._connection.getUniqueId()
            });
            return this._connection.send(presence.tree());
        },

        /*Function
         Change the current users status.
         Parameters:
         (String) room - The multi-user chat room name.
         (String) user - The current nick.
         (String) show - The new show-text.
         (String) status - The new status-text.
         */
        setStatus: function(room, user, show, status) {
            var presence, room_nick;
            room_nick = this.test_append_nick(room, user);
            presence = $pres({
                from: this._connection.jid,
                to: room_nick
            });
            if (show != null) {
                presence.c('show', show).up();
            }
            if (status != null) {
                presence.c('status', status);
            }
            return this._connection.send(presence.tree());
        },

        /*Function
         Registering with a room.
         @see http://xmpp.org/extensions/xep-0045.html#register
         Parameters:
         (String) room - The multi-user chat room name.
         (Function) handle_cb - Function to call for room list return.
         (Function) error_cb - Function to call on error.
         */
        registrationRequest: function(room, handle_cb, error_cb) {
            var iq;
            iq = $iq({
                to: room,
                from: this._connection.jid,
                type: "get"
            }).c("query", {
                xmlns: Strophe.NS.MUC_REGISTER
            });
            return this._connection.sendIQ(iq, function(stanza) {
                var $field, $fields, field, fields, length, _i, _len;
                $fields = stanza.getElementsByTagName('field');
                length = $fields.length;
                fields = {
                    required: [],
                    optional: []
                };
                for (_i = 0, _len = $fields.length; _i < _len; _i++) {
                    $field = $fields[_i];
                    field = {
                        "var": $field.getAttribute('var'),
                        label: $field.getAttribute('label'),
                        type: $field.getAttribute('type')
                    };
                    if ($field.getElementsByTagName('required').length > 0) {
                        fields.required.push(field);
                    } else {
                        fields.optional.push(field);
                    }
                }
                return handle_cb(fields);
            }, error_cb);
        },

        /*Function
         Submits registration form.
         Parameters:
         (String) room - The multi-user chat room name.
         (Function) handle_cb - Function to call for room list return.
         (Function) error_cb - Function to call on error.
         */
        submitRegistrationForm: function(room, fields, handle_cb, error_cb) {
            var iq, key, val;
            iq = $iq({
                to: room,
                type: "set"
            }).c("query", {
                xmlns: Strophe.NS.MUC_REGISTER
            });
            iq.c("x", {
                xmlns: "jabber:x:data",
                type: "submit"
            });
            iq.c('field', {
                'var': 'FORM_TYPE'
            }).c('value').t('http://jabber.org/protocol/muc#register').up().up();
            for (key in fields) {
                val = fields[key];
                iq.c('field', {
                    'var': key
                }).c('value').t(val).up().up();
            }
            return this._connection.sendIQ(iq, handle_cb, error_cb);
        },

        /*Function
         List all chat room available on a server.
         Parameters:
         (String) server - name of chat server.
         (String) handle_cb - Function to call for room list return.
         (String) error_cb - Function to call on error.
         */
        listRooms: function(server, handle_cb, error_cb) {
            var iq;
            iq = $iq({
                to: server,
                from: this._connection.jid,
                type: "get"
            }).c("query", {
                xmlns: Strophe.NS.DISCO_ITEMS
            });
            return this._connection.sendIQ(iq, handle_cb, error_cb);
        },
        test_append_nick: function(room, nick) {
            var domain, node;
            node = Strophe.escapeNode(Strophe.getNodeFromJid(room));
            domain = Strophe.getDomainFromJid(room);
            return node + "@" + domain + (nick != null ? "/" + nick : "");
        }
    });

    XmppRoom = (function() {
        function XmppRoom(client, name, nick, password) {
            this.client = client;
            this.name = name;
            this.nick = nick;
            this.password = password;
            this._roomRosterHandler = __bind(this._roomRosterHandler, this);
            this._addOccupant = __bind(this._addOccupant, this);
            this.roster = {};
            this._message_handlers = {};
            this._presence_handlers = {};
            this._roster_handlers = {};
            this._handler_ids = 0;
            if (client.muc) {
                this.client = client.muc;
            }
            this.name = Strophe.getBareJidFromJid(name);
            this.addHandler('presence', this._roomRosterHandler);
        }

        XmppRoom.prototype.join = function(msg_handler_cb, pres_handler_cb, roster_cb) {
            return this.client.join(this.name, this.nick, msg_handler_cb, pres_handler_cb, roster_cb, this.password);
        };

        XmppRoom.prototype.leave = function(handler_cb, message) {
            this.client.leave(this.name, this.nick, handler_cb, message);
            return delete this.client.rooms[this.name];
        };

        XmppRoom.prototype.message = function(nick, message, html_message, type) {
            return this.client.message(this.name, nick, message, html_message, type);
        };

        XmppRoom.prototype.groupchat = function(message, html_message) {
            return this.client.groupchat(this.name, message, html_message);
        };

        XmppRoom.prototype.invite = function(receiver, reason) {
            return this.client.invite(this.name, receiver, reason);
        };

        XmppRoom.prototype.multipleInvites = function(receivers, reason) {
            return this.client.invite(this.name, receivers, reason);
        };

        XmppRoom.prototype.directInvite = function(receiver, reason) {
            return this.client.directInvite(this.name, receiver, reason, this.password);
        };

        XmppRoom.prototype.configure = function(handler_cb) {
            return this.client.configure(this.name, handler_cb);
        };

        XmppRoom.prototype.cancelConfigure = function() {
            return this.client.cancelConfigure(this.name);
        };

        XmppRoom.prototype.saveConfiguration = function(config) {
            return this.client.saveConfiguration(this.name, config);
        };

        XmppRoom.prototype.queryOccupants = function(success_cb, error_cb) {
            return this.client.queryOccupants(this.name, success_cb, error_cb);
        };

        XmppRoom.prototype.setTopic = function(topic) {
            return this.client.setTopic(this.name, topic);
        };

        XmppRoom.prototype.modifyRole = function(nick, role, reason, success_cb, error_cb) {
            return this.client.modifyRole(this.name, nick, role, reason, success_cb, error_cb);
        };

        XmppRoom.prototype.kick = function(nick, reason, handler_cb, error_cb) {
            return this.client.kick(this.name, nick, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.voice = function(nick, reason, handler_cb, error_cb) {
            return this.client.voice(this.name, nick, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.mute = function(nick, reason, handler_cb, error_cb) {
            return this.client.mute(this.name, nick, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.op = function(nick, reason, handler_cb, error_cb) {
            return this.client.op(this.name, nick, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.deop = function(nick, reason, handler_cb, error_cb) {
            return this.client.deop(this.name, nick, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.modifyAffiliation = function(jid, affiliation, reason, success_cb, error_cb) {
            return this.client.modifyAffiliation(this.name, jid, affiliation, reason, success_cb, error_cb);
        };

        XmppRoom.prototype.ban = function(jid, reason, handler_cb, error_cb) {
            return this.client.ban(this.name, jid, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.member = function(jid, reason, handler_cb, error_cb) {
            return this.client.member(this.name, jid, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.revoke = function(jid, reason, handler_cb, error_cb) {
            return this.client.revoke(this.name, jid, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.owner = function(jid, reason, handler_cb, error_cb) {
            return this.client.owner(this.name, jid, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.admin = function(jid, reason, handler_cb, error_cb) {
            return this.client.admin(this.name, jid, reason, handler_cb, error_cb);
        };

        XmppRoom.prototype.changeNick = function(nick) {
            this.nick = nick;
            return this.client.changeNick(this.name, nick);
        };

        XmppRoom.prototype.setStatus = function(show, status) {
            return this.client.setStatus(this.name, this.nick, show, status);
        };


        /*Function
         Adds a handler to the MUC room.
         Parameters:
         (String) handler_type - 'message', 'presence' or 'roster'.
         (Function) handler - The handler function.
         Returns:
         id - the id of handler.
         */

        XmppRoom.prototype.addHandler = function(handler_type, handler) {
            var id;
            id = this._handler_ids++;
            switch (handler_type) {
                case 'presence':
                    this._presence_handlers[id] = handler;
                    break;
                case 'message':
                    this._message_handlers[id] = handler;
                    break;
                case 'roster':
                    this._roster_handlers[id] = handler;
                    break;
                default:
                    this._handler_ids--;
                    return null;
            }
            return id;
        };


        /*Function
         Removes a handler from the MUC room.
         This function takes ONLY ids returned by the addHandler function
         of this room. passing handler ids returned by connection.addHandler
         may brake things!
         Parameters:
         (number) id - the id of the handler
         */

        XmppRoom.prototype.removeHandler = function(id) {
            delete this._presence_handlers[id];
            delete this._message_handlers[id];
            return delete this._roster_handlers[id];
        };


        /*Function
         Creates and adds an Occupant to the Room Roster.
         Parameters:
         (Object) data - the data the Occupant is filled with
         Returns:
         occ - the created Occupant.
         */

        XmppRoom.prototype._addOccupant = function(data) {
            var occ;
            occ = new Occupant(data, this);
            this.roster[occ.nick] = occ;
            return occ;
        };


        /*Function
         The standard handler that managed the Room Roster.
         Parameters:
         (Object) pres - the presence stanza containing user information
         */

        XmppRoom.prototype._roomRosterHandler = function(pres) {
            var data, handler, id, newnick, nick, _ref;
            data = XmppRoom._parsePresence(pres);
            nick = data.nick;
            newnick = data.newnick || null;
            switch (data.type) {
                case 'error':
                    return true;
                case 'unavailable':
                    if (newnick) {
                        data.nick = newnick;
                        if (this.roster[nick] && this.roster[newnick]) {
                            this.roster[nick].update(this.roster[newnick]);
                            this.roster[newnick] = this.roster[nick];
                        }
                        if (this.roster[nick] && !this.roster[newnick]) {
                            this.roster[newnick] = this.roster[nick].update(data);
                        }
                    }
                    delete this.roster[nick];
                    break;
                default:
                    if (this.roster[nick]) {
                        this.roster[nick].update(data);
                    } else {
                        this._addOccupant(data);
                    }
            }
            _ref = this._roster_handlers;
            for (id in _ref) {
                handler = _ref[id];
                if (!handler(this.roster, this)) {
                    delete this._roster_handlers[id];
                }
            }
            return true;
        };


        /*Function
         Parses a presence stanza
         Parameters:
         (Object) data - the data extracted from the presence stanza
         */

        XmppRoom._parsePresence = function(pres) {
            var c, c2, data, _i, _j, _len, _len1, _ref, _ref1;
            data = {};
            data.nick = Strophe.getResourceFromJid(pres.getAttribute("from"));
            data.type = pres.getAttribute("type");
            data.states = [];
            _ref = pres.childNodes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                c = _ref[_i];
                switch (c.nodeName) {
                    case "status":
                        data.status = c.textContent || null;
                        break;
                    case "show":
                        data.show = c.textContent || null;
                        break;
                    case "x":
                        if (c.getAttribute("xmlns") === Strophe.NS.MUC_USER) {
                            _ref1 = c.childNodes;
                            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                                c2 = _ref1[_j];
                                switch (c2.nodeName) {
                                    case "item":
                                        data.affiliation = c2.getAttribute("affiliation");
                                        data.role = c2.getAttribute("role");
                                        data.jid = c2.getAttribute("jid");
                                        data.newnick = c2.getAttribute("nick");
                                        break;
                                    case "status":
                                        if (c2.getAttribute("code")) {
                                            data.states.push(c2.getAttribute("code"));
                                        }
                                }
                            }
                        }
                }
            }
            return data;
        };

        return XmppRoom;

    })();

    RoomConfig = (function() {
        function RoomConfig(info) {
            this.parse = __bind(this.parse, this);
            if (info != null) {
                this.parse(info);
            }
        }

        RoomConfig.prototype.parse = function(result) {
            var attr, attrs, child, field, identity, query, _i, _j, _k, _len, _len1, _len2, _ref;
            query = result.getElementsByTagName("query")[0].childNodes;
            this.identities = [];
            this.features = [];
            this.x = [];
            for (_i = 0, _len = query.length; _i < _len; _i++) {
                child = query[_i];
                attrs = child.attributes;
                switch (child.nodeName) {
                    case "identity":
                        identity = {};
                        for (_j = 0, _len1 = attrs.length; _j < _len1; _j++) {
                            attr = attrs[_j];
                            identity[attr.name] = attr.textContent;
                        }
                        this.identities.push(identity);
                        break;
                    case "feature":
                        this.features.push(child.getAttribute("var"));
                        break;
                    case "x":
                        if ((!child.childNodes[0].getAttribute("var") === 'FORM_TYPE') || (!child.childNodes[0].getAttribute("type") === 'hidden')) {
                            break;
                        }
                        _ref = child.childNodes;
                        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                            field = _ref[_k];
                            if (!field.attributes.type) {
                                this.x.push({
                                    "var": field.getAttribute("var"),
                                    label: field.getAttribute("label") || "",
                                    value: field.firstChild.textContent || ""
                                });
                            }
                        }
                }
            }
            return {
                "identities": this.identities,
                "features": this.features,
                "x": this.x
            };
        };

        return RoomConfig;

    })();

    Occupant = (function() {
        function Occupant(data, room) {
            this.room = room;
            this.update = __bind(this.update, this);
            this.admin = __bind(this.admin, this);
            this.owner = __bind(this.owner, this);
            this.revoke = __bind(this.revoke, this);
            this.member = __bind(this.member, this);
            this.ban = __bind(this.ban, this);
            this.modifyAffiliation = __bind(this.modifyAffiliation, this);
            this.deop = __bind(this.deop, this);
            this.op = __bind(this.op, this);
            this.mute = __bind(this.mute, this);
            this.voice = __bind(this.voice, this);
            this.kick = __bind(this.kick, this);
            this.modifyRole = __bind(this.modifyRole, this);
            this.update(data);
        }

        Occupant.prototype.modifyRole = function(role, reason, success_cb, error_cb) {
            return this.room.modifyRole(this.nick, role, reason, success_cb, error_cb);
        };

        Occupant.prototype.kick = function(reason, handler_cb, error_cb) {
            return this.room.kick(this.nick, reason, handler_cb, error_cb);
        };

        Occupant.prototype.voice = function(reason, handler_cb, error_cb) {
            return this.room.voice(this.nick, reason, handler_cb, error_cb);
        };

        Occupant.prototype.mute = function(reason, handler_cb, error_cb) {
            return this.room.mute(this.nick, reason, handler_cb, error_cb);
        };

        Occupant.prototype.op = function(reason, handler_cb, error_cb) {
            return this.room.op(this.nick, reason, handler_cb, error_cb);
        };

        Occupant.prototype.deop = function(reason, handler_cb, error_cb) {
            return this.room.deop(this.nick, reason, handler_cb, error_cb);
        };

        Occupant.prototype.modifyAffiliation = function(affiliation, reason, success_cb, error_cb) {
            return this.room.modifyAffiliation(this.jid, affiliation, reason, success_cb, error_cb);
        };

        Occupant.prototype.ban = function(reason, handler_cb, error_cb) {
            return this.room.ban(this.jid, reason, handler_cb, error_cb);
        };

        Occupant.prototype.member = function(reason, handler_cb, error_cb) {
            return this.room.member(this.jid, reason, handler_cb, error_cb);
        };

        Occupant.prototype.revoke = function(reason, handler_cb, error_cb) {
            return this.room.revoke(this.jid, reason, handler_cb, error_cb);
        };

        Occupant.prototype.owner = function(reason, handler_cb, error_cb) {
            return this.room.owner(this.jid, reason, handler_cb, error_cb);
        };

        Occupant.prototype.admin = function(reason, handler_cb, error_cb) {
            return this.room.admin(this.jid, reason, handler_cb, error_cb);
        };

        Occupant.prototype.update = function(data) {
            this.nick = data.nick || null;
            this.affiliation = data.affiliation || null;
            this.role = data.role || null;
            this.jid = data.jid || null;
            this.status = data.status || null;
            this.show = data.show || null;
            return this;
        };

        return Occupant;

    })();

}).call(this);
/*! jQuery-Impromptu - v6.2.1 - 2015-05-10
* http://trentrichardson.com/Impromptu
* Copyright (c) 2015 Trent Richardson; Licensed MIT */
(function(root, factory) {
	if (typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	} else {
		factory(root.jQuery);
	}
}(this, function($) {
	'use strict';

	// ########################################################################
	// Base object
	// ########################################################################

	/**
	* Imp - Impromptu object - passing no params will not open, only return the instance
	* @param message String/Object - String of html or Object of states
	* @param options Object - Options to set the prompt
	* @return Imp - the instance of this Impromptu object
	*/
	var Imp = function(message, options){
		var t = this;
		t.id = Imp.count++;

		Imp.lifo.push(t);

		if(message){
			t.open(message, options);
		}
		return t;
	};

	// ########################################################################
	// static properties and methods
	// ########################################################################

	/**
	* defaults - the default options
	*/
	Imp.defaults = {
		prefix:'jqi',
		classes: {
			box: '',
			fade: '',
			prompt: '',
			form: '',
			close: '',
			title: '',
			message: '',
			buttons: '',
			button: '',
			defaultButton: ''
		},
		title: '',
		closeText: '&times;',
		buttons: {
			Ok: true
		},
		buttonTimeout: 1000,
		loaded: function(e){},
		submit: function(e,v,m,f){},
		close: function(e,v,m,f){},
		statechanging: function(e, from, to){},
		statechanged: function(e, to){},
		opacity: 0.6,
		zIndex: 999,
		overlayspeed: 'slow',
		promptspeed: 'fast',
		show: 'fadeIn',
		hide: 'fadeOut',
		focus: 0,
		defaultButton: 0,
		useiframe: false,
		top: '15%',
		position: {
			container: null,
			x: null,
			y: null,
			arrow: null,
			width: null
		},
		persistent: true,
		timeout: 0,
		states: {},
		initialState: 0,
		state: {
			name: null,
			title: '',
			html: '',
			buttons: {
				Ok: true
			},
			focus: 0,
			defaultButton: 0,
			position: {
				container: null,
				x: null,
				y: null,
				arrow: null,
				width: null
			},
			submit: function(e,v,m,f){
				return true;
			}
		}
	};

	/**
	* setDefaults - Sets the default options
	* @param o Object - Options to set as defaults
	* @return void
	*/
	Imp.setDefaults = function(o) {
		Imp.defaults = $.extend({}, Imp.defaults, o);
	};

	/**
	* setStateDefaults - Sets the default options for a state
	* @param o Object - Options to set as defaults
	* @return void
	*/
	Imp.setStateDefaults = function(o) {
		Imp.defaults.state = $.extend({}, Imp.defaults.state, o);
	};

	/**
	* @var Int - A counter used to provide a unique ID for new prompts
	*/
	Imp.count = 0;

	/**
	* @var Array - An array of Impromptu intances in a LIFO queue (last in first out)
	*/
	Imp.lifo = [];

	/**
	* getLast - get the last element from the queue (doesn't pop, just returns)
	* @return Imp - the instance of this Impromptu object or false if queue is empty
	*/
	Imp.getLast = function(){
		var l = Imp.lifo.length;
		return (l > 0)? Imp.lifo[l-1] : false;
	};

	/**
	* removeFromStack - remove an element from the lifo stack by its id
	* @param id int - id of the instance to remove
	* @return api - The api of the element removed from the stack or void
	*/
	Imp.removeFromStack = function(id){
		for(var i=Imp.lifo.length-1; i>=0; i--){
			if(Imp.lifo[i].id === id){
				return Imp.lifo.splice(i,1)[0];
			}
		}
	};

	// ########################################################################
	// extend our object instance properties and methods
	// ########################################################################
	Imp.prototype = {

		/**
		* @var Int - A unique id, simply an autoincremented number
		*/
		id: null,

		/**
		* open - Opens the prompt
		* @param message String/Object - String of html or Object of states
		* @param options Object - Options to set the prompt
		* @return Imp - the instance of this Impromptu object
		*/
		open: function(message, options) {
			var t = this;

			t.options = $.extend({},Imp.defaults,options);

			// Be sure any previous timeouts are destroyed
			if(t.timeout){
				clearTimeout(t.timeout);
			}
			t.timeout = false;

			var opts = t.options,
				$body = $(document.body),
				$window = $(window);

			//build the box and fade
			var msgbox = '<div class="'+ opts.prefix +'box '+ opts.classes.box +'">';
			if(opts.useiframe && ($('object, applet').length > 0)) {
				msgbox += '<iframe src="javascript:false;" class="'+ opts.prefix +'fade '+ opts.classes.fade +'"></iframe>';
			} else {
				msgbox += '<div class="'+ opts.prefix +'fade '+ opts.classes.fade +'"></div>';
			}
			msgbox += '<div class="'+ opts.prefix +' '+ opts.classes.prompt +'">'+
						'<form action="#" class="'+ opts.prefix +'form '+ opts.classes.form +'">'+
							'<div class="'+ opts.prefix +'close '+ opts.classes.close +'">'+ opts.closeText +'</div>'+
							'<div class="'+ opts.prefix +'states"></div>'+
						'</form>'+
					'</div>'+
				'</div>';

			t.jqib = $(msgbox).appendTo($body);
			t.jqi = t.jqib.children('.'+ opts.prefix);
			t.jqif = t.jqib.children('.'+ opts.prefix +'fade');

			//if a string was passed, convert to a single state
			if(message.constructor === String){
				message = {
					state0: {
						title: opts.title,
						html: message,
						buttons: opts.buttons,
						position: opts.position,
						focus: opts.focus,
						defaultButton: opts.defaultButton,
						submit: opts.submit
					}
				};
			}

			//build the states
			t.options.states = {};
			var k,v;
			for(k in message){
				v = $.extend({},Imp.defaults.state,{name:k},message[k]);
				t.addState(v.name, v);

				if(t.currentStateName === ''){
					t.currentStateName = v.name;
				}
			}

			//Events
			t.jqi.on('click', '.'+ opts.prefix +'buttons button', function(e){
				var $t = $(this),
					$state = $t.parents('.'+ opts.prefix +'state'),
					statename = $state.data('jqi-name'),
					stateobj = t.options.states[statename],
					msg = $state.children('.'+ opts.prefix +'message'),
					clicked = stateobj.buttons[$t.text()] || stateobj.buttons[$t.html()],
					forminputs = {};

				// disable for a moment to prevent multiple clicks
				if(t.options.buttonTimeout > 0){
					t.disableStateButtons(statename);
					setTimeout(function(){
						t.enableStateButtons(statename);
					}, t.options.buttonTimeout);
				}

				// if for some reason we couldn't get the value
				if(clicked === undefined){
					for(var i in stateobj.buttons){
						if(stateobj.buttons[i].title === $t.text() || stateobj.buttons[i].title === $t.html()){
							clicked = stateobj.buttons[i].value;
						}
					}
				}

				//collect all form element values from all states.
				$.each(t.jqi.children('form').serializeArray(),function(i,obj){
					if (forminputs[obj.name] === undefined) {
						forminputs[obj.name] = obj.value;
					} else if (typeof forminputs[obj.name] === Array || typeof forminputs[obj.name] === 'object') {
						forminputs[obj.name].push(obj.value);
					} else {
						forminputs[obj.name] = [forminputs[obj.name],obj.value];
					}
				});

				// trigger an event
				var promptsubmite = new $.Event('impromptu:submit');
				promptsubmite.stateName = stateobj.name;
				promptsubmite.state = $state;
				$state.trigger(promptsubmite, [clicked, msg, forminputs]);

				if(!promptsubmite.isDefaultPrevented()){
					t.close(true, clicked,msg,forminputs);
				}
			});

			// if the fade is clicked blink the prompt
			var fadeClicked = function(){
				if(opts.persistent){
					var offset = (opts.top.toString().indexOf('%') >= 0? ($window.height()*(parseInt(opts.top,10)/100)) : parseInt(opts.top,10)),
						top = parseInt(t.jqi.css('top').replace('px',''),10) - offset;

					//$window.scrollTop(top);
					$('html,body').animate({ scrollTop: top }, 'fast', function(){
						var i = 0;
						t.jqib.addClass(opts.prefix +'warning');
						var intervalid = setInterval(function(){
							t.jqib.toggleClass(opts.prefix +'warning');
							if(i++ > 1){
								clearInterval(intervalid);
								t.jqib.removeClass(opts.prefix +'warning');
							}
						}, 100);
					});
				}
				else {
					t.close(true);
				}
			};

			// listen for esc or tab keys
			var keyDownEventHandler = function(e){
				var key = (window.event) ? event.keyCode : e.keyCode;

				//escape key closes
				if(key === 27) {
					fadeClicked();
				}

				//enter key pressed trigger the default button if its not on it, ignore if it is a textarea
				if(key === 13){
					var $defBtn = t.getCurrentState().find('.'+ opts.prefix +'defaultbutton');
					var $tgt = $(e.target);

					if($tgt.is('textarea,.'+opts.prefix+'button') === false && $defBtn.length > 0){
						e.preventDefault();
						$defBtn.click();
					}
				}

				//constrain tabs, tabs should iterate through the state and not leave
				if (key === 9){
					var $inputels = $('input,select,textarea,button',t.getCurrentState());
					var fwd = !e.shiftKey && e.target === $inputels[$inputels.length-1];
					var back = e.shiftKey && e.target === $inputels[0];
					if (fwd || back) {
						setTimeout(function(){
							if (!$inputels){
								return;
							}
							var el = $inputels[back===true ? $inputels.length-1 : 0];

							if (el){
								el.focus();
							}
						},10);
						return false;
					}
				}
			};

			t.position();
			t.style();

			// store copy of the window resize function for interal use only
			t._windowResize = function(e){
				t.position(e);
			};
			$window.resize({ animate: false }, t._windowResize);

			t.jqif.click(fadeClicked);
			t.jqi.find('.'+ opts.prefix +'close').click(function(){ t.close(); });
			t.jqi.find('.'+ opts.prefix +'form').submit(function(){ return false; });
			t.jqib.on("keydown",keyDownEventHandler)
						.on('impromptu:loaded', opts.loaded)
						.on('impromptu:close', opts.close)
						.on('impromptu:statechanging', opts.statechanging)
						.on('impromptu:statechanged', opts.statechanged);

			// Show it
			t.jqif[opts.show](opts.overlayspeed);
			t.jqi[opts.show](opts.promptspeed, function(){

				t.goToState(
					isNaN(opts.initialState) ? opts.initialState : 
						t.jqi.find('.'+ opts.prefix +'states .'+ opts.prefix +'state').eq(opts.initialState).data('jqi-name')
				);

				t.jqib.trigger('impromptu:loaded');
			});

			// Timeout
			if(opts.timeout > 0){
				t.timeout = setTimeout(function(){ t.close(true); },opts.timeout);
			}

			return t;
		},

		/**
		* close - Closes the prompt
		* @param callback Function - called when the transition is complete
		* @param clicked String - value of the button clicked (only used internally)
		* @param msg jQuery - The state message body (only used internally)
		* @param forvals Object - key/value pairs of all form field names and values (only used internally)
		* @return Imp - the instance of this Impromptu object
		*/
		close: function(callCallback, clicked, msg, formvals){
			var t = this;
			Imp.removeFromStack(t.id);

			if(t.timeout){
				clearTimeout(t.timeout);
				t.timeout = false;
			}

			if(t.jqib){
				t.jqib[t.options.hide]('fast',function(){
					
					t.jqib.trigger('impromptu:close', [clicked,msg,formvals]);
					
					t.jqib.remove();
					
					$(window).off('resize', t._windowResize);

					if(typeof callCallback === 'function'){
						callCallback();
					}
				});
			}
			t.currentStateName = "";

			return t;
		},

		/**
		* addState - Injects a state into the prompt
		* @param statename String - Name of the state
		* @param stateobj Object - options for the state
		* @param afterState String - selector of the state to insert after
		* @return jQuery - the newly created state
		*/
		addState: function(statename, stateobj, afterState) {
			var t = this,
				state = '',
				$state = null,
				arrow = '',
				title = '',
				opts = t.options,
				$jqistates = t.jqi.find('.'+ opts.prefix +'states'),
				buttons = [],
				showHtml,defbtn,k,v,l,i=0;

			stateobj = $.extend({},Imp.defaults.state, {name:statename}, stateobj);

			if(stateobj.position.arrow !== null){
				arrow = '<div class="'+ opts.prefix + 'arrow '+ opts.prefix + 'arrow'+ stateobj.position.arrow +'"></div>';
			}
			if(stateobj.title && stateobj.title !== ''){
				title = '<div class="lead '+ opts.prefix + 'title '+ opts.classes.title +'">'+  stateobj.title +'</div>';
			}

			showHtml = stateobj.html;
			if (typeof stateobj.html === 'function') {
				showHtml = 'Error: html function must return text';
			}

			state += '<div class="'+ opts.prefix + 'state" data-jqi-name="'+ statename +'">'+
						arrow + title +
						'<div class="'+ opts.prefix +'message '+ opts.classes.message +'">' + showHtml +'</div>'+
						'<div class="'+ opts.prefix +'buttons'+ ($.isEmptyObject(stateobj.buttons)? 'hide ':' ') + opts.classes.buttons +'">';

			// state buttons may be in object or array, lets convert objects to arrays
			if($.isArray(stateobj.buttons)){
				buttons = stateobj.buttons;
			}
			else if($.isPlainObject(stateobj.buttons)){
				for(k in stateobj.buttons){
					if(stateobj.buttons.hasOwnProperty(k)){
						buttons.push({ title: k, value: stateobj.buttons[k] });
					}
				}
			}

			// iterate over each button and create them
			for(i=0, l=buttons.length; i<l; i++){
				v = buttons[i],
				defbtn = stateobj.focus === i || (isNaN(stateobj.focus) && stateobj.defaultButton === i) ? (opts.prefix + 'defaultbutton ' + opts.classes.defaultButton) : '';

				state += '<button class="'+ opts.classes.button +' '+ opts.prefix + 'button '+ defbtn;

				if(typeof v.classes !== "undefined"){
					state += ' '+ ($.isArray(v.classes)? v.classes.join(' ') : v.classes) + ' ';
				}

				state += '" name="' + opts.prefix + '_' + statename + '_button' + v.title.replace(/[^a-z0-9]+/gi,'') + '" value="' + v.value + '">' + v.title + '</button>';
			}
			
			state += '</div></div>';

			$state = $(state).css({display:'none'});

			$state.on('impromptu:submit', stateobj.submit);

			if(afterState !== undefined){
				t.getState(afterState).after($state);
			}
			else{
				$jqistates.append($state);
			}

			t.options.states[statename] = stateobj;

			return $state;
		},

		/**
		* removeState - Removes a state from the prompt
		* @param state String - Name of the state
		* @param newState String - Name of the state to transition to
		* @return Boolean - returns true on success, false on failure
		*/
		removeState: function(state, newState) {
			var t = this,
				$state = t.getState(state),
				rm = function(){ $state.remove(); };

			if($state.length === 0){
				return false;
			}

			// transition away from it before deleting
			if($state.css('display') !== 'none'){
				if(newState !== undefined && t.getState(newState).length > 0){
					t.goToState(newState, false, rm);
				}
				else if($state.next().length > 0){
					t.nextState(rm);
				}
				else if($state.prev().length > 0){
					t.prevState(rm);
				}
				else{
					t.close();
				}
			}
			else{
				$state.slideUp('slow', rm);
			}

			return true;
		},

		/**
		* getApi - Get the api, so you can extract it from $.prompt stack
		* @return jQuery - the prompt
		*/
		getApi: function() {
			return this;
		},

		/**
		* getBox - Get the box containing fade and prompt
		* @return jQuery - the prompt
		*/
		getBox: function() {
			return this.jqib;
		},

		/**
		* getPrompt - Get the prompt
		* @return jQuery - the prompt
		*/
		getPrompt: function() {
			return this.jqi;
		},

		/**
		* getState - Get the state by its name
		* @param statename String - Name of the state
		* @return jQuery - the state
		*/
		getState: function(statename) {
			return this.jqi.find('[data-jqi-name="'+ statename +'"]');
		},

		/**
		* getCurrentState - Get the current visible state
		* @return jQuery - the current visible state
		*/
		getCurrentState: function() {
			return this.getState(this.getCurrentStateName());
		},

		/**
		* getCurrentStateName - Get the name of the current visible state/substate
		* @return String - the current visible state's name
		*/
		getCurrentStateName: function() {
			return this.currentStateName;
		},

		/**
		* disableStateButtons - Disables the buttons in a state
		* @param statename String - Name of the state containing buttons
		* @param buttons Array - Array of button values to disable. By default all are disabled
		* @param enable Boolean - True to enable the buttons instead of disabling (internally use only)
		* @return Void
		*/
		disableStateButtons: function(statename, buttons, enable) {
			var t = this;

			if($.isArray(statename)){
				buttons = statename;
				statename = null;
			}
			
			t.getState(statename || t.getCurrentStateName()).find('.'+ t.options.prefix + 'button').each(function(i,btn){
				if(buttons === undefined || $.inArray(btn.value, buttons) !== -1){
					btn.disabled = !enable;
				}
			});
		},

		/**
		* enableStateButtons - Enables the buttons in a state
		* @param statename String - Name of the state containing buttons. Defaults to current state
		* @param buttons Array - Array of button values to enable. By default all are enabled
		* @return Void
		*/
		enableStateButtons: function(statename, buttons) {
			this.disableStateButtons(statename, buttons, true);
		},

		/**
		* position - Repositions the prompt (Used internally)
		* @return void
		*/
		position: function(e){
			var t = this,
				restoreFx = $.fx.off,
				$state = t.getCurrentState(),
				stateObj = t.options.states[$state.data('jqi-name')],
				pos = stateObj? stateObj.position : undefined,
				$window = $(window),
				bodyHeight = document.body.scrollHeight, //$(document.body).outerHeight(true),
				windowHeight = $(window).height(),
				documentHeight = $(document).height(),
				height = (bodyHeight > windowHeight) ? bodyHeight : windowHeight,
				scrollTop = parseInt($window.scrollTop(),10),
				top = scrollTop + (t.options.top.toString().indexOf('%') >= 0?
						(windowHeight*(parseInt(t.options.top,10)/100)) : parseInt(t.options.top,10));

			// when resizing the window turn off animation
			if(e !== undefined && e.data.animate === false){
				$.fx.off = true;
			}

			t.jqib.css({
				position: "absolute",
				height: height,
				width: "100%",
				top: 0,
				left: 0,
				right: 0,
				bottom: 0
			});
			t.jqif.css({
				position: "fixed",
				height: height,
				width: "100%",
				top: 0,
				left: 0,
				right: 0,
				bottom: 0
			});

			// tour positioning
			if(pos && pos.container){
				var offset = $(pos.container).offset(),
					hasScrolled = false;
					
				if($.isPlainObject(offset) && offset.top !== undefined){
					top = (offset.top + pos.y) - (t.options.top.toString().indexOf('%') >= 0? (windowHeight*(parseInt(t.options.top,10)/100)) : parseInt(t.options.top,10));

					t.jqi.css({
						position: "absolute"
					});
					t.jqi.animate({
						top: offset.top + pos.y,
						left: offset.left + pos.x,
						marginLeft: 0,
						width: (pos.width !== undefined)? pos.width : null
					}, function(){
						// if it didn't scroll before, check that the bottom is within view. Since width 
						// is animated we must use the callback before we know the height
						if(!hasScrolled && (offset.top + pos.y + t.jqi.outerHeight(true)) > (scrollTop + windowHeight)){
							$('html,body').animate({ scrollTop: top }, 'slow', 'swing', function(){});
							hasScrolled = true;
						}
					});

					// scroll if the top is out of the viewing area
					if(top < scrollTop || top > scrollTop + windowHeight){
						$('html,body').animate({ scrollTop: top }, 'slow', 'swing', function(){});
						hasScrolled = true;
					}
				}
			}
			// custom state width animation
			else if(pos && pos.width){
				t.jqi.css({
						position: "absolute",
						left: '50%'
					});
				t.jqi.animate({
						top: pos.y || top,
						left: pos.x || '50%',
						marginLeft: ((pos.width/2)*-1),
						width: pos.width
					});
			}
			// standard prompt positioning
			else{
				t.jqi.css({
					position: "absolute",
					top: top,
					left: '50%',//$window.width()/2,
					marginLeft: ((t.jqi.outerWidth(false)/2)*-1)
				});
			}

			// restore fx settings
			if(e !== undefined && e.data.animate === false){
				$.fx.off = restoreFx;
			}
		},

		/**
		* style - Restyles the prompt (Used internally)
		* @return void
		*/
		style: function(){
			var t = this;
			
			t.jqif.css({
				zIndex: t.options.zIndex,
				display: "none",
				opacity: t.options.opacity
			});
			t.jqi.css({
				zIndex: t.options.zIndex+1,
				display: "none"
			});
			t.jqib.css({
				zIndex: t.options.zIndex
			});
		},

		/**
		* goToState - Goto the specified state
		* @param state String - name of the state to transition to
		* @param subState Boolean - true to be a sub state within the currently open state
		* @param callback Function - called when the transition is complete
		* @return jQuery - the newly active state
		*/
		goToState: function(state, subState, callback) {
			var t = this,
				$jqi = t.jqi,
				jqiopts = t.options,
				$state = t.getState(state),
				stateobj = jqiopts.states[$state.data('jqi-name')],
				promptstatechanginge = new $.Event('impromptu:statechanging'),
				opts = t.options;

			if(stateobj !== undefined){


				if (typeof stateobj.html === 'function') {
					var contentLaterFunc = stateobj.html;
					$state.find('.' + opts.prefix +'message ').html(contentLaterFunc());
				}

				// subState can be ommitted
				if(typeof subState === 'function'){
					callback = subState;
					subState = false;
				}

				t.jqib.trigger(promptstatechanginge, [t.getCurrentStateName(), state]);

				if(!promptstatechanginge.isDefaultPrevented() && $state.length > 0){
					t.jqi.find('.'+ opts.prefix +'parentstate').removeClass(opts.prefix +'parentstate');

					if(subState){ // hide any open substates
						// get rid of any substates
						t.jqi.find('.'+ opts.prefix +'substate').not($state)
							.slideUp(jqiopts.promptspeed)
							.removeClass('.'+ opts.prefix +'substate')
							.find('.'+ opts.prefix +'arrow').hide();

						// add parent state class so it can be visible, but blocked
						t.jqi.find('.'+ opts.prefix +'state:visible').addClass(opts.prefix +'parentstate');

						// add substate class so we know it will be smaller
						$state.addClass(opts.prefix +'substate');
					}
					else{ // hide any open states
						t.jqi.find('.'+ opts.prefix +'state').not($state)
							.slideUp(jqiopts.promptspeed)
							.find('.'+ opts.prefix +'arrow').hide();
					}
					t.currentStateName = stateobj.name;

					$state.slideDown(jqiopts.promptspeed,function(){
						var $t = $(this);
						t.enableStateButtons();
						
						// if focus is a selector, find it, else its button index
						if(typeof(stateobj.focus) === 'string'){
							$t.find(stateobj.focus).eq(0).focus();
						}
						else{
							$t.find('.'+ opts.prefix +'defaultbutton').focus();
						}

						$t.find('.'+ opts.prefix +'arrow').show(jqiopts.promptspeed);

						if (typeof callback === 'function'){
							t.jqib.on('impromptu:statechanged', callback);
						}
						t.jqib.trigger('impromptu:statechanged', [state]);
						if (typeof callback === 'function'){
							t.jqib.off('impromptu:statechanged', callback);
						}
					});
					if(!subState){
						t.position();
					}
				} // end isDefaultPrevented()	
			}// end stateobj !== undefined

			return $state;
		},

		/**
		* nextState - Transition to the next state
		* @param callback Function - called when the transition is complete
		* @return jQuery - the newly active state
		*/
		nextState: function(callback) {
			var t = this,
				$next = t.getCurrentState().next();
			if($next.length > 0){
				t.goToState( $next.data('jqi-name'), callback );
			}
			return $next;
		},

		/**
		* prevState - Transition to the previous state
		* @param callback Function - called when the transition is complete
		* @return jQuery - the newly active state
		*/
		prevState: function(callback) {
			var t = this,
				$prev = t.getCurrentState().prev();
			if($prev.length > 0){
				t.goToState( $prev.data('jqi-name'), callback );
			}
			return $prev;
		}

	};

	// ########################################################################
	// $.prompt will manage a queue of Impromptu instances
	// ########################################################################

	/**
	* $.prompt create a new Impromptu instance and push it on the stack of instances
	* @param message String/Object - String of html or Object of states
	* @param options Object - Options to set the prompt
	* @return jQuery - the jQuery object of the prompt within the modal
	*/
	$.prompt = function(message, options){
		var api = new Imp(message, options);
		return api.jqi;
	};

	/**
	* Copy over static methods
	*/
	$.each(Imp, function(k,v){
		$.prompt[k] = v;
	});

	/**
	* Create a proxy for accessing all instance methods. The close method pops from queue.
	*/
	$.each(Imp.prototype, function(k,v){
		$.prompt[k] = function(){
			var api = Imp.getLast(); // always use the last instance on the stack

			if(api && typeof api[k] === "function"){
				return api[k].apply(api, arguments);
			}
		};
	});

	// ########################################################################
	// jQuery Plugin and public access
	// ########################################################################

	/**
	* Enable using $('.selector').prompt({});
	* This will grab the html within the prompt as the prompt message
	*/
	$.fn.prompt = function(options){
		if(options === undefined){
			options = {};
		}
		if(options.withDataAndEvents === undefined){
			options.withDataAndEvents = false;
		}

		$.prompt($(this).clone(options.withDataAndEvents).html(),options);
	};

	/**
	* Export it as Impromptu and $.prompt
	* Can be used from here forth as new Impromptu(states, opts)
	*/
	window.Impromptu = Imp;

}));

/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.12
 *
 * Requires: jQuery 1.2.2+
 */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):"object"==typeof exports?module.exports=a:a(jQuery)}(function(a){function b(b){var g=b||window.event,h=i.call(arguments,1),j=0,l=0,m=0,n=0,o=0,p=0;if(b=a.event.fix(g),b.type="mousewheel","detail"in g&&(m=-1*g.detail),"wheelDelta"in g&&(m=g.wheelDelta),"wheelDeltaY"in g&&(m=g.wheelDeltaY),"wheelDeltaX"in g&&(l=-1*g.wheelDeltaX),"axis"in g&&g.axis===g.HORIZONTAL_AXIS&&(l=-1*m,m=0),j=0===m?l:m,"deltaY"in g&&(m=-1*g.deltaY,j=m),"deltaX"in g&&(l=g.deltaX,0===m&&(j=-1*l)),0!==m||0!==l){if(1===g.deltaMode){var q=a.data(this,"mousewheel-line-height");j*=q,m*=q,l*=q}else if(2===g.deltaMode){var r=a.data(this,"mousewheel-page-height");j*=r,m*=r,l*=r}if(n=Math.max(Math.abs(m),Math.abs(l)),(!f||f>n)&&(f=n,d(g,n)&&(f/=40)),d(g,n)&&(j/=40,l/=40,m/=40),j=Math[j>=1?"floor":"ceil"](j/f),l=Math[l>=1?"floor":"ceil"](l/f),m=Math[m>=1?"floor":"ceil"](m/f),k.settings.normalizeOffset&&this.getBoundingClientRect){var s=this.getBoundingClientRect();o=b.clientX-s.left,p=b.clientY-s.top}return b.deltaX=l,b.deltaY=m,b.deltaFactor=f,b.offsetX=o,b.offsetY=p,b.deltaMode=0,h.unshift(b,j,l,m),e&&clearTimeout(e),e=setTimeout(c,200),(a.event.dispatch||a.event.handle).apply(this,h)}}function c(){f=null}function d(a,b){return k.settings.adjustOldDeltas&&"mousewheel"===a.type&&b%120===0}var e,f,g=["wheel","mousewheel","DOMMouseScroll","MozMousePixelScroll"],h="onwheel"in document||document.documentMode>=9?["wheel"]:["mousewheel","DomMouseScroll","MozMousePixelScroll"],i=Array.prototype.slice;if(a.event.fixHooks)for(var j=g.length;j;)a.event.fixHooks[g[--j]]=a.event.mouseHooks;var k=a.event.special.mousewheel={version:"3.1.12",setup:function(){if(this.addEventListener)for(var c=h.length;c;)this.addEventListener(h[--c],b,!1);else this.onmousewheel=b;a.data(this,"mousewheel-line-height",k.getLineHeight(this)),a.data(this,"mousewheel-page-height",k.getPageHeight(this))},teardown:function(){if(this.removeEventListener)for(var c=h.length;c;)this.removeEventListener(h[--c],b,!1);else this.onmousewheel=null;a.removeData(this,"mousewheel-line-height"),a.removeData(this,"mousewheel-page-height")},getLineHeight:function(b){var c=a(b),d=c["offsetParent"in a.fn?"offsetParent":"parent"]();return d.length||(d=a("body")),parseInt(d.css("fontSize"),10)||parseInt(c.css("fontSize"),10)||16},getPageHeight:function(b){return a(b).height()},settings:{adjustOldDeltas:!0,normalizeOffset:!0}};a.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})});
(function(factory){if(typeof define==="function"&&define.amd){define(["jquery"],factory)}else{factory(jQuery)}})(function($){"use strict";var k={},max=Math.max,min=Math.min;k.c={};k.c.d=$(document);k.c.t=function(e){return e.originalEvent.touches.length-1};k.o=function(){var s=this;this.o=null;this.$=null;this.i=null;this.g=null;this.v=null;this.cv=null;this.x=0;this.y=0;this.w=0;this.h=0;this.$c=null;this.c=null;this.t=0;this.isInit=false;this.fgColor=null;this.pColor=null;this.dH=null;this.cH=null;this.eH=null;this.rH=null;this.scale=1;this.relative=false;this.relativeWidth=false;this.relativeHeight=false;this.$div=null;this.run=function(){var cf=function(e,conf){var k;for(k in conf){s.o[k]=conf[k]}s._carve().init();s._configure()._draw()};if(this.$.data("kontroled"))return;this.$.data("kontroled",true);this.extend();this.o=$.extend({min:this.$.data("min")!==undefined?this.$.data("min"):0,max:this.$.data("max")!==undefined?this.$.data("max"):100,stopper:true,readOnly:this.$.data("readonly")||this.$.attr("readonly")==="readonly",cursor:this.$.data("cursor")===true&&30||this.$.data("cursor")||0,thickness:this.$.data("thickness")&&Math.max(Math.min(this.$.data("thickness"),1),.01)||.35,lineCap:this.$.data("linecap")||"butt",width:this.$.data("width")||200,height:this.$.data("height")||200,displayInput:this.$.data("displayinput")==null||this.$.data("displayinput"),displayPrevious:this.$.data("displayprevious"),fgColor:this.$.data("fgcolor")||"#87CEEB",inputColor:this.$.data("inputcolor"),font:this.$.data("font")||"Arial",fontWeight:this.$.data("font-weight")||"bold",inline:false,step:this.$.data("step")||1,rotation:this.$.data("rotation"),draw:null,change:null,cancel:null,release:null,format:function(v){return v},parse:function(v){return parseFloat(v)}},this.o);this.o.flip=this.o.rotation==="anticlockwise"||this.o.rotation==="acw";if(!this.o.inputColor){this.o.inputColor=this.o.fgColor}if(this.$.is("fieldset")){this.v={};this.i=this.$.find("input");this.i.each(function(k){var $this=$(this);s.i[k]=$this;s.v[k]=s.o.parse($this.val());$this.bind("change blur",function(){var val={};val[k]=$this.val();s.val(val)})});this.$.find("legend").remove()}else{this.i=this.$;this.v=this.o.parse(this.$.val());this.v===""&&(this.v=this.o.min);this.$.bind("change blur",function(){s.val(s._validate(s.o.parse(s.$.val())))})}!this.o.displayInput&&this.$.hide();this.$c=$(document.createElement("canvas")).attr({width:this.o.width,height:this.o.height});this.$div=$('<div style="'+(this.o.inline?"display:inline;":"")+"width:"+this.o.width+"px;height:"+this.o.height+"px;"+'"></div>');this.$.wrap(this.$div).before(this.$c);this.$div=this.$.parent();if(typeof G_vmlCanvasManager!=="undefined"){G_vmlCanvasManager.initElement(this.$c[0])}this.c=this.$c[0].getContext?this.$c[0].getContext("2d"):null;if(!this.c){throw{name:"CanvasNotSupportedException",message:"Canvas not supported. Please use excanvas on IE8.0.",toString:function(){return this.name+": "+this.message}}}this.scale=(window.devicePixelRatio||1)/(this.c.webkitBackingStorePixelRatio||this.c.mozBackingStorePixelRatio||this.c.msBackingStorePixelRatio||this.c.oBackingStorePixelRatio||this.c.backingStorePixelRatio||1);this.relativeWidth=this.o.width%1!==0&&this.o.width.indexOf("%");this.relativeHeight=this.o.height%1!==0&&this.o.height.indexOf("%");this.relative=this.relativeWidth||this.relativeHeight;this._carve();if(this.v instanceof Object){this.cv={};this.copy(this.v,this.cv)}else{this.cv=this.v}this.$.bind("configure",cf).parent().bind("configure",cf);this._listen()._configure()._xy().init();this.isInit=true;this.$.val(this.o.format(this.v));this._draw();return this};this._carve=function(){if(this.relative){var w=this.relativeWidth?this.$div.parent().width()*parseInt(this.o.width)/100:this.$div.parent().width(),h=this.relativeHeight?this.$div.parent().height()*parseInt(this.o.height)/100:this.$div.parent().height();this.w=this.h=Math.min(w,h)}else{this.w=this.o.width;this.h=this.o.height}this.$div.css({width:this.w+"px",height:this.h+"px"});this.$c.attr({width:this.w,height:this.h});if(this.scale!==1){this.$c[0].width=this.$c[0].width*this.scale;this.$c[0].height=this.$c[0].height*this.scale;this.$c.width(this.w);this.$c.height(this.h)}return this};this._draw=function(){var d=true;s.g=s.c;s.clear();s.dH&&(d=s.dH());d!==false&&s.draw()};this._touch=function(e){var touchMove=function(e){var v=s.xy2val(e.originalEvent.touches[s.t].pageX,e.originalEvent.touches[s.t].pageY);if(v==s.cv)return;if(s.cH&&s.cH(v)===false)return;s.change(s._validate(v));s._draw()};this.t=k.c.t(e);touchMove(e);k.c.d.bind("touchmove.k",touchMove).bind("touchend.k",function(){k.c.d.unbind("touchmove.k touchend.k");s.val(s.cv)});return this};this._mouse=function(e){var mouseMove=function(e){var v=s.xy2val(e.pageX,e.pageY);if(v==s.cv)return;if(s.cH&&s.cH(v)===false)return;s.change(s._validate(v));s._draw()};mouseMove(e);k.c.d.bind("mousemove.k",mouseMove).bind("keyup.k",function(e){if(e.keyCode===27){k.c.d.unbind("mouseup.k mousemove.k keyup.k");if(s.eH&&s.eH()===false)return;s.cancel()}}).bind("mouseup.k",function(e){k.c.d.unbind("mousemove.k mouseup.k keyup.k");s.val(s.cv)});return this};this._xy=function(){var o=this.$c.offset();this.x=o.left;this.y=o.top;return this};this._listen=function(){if(!this.o.readOnly){this.$c.bind("mousedown",function(e){e.preventDefault();s._xy()._mouse(e)}).bind("touchstart",function(e){e.preventDefault();s._xy()._touch(e)});this.listen()}else{this.$.attr("readonly","readonly")}if(this.relative){$(window).resize(function(){s._carve().init();s._draw()})}return this};this._configure=function(){if(this.o.draw)this.dH=this.o.draw;if(this.o.change)this.cH=this.o.change;if(this.o.cancel)this.eH=this.o.cancel;if(this.o.release)this.rH=this.o.release;if(this.o.displayPrevious){this.pColor=this.h2rgba(this.o.fgColor,"0.4");this.fgColor=this.h2rgba(this.o.fgColor,"0.6")}else{this.fgColor=this.o.fgColor}return this};this._clear=function(){this.$c[0].width=this.$c[0].width};this._validate=function(v){return~~((v<0?-.5:.5)+v/this.o.step)*this.o.step};this.listen=function(){};this.extend=function(){};this.init=function(){};this.change=function(v){};this.val=function(v){};this.xy2val=function(x,y){};this.draw=function(){};this.clear=function(){this._clear()};this.h2rgba=function(h,a){var rgb;h=h.substring(1,7);rgb=[parseInt(h.substring(0,2),16),parseInt(h.substring(2,4),16),parseInt(h.substring(4,6),16)];return"rgba("+rgb[0]+","+rgb[1]+","+rgb[2]+","+a+")"};this.copy=function(f,t){for(var i in f){t[i]=f[i]}}};k.Dial=function(){k.o.call(this);this.startAngle=null;this.xy=null;this.radius=null;this.lineWidth=null;this.cursorExt=null;this.w2=null;this.PI2=2*Math.PI;this.extend=function(){this.o=$.extend({bgColor:this.$.data("bgcolor")||"#EEEEEE",angleOffset:this.$.data("angleoffset")||0,angleArc:this.$.data("anglearc")||360,inline:true},this.o)};this.val=function(v,triggerRelease){if(null!=v){v=this.o.parse(v);if(triggerRelease!==false&&v!=this.v&&this.rH&&this.rH(v)===false)return;this.cv=this.o.stopper?max(min(v,this.o.max),this.o.min):v;this.v=this.cv;this.$.val(this.o.format(this.v));this._draw()}else{return this.v}};this.xy2val=function(x,y){var a,ret;a=Math.atan2(x-(this.x+this.w2),-(y-this.y-this.w2))-this.angleOffset;if(this.o.flip){a=this.angleArc-a-this.PI2}if(this.angleArc!=this.PI2&&a<0&&a>-.5){a=0}else if(a<0){a+=this.PI2}ret=~~(.5+a*(this.o.max-this.o.min)/this.angleArc)+this.o.min;this.o.stopper&&(ret=max(min(ret,this.o.max),this.o.min));return ret};this.listen=function(){var s=this,mwTimerStop,mwTimerRelease,mw=function(e){e.preventDefault();var ori=e.originalEvent,deltaX=ori.detail||ori.wheelDeltaX,deltaY=ori.detail||ori.wheelDeltaY,v=s._validate(s.o.parse(s.$.val()))+(deltaX>0||deltaY>0?s.o.step:deltaX<0||deltaY<0?-s.o.step:0);v=max(min(v,s.o.max),s.o.min);s.val(v,false);if(s.rH){clearTimeout(mwTimerStop);mwTimerStop=setTimeout(function(){s.rH(v);mwTimerStop=null},100);if(!mwTimerRelease){mwTimerRelease=setTimeout(function(){if(mwTimerStop)s.rH(v);mwTimerRelease=null},200)}}},kval,to,m=1,kv={37:-s.o.step,38:s.o.step,39:s.o.step,40:-s.o.step};this.$.bind("keydown",function(e){var kc=e.keyCode;if(kc>=96&&kc<=105){kc=e.keyCode=kc-48}kval=parseInt(String.fromCharCode(kc));if(isNaN(kval)){kc!==13&&kc!==8&&kc!==9&&kc!==189&&(kc!==190||s.$.val().match(/\./))&&e.preventDefault();if($.inArray(kc,[37,38,39,40])>-1){e.preventDefault();var v=s.o.parse(s.$.val())+kv[kc]*m;s.o.stopper&&(v=max(min(v,s.o.max),s.o.min));s.change(v);s._draw();to=window.setTimeout(function(){m*=2},30)}}}).bind("keyup",function(e){if(isNaN(kval)){if(to){window.clearTimeout(to);to=null;m=1;s.val(s.$.val())}}else{s.$.val()>s.o.max&&s.$.val(s.o.max)||s.$.val()<s.o.min&&s.$.val(s.o.min)}});this.$c.bind("mousewheel DOMMouseScroll",mw);this.$.bind("mousewheel DOMMouseScroll",mw)};this.init=function(){if(this.v<this.o.min||this.v>this.o.max)this.v=this.o.min;this.$.val(this.v);this.w2=this.w/2;this.cursorExt=this.o.cursor/100;this.xy=this.w2*this.scale;this.lineWidth=this.xy*this.o.thickness;this.lineCap=this.o.lineCap;this.radius=this.xy-this.lineWidth/2;this.o.angleOffset&&(this.o.angleOffset=isNaN(this.o.angleOffset)?0:this.o.angleOffset);this.o.angleArc&&(this.o.angleArc=isNaN(this.o.angleArc)?this.PI2:this.o.angleArc);this.angleOffset=this.o.angleOffset*Math.PI/180;this.angleArc=this.o.angleArc*Math.PI/180;this.startAngle=1.5*Math.PI+this.angleOffset;this.endAngle=1.5*Math.PI+this.angleOffset+this.angleArc;var s=max(String(Math.abs(this.o.max)).length,String(Math.abs(this.o.min)).length,2)+2;this.o.displayInput&&this.i.css({width:(this.w/2+4>>0)+"px",height:(this.w/3>>0)+"px",position:"absolute","vertical-align":"middle","margin-top":(this.w/3>>0)+"px","margin-left":"-"+(this.w*3/4+2>>0)+"px",border:0,background:"none",font:this.o.fontWeight+" "+(this.w/s>>0)+"px "+this.o.font,"text-align":"center",color:this.o.inputColor||this.o.fgColor,padding:"0px","-webkit-appearance":"none"})||this.i.css({width:"0px",visibility:"hidden"})};this.change=function(v){this.cv=v;this.$.val(this.o.format(v))};this.angle=function(v){return(v-this.o.min)*this.angleArc/(this.o.max-this.o.min)};this.arc=function(v){var sa,ea;v=this.angle(v);if(this.o.flip){sa=this.endAngle+1e-5;ea=sa-v-1e-5}else{sa=this.startAngle-1e-5;ea=sa+v+1e-5}this.o.cursor&&(sa=ea-this.cursorExt)&&(ea=ea+this.cursorExt);return{s:sa,e:ea,d:this.o.flip&&!this.o.cursor}};this.draw=function(){var c=this.g,a=this.arc(this.cv),pa,r=1;c.lineWidth=this.lineWidth;c.lineCap=this.lineCap;c.beginPath();c.strokeStyle=this.o.bgColor;c.arc(this.xy,this.xy,this.radius,this.endAngle-1e-5,this.startAngle+1e-5,true);c.stroke();if(this.o.displayPrevious){pa=this.arc(this.v);c.beginPath();c.strokeStyle=this.pColor;c.arc(this.xy,this.xy,this.radius,pa.s,pa.e,pa.d);c.stroke();r=this.cv==this.v}c.beginPath();c.strokeStyle=r?this.o.fgColor:this.fgColor;c.arc(this.xy,this.xy,this.radius,a.s,a.e,a.d);c.stroke()};this.cancel=function(){this.val(this.v)}};$.fn.dial=$.fn.knob=function(o){return this.each(function(){var d=new k.Dial;d.o=o;d.$=$(this);d.run()}).parent()}});
/*! jquery-textcomplete - v0.2.6 - 2014-08-16 */!function(a){"use strict";var b=function(a){var b,d,e;return b=function(){d=!1},function(){var b=c(arguments);if(d)return e=b,void 0;d=!0;var f=this;b.unshift(function g(){if(e){var b=e;e=void 0,b.unshift(g),a.apply(f,b)}else d=!1}),a.apply(this,b)}},c=function(a){var b;return b=Array.prototype.slice.call(a)},d=function(){var b;return b=a("<div></div>").css(["color"]).color,"undefined"!=typeof b?function(a,b){return a.css(b)}:function(b,c){var d;return d={},a.each(c,function(a,c){d[c]=b.css(c)}),d}}(),e=function(a){return a},f=function(a){var b={};return function(c,d){b[c]?d(b[c]):a.call(this,c,function(a){b[c]=(b[c]||[]).concat(a),d.apply(null,arguments)})}},g=function(a,b){var c,d;if(a.indexOf)return-1!=a.indexOf(b);for(c=0,d=a.length;d>c;c++)if(a[c]===b)return!0;return!1},h=function(){function c(b,c){var d;this.el=b.get(0),d=this.el===document.activeElement,this.$el=b,this.id="textComplete"+h++,this.strategies=[],this.option=c,d?(this.initialize(),this.$el.focus()):this.$el.one("focus.textComplete",a.proxy(this.initialize,this))}var e,f,g,h;return e={list:'<ul class="dropdown-menu"></ul>'},f={list:{position:"absolute",left:0,zIndex:"100",display:"none"}},g=a(e.list).css(f.list),h=0,a.extend(c.prototype,{initialize:function(){var b,c,d,e;b=g.clone(),this.listView=new i(b,this),this.$el.on({"keyup.textComplete":a.proxy(this.onKeyup,this),"keydown.textComplete":a.proxy(this.listView.onKeydown,this.listView)}),d=this.option.appendTo,d?this.listView.appendTo(d instanceof a?d:a(d)):this.listView.appendTo(a("body")),e=this.option.height,e&&(b.css("overflow-y","auto"),b.height(e)),c={},c["click."+this.id]=a.proxy(this.onClickDocument,this),c["keyup."+this.id]=a.proxy(this.onKeyupDocument,this),a(document).on(c)},register:function(a){this.strategies=this.strategies.concat(a)},renderList:function(a){this.clearAtNext&&(this.listView.clear(),this.clearAtNext=!1),a.length&&(this.listView.strategy=this.strategy,this.listView.shown||this.listView.setPosition(this.getCaretPosition()).clear().activate(),a=a.slice(0,this.strategy.maxCount),this.listView.render(a)),!this.listView.data.length&&this.listView.shown&&this.listView.deactivate()},searchCallbackFactory:function(a){var b=this;return function(c,d){b.renderList(c),d||(a(),b.clearAtNext=!0)}},onKeyup:function(a){this.skipSearch(a)||this.trigger(null,!0)},trigger:function(a,b){var c,d;if(a||(a=this.getTextFromHeadToCaret()),c=this.extractSearchQuery(a),c.length){if(d=c[1],b&&this.term===d)return;this.term=d,this.search(c)}else this.term=null,this.listView.deactivate()},skipSearch:function(a){switch(a.keyCode){case 40:case 38:return!0}if(a.ctrlKey)switch(a.keyCode){case 78:case 80:return!0}},onSelect:function(b){var c,d,e,f,g,h,i;if(c=this.getTextFromHeadToCaret(),i=c.length,this.el.isContentEditable){f=window.getSelection(),g=f.getRangeAt(0),h=g.cloneRange(),h.selectNodeContents(g.startContainer);var j=h.toString();d=j.substring(g.startOffset)}else d=this.el.value.substring(this.el.selectionEnd);if(e=this.strategy.replace(b),a.isArray(e)&&(d=e[1]+d,e=e[0]),c=c.replace(this.strategy.match,e),this.el.isContentEditable){g.selectNodeContents(g.startContainer),g.deleteContents();var k=document.createTextNode(c+d);g.insertNode(k),g.setStart(k,c.length),g.collapse(!0),f.removeAllRanges(),f.addRange(g)}else this.$el.val(c+d),this.el.selectionStart=this.el.selectionEnd=c.length;this.$el.trigger("change").trigger("textComplete:select",b),this.el.focus()},onClickDocument:function(a){a.originalEvent&&!a.originalEvent.keepTextCompleteDropdown&&this.listView.deactivate()},onKeyupDocument:function(a){this.listView.shown&&27===a.keyCode&&(this.listView.deactivate(),this.$el.focus())},destroy:function(){this.$el.off(".textComplete"),a(document).off("."+this.id),this.listView&&this.listView.destroy(),this.$el.removeData("textComplete"),this.$el=null},getCaretPosition:function(){var a,b;return a=this.getCaretRelativePosition(),b=this.$el.offset(),a.top+=b.top,a.left+=b.left,a},getCaretRelativePosition:function(){var b,c,e,f,g,h,i,j,k,l;return this.el.isContentEditable?(j=window.getSelection().getRangeAt(0).cloneRange(),k=document.createElement("span"),j.insertNode(k),j.selectNodeContents(k),j.deleteContents(),l=a(k),g=l.offset(),g.left-=this.$el.offset().left,g.top+=l.height()-this.$el.offset().top):(b=["border-width","font-family","font-size","font-style","font-variant","font-weight","height","letter-spacing","word-spacing","line-height","text-decoration","text-align","width","padding-top","padding-right","padding-bottom","padding-left","margin-top","margin-right","margin-bottom","margin-left","border-style","box-sizing"],i=this.$el[0].scrollHeight>this.$el[0].offsetHeight,c=a.extend({position:"absolute",overflow:i?"scroll":"auto","white-space":"pre-wrap",top:0,left:-9999,direction:h},d(this.$el,b)),e=a("<div></div>").css(c).text(this.getTextFromHeadToCaret()),f=a("<span></span>").text(".").appendTo(e),this.$el.before(e),g=f.position(),g.top+=f.height()-this.$el.scrollTop(),e.remove()),h=this.$el.attr("dir")||this.$el.css("direction"),"rtl"===h&&(g.left-=this.listView.$el.width()),g},getTextFromHeadToCaret:function(){var a,b,c;if(this.el.isContentEditable){if(window.getSelection){var c=window.getSelection().getRangeAt(0),d=c.cloneRange();d.selectNodeContents(c.startContainer),a=d.toString().substring(0,c.startOffset)}}else b=this.el.selectionEnd,"number"==typeof b?a=this.el.value.substring(0,b):document.selection&&(c=this.el.createTextRange(),c.moveStart("character",0),c.moveEnd("textedit"),a=c.text);return a},extractSearchQuery:function(a){var b,c,d,e;for(b=0,c=this.strategies.length;c>b;b++)if(d=this.strategies[b],e=a.match(d.match))return[d,e[d.index]];return[]},search:b(function(a,b){var c;this.strategy=b[0],c=b[1],this.strategy.search(c,this.searchCallbackFactory(a))})}),c}(),i=function(){function b(b,c){this.data=[],this.$el=b,this.index=0,this.completer=c,c.option.listPosition&&(this.setPosition=c.option.listPosition),this.$el.on("mousedown.textComplete","li.textcomplete-item",a.proxy(this.onClick,this)),this.$el.on("mouseover.textComplete","li.textcomplete-item",a.proxy(this.onMouseover,this))}return a.extend(b.prototype,{shown:!1,render:function(b){var c,d,e,f,h,i;for(c="",this.strategy.header&&(i=a.isFunction(this.strategy.header)?this.strategy.header(b):this.strategy.header,c+='<li class="textcomplete-header">'+i+"</li>"),d=0,e=b.length;e>d&&(h=b[d],g(this.data,h)||(f=this.data.length,this.data.push(h),c+='<li class="textcomplete-item" data-index="'+f+'"><a>',c+=this.strategy.template(h),c+="</a></li>",this.data.length!==this.strategy.maxCount));d++);this.strategy.footer&&(i=a.isFunction(this.strategy.footer)?this.strategy.footer(b):this.strategy.footer,c+='<li class="textcomplete-footer">'+i+"</li>"),this.$el.append(c),this.data.length?(this.activateIndexedItem(),this.setScroll()):this.deactivate()},clear:function(){return this.data=[],this.$el.html(""),this.index=0,this},activateIndexedItem:function(){this.$el.find(".active").removeClass("active"),this.getActiveItem().addClass("active")},getActiveItem:function(){return a(this.$el.children(".textcomplete-item").get(this.index))},activate:function(){return this.shown||(this.$el.show(),this.completer.$el.trigger("textComplete:show"),this.shown=!0),this},deactivate:function(){return this.shown&&(this.$el.hide(),this.completer.$el.trigger("textComplete:hide"),this.shown=!1,this.data=[],this.index=null),this},setPosition:function(a){var b;return this.strategy.placement.indexOf("top")>-1?(b=parseInt(this.$el.css("font-size")),a={top:"auto",bottom:this.$el.parent().height()-a.top+b,left:a.left}):a.bottom="auto",this.strategy.placement.indexOf("absleft")>-1&&(a.left=0),this.strategy.placement.indexOf("absright")>-1&&(a.right=0,a.left="auto"),this.$el.css(a),this},setScroll:function(){var a=this.getActiveItem(),b=a.position().top,c=a.outerHeight(),d=this.$el.innerHeight(),e=this.$el.scrollTop();0===this.index||this.index===this.data.length-1||0>b?this.$el.scrollTop(b+e):b+c>d&&this.$el.scrollTop(b+c+e-d)},select:function(a){var b=this;this.completer.onSelect(this.data[a]),setTimeout(function(){b.deactivate()},0)},onKeydown:function(b){if(this.shown){var c=b.ctrlKey||b.altKey||b.metaKey||b.shiftKey;if(38===b.keyCode||b.ctrlKey&&80===b.keyCode)b.preventDefault(),0===this.index?this.index=this.data.length-1:this.index-=1,this.activateIndexedItem(),this.setScroll();else if(40===b.keyCode||b.ctrlKey&&78===b.keyCode)b.preventDefault(),this.index===this.data.length-1?this.index=0:this.index+=1,this.activateIndexedItem(),this.setScroll();else if(c||13!==b.keyCode&&9!==b.keyCode){if(33===b.keyCode){b.preventDefault();var d=0,e=this.getActiveItem().position().top-this.$el.innerHeight();this.$el.children().each(function(b){return a(this).position().top+a(this).outerHeight()>e?(d=b,!1):void 0}),this.index=d,this.activateIndexedItem(),this.setScroll()}else if(34===b.keyCode){b.preventDefault();var d=this.data.length-1,e=this.getActiveItem().position().top+this.$el.innerHeight();this.$el.children().each(function(b){return a(this).position().top>e?(d=b,!1):void 0}),this.index=d,this.activateIndexedItem(),this.setScroll()}}else b.preventDefault(),this.select(parseInt(this.getActiveItem().data("index"),10))}},onClick:function(b){var c=a(b.target);b.preventDefault(),b.originalEvent.keepTextCompleteDropdown=!0,c.hasClass("textcomplete-item")||(c=c.parents("li.textcomplete-item")),this.select(parseInt(c.data("index"),10))},onMouseover:function(b){var c=a(b.target);b.preventDefault(),c.hasClass("textcomplete-item")||(c=c.parents("li.textcomplete-item")),this.index=parseInt(c.data("index"),10),this.activateIndexedItem()},destroy:function(){this.deactivate(),this.$el.off("click.textComplete").remove(),this.$el=null},appendTo:function(a){a.css({position:"relative"}).append(this.$el)}}),b}();a.fn.textcomplete=function(b,c){var d,g,i,j;if(j="textComplete",c||(c={}),"destroy"===b)return this.each(function(){var b=a(this).data(j);b&&b.destroy()});for(d=0,g=b.length;g>d;d++)i=b[d],i.template||(i.template=e),null==i.index&&(i.index=2),null==i.placement&&(i.placement=""),i.cache&&(i.search=f(i.search)),i.maxCount||(i.maxCount=10);return this.each(function(){var d,e;d=a(this),e=d.data(j),e||(e=new h(d,c),d.data(j,e)),e.register(b)})}}(window.jQuery||window.Zepto);
/*
 //@ sourceMappingURL=jquery.textcomplete.min.map
 */
!function(a){a.fn.simpleColor=function(b){function c(){b=a.simpleColorOptions;var c=a("<div class='simpleColorContainer' />");c.css("position","relative");var e=this.value&&""!=this.value?this.value:b.defaultColor,f=a("<div class='simpleColorDisplay' />");f.css(a.extend(b.displayCSS,{"background-color":e})),f.data("color",e),c.append(f),b.displayColorCode&&(f.data("displayColorCode",!0),f.text(this.value),f.css({color:b.colorCodeColor,textAlign:b.colorCodeAlign}));var g=function(c){if(a("html").bind("click.simpleColorDisplay",function(e){a("html").unbind("click.simpleColorDisplay"),a(".simpleColorChooser").hide();var g=a(e.target);(g.is(".simpleColorCell")===!1||a.contains(a(c.target).closest(".simpleColorContainer")[0],g[0])===!1)&&(f.css("background-color",f.data("color")),b.displayColorCode&&f.text(f.data("color"))),b.onClose&&b.onClose(d)}),c.data.container.chooser)c.data.container.chooser.toggle();else{var e=a("<div class='simpleColorChooser'/>");e.css(b.chooserCSS),c.data.container.chooser=e,c.data.container.append(e);for(var g=0;g<b.colors.length;g++){var h=a("<div class='simpleColorCell' id='"+b.colors[g]+"'/>");h.css({width:b.cellWidth+"px",height:b.cellHeight+"px",margin:b.cellMargin+"px",cursor:"pointer",lineHeight:b.cellHeight+"px",fontSize:"1px","float":"left","background-color":"#"+b.colors[g]}),e.append(h),(b.onCellEnter||b.livePreview)&&h.bind("mouseenter",function(){b.onCellEnter&&b.onCellEnter(this.id,d),b.livePreview&&(f.css("background-color","#"+this.id),b.displayColorCode&&f.text("#"+this.id))}),h.bind("click",{input:c.data.input,chooser:e,displayBox:f},function(c){var e="#"+this.id;c.data.input.value=e,a(c.data.input).change(),a(c.data.displayBox).data("color",e),c.data.displayBox.css("background-color",e),c.data.chooser.hide(),b.displayColorCode&&c.data.displayBox.text(e),b.onSelect&&b.onSelect(this.id,d)})}}},h={input:this,container:c,displayBox:f};f.bind("click",h,g),a(this).after(c),a(this).data("container",c)}var d=this,e=["990033","ff3366","cc0033","ff0033","ff9999","cc3366","ffccff","cc6699","993366","660033","cc3399","ff99cc","ff66cc","ff99ff","ff6699","cc0066","ff0066","ff3399","ff0099","ff33cc","ff00cc","ff66ff","ff33ff","ff00ff","cc0099","990066","cc66cc","cc33cc","cc99ff","cc66ff","cc33ff","993399","cc00cc","cc00ff","9900cc","990099","cc99cc","996699","663366","660099","9933cc","660066","9900ff","9933ff","9966cc","330033","663399","6633cc","6600cc","9966ff","330066","6600ff","6633ff","ccccff","9999ff","9999cc","6666cc","6666ff","666699","333366","333399","330099","3300cc","3300ff","3333ff","3333cc","0066ff","0033ff","3366ff","3366cc","000066","000033","0000ff","000099","0033cc","0000cc","336699","0066cc","99ccff","6699ff","003366","6699cc","006699","3399cc","0099cc","66ccff","3399ff","003399","0099ff","33ccff","00ccff","99ffff","66ffff","33ffff","00ffff","00cccc","009999","669999","99cccc","ccffff","33cccc","66cccc","339999","336666","006666","003333","00ffcc","33ffcc","33cc99","00cc99","66ffcc","99ffcc","00ff99","339966","006633","336633","669966","66cc66","99ff99","66ff66","339933","99cc99","66ff99","33ff99","33cc66","00cc66","66cc99","009966","009933","33ff66","00ff66","ccffcc","ccff99","99ff66","99ff33","00ff33","33ff33","00cc33","33cc33","66ff33","00ff00","66cc33","006600","003300","009900","33ff00","66ff00","99ff00","66cc00","00cc00","33cc00","339900","99cc66","669933","99cc33","336600","669900","99cc00","ccff66","ccff33","ccff00","999900","cccc00","cccc33","333300","666600","999933","cccc66","666633","999966","cccc99","ffffcc","ffff99","ffff66","ffff33","ffff00","ffcc00","ffcc66","ffcc33","cc9933","996600","cc9900","ff9900","cc6600","993300","cc6633","663300","ff9966","ff6633","ff9933","ff6600","cc3300","996633","330000","663333","996666","cc9999","993333","cc6666","ffcccc","ff3333","cc3333","ff6666","660000","990000","cc0000","ff0000","ff3300","cc9966","ffcc99","ffffff","cccccc","999999","666666","333333","000000","000000","000000","000000","000000","000000","000000","000000","000000"];return b=a.extend({defaultColor:this.attr("defaultColor")||"#FFF",cellWidth:this.attr("cellWidth")||10,cellHeight:this.attr("cellHeight")||10,cellMargin:this.attr("cellMargin")||1,boxWidth:this.attr("boxWidth")||"115px",boxHeight:this.attr("boxHeight")||"20px",columns:this.attr("columns")||16,insert:this.attr("insert")||"after",colors:this.attr("colors")||e,displayColorCode:this.attr("displayColorCode")||!1,colorCodeAlign:this.attr("colorCodeAlign")||"center",colorCodeColor:this.attr("colorCodeColor")||"#FFF",onSelect:null,onCellEnter:null,onClose:null,livePreview:!1},b||{}),b.totalWidth=b.columns*(b.cellWidth+2*b.cellMargin),b.chooserCSS=a.extend({border:"1px solid #000",margin:"0 0 0 5px",width:b.totalWidth,height:b.totalHeight,top:0,left:b.boxWidth,position:"absolute","background-color":"#fff"},b.chooserCSS||{}),b.displayCSS=a.extend({"background-color":b.defaultColor,border:"1px solid #000",width:b.boxWidth,height:b.boxHeight,"line-height":b.boxHeight+"px",cursor:"pointer"},b.displayCSS||{}),this.hide(),-1!=navigator.userAgent.indexOf("MSIE")&&(b.totalWidth+=2),b.totalHeight=Math.ceil(b.colors.length/b.columns)*(b.cellHeight+2*b.cellMargin),a.simpleColorOptions=b,this.each(c),a(".simpleColorDisplay").each(function(){a(this).click(function(a){a.stopPropagation()})}),this},a.fn.closeChooser=function(){return this.each(function(){a(this).data("container").find(".simpleColorChooser").hide()}),this},a.fn.setColor=function(b){return this.each(function(){var c=a(this).data("container").find(".simpleColorDisplay");c.css("background-color",b).data("color",b),c.data("displayColorCode")===!0&&c.text(b)}),this}}(jQuery);
/*! jquery.cookie v1.4.1 | MIT */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):"object"==typeof exports?a(require("jquery")):a(jQuery)}(function(a){function b(a){return h.raw?a:encodeURIComponent(a)}function c(a){return h.raw?a:decodeURIComponent(a)}function d(a){return b(h.json?JSON.stringify(a):String(a))}function e(a){0===a.indexOf('"')&&(a=a.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,"\\"));try{return a=decodeURIComponent(a.replace(g," ")),h.json?JSON.parse(a):a}catch(b){}}function f(b,c){var d=h.raw?b:e(b);return a.isFunction(c)?c(d):d}var g=/\+/g,h=a.cookie=function(e,g,i){if(void 0!==g&&!a.isFunction(g)){if(i=a.extend({},h.defaults,i),"number"==typeof i.expires){var j=i.expires,k=i.expires=new Date;k.setTime(+k+864e5*j)}return document.cookie=[b(e),"=",d(g),i.expires?"; expires="+i.expires.toUTCString():"",i.path?"; path="+i.path:"",i.domain?"; domain="+i.domain:"",i.secure?"; secure":""].join("")}for(var l=e?void 0:{},m=document.cookie?document.cookie.split("; "):[],n=0,o=m.length;o>n;n++){var p=m[n].split("="),q=c(p.shift()),r=p.join("=");if(e&&e===q){l=f(r,g);break}e||void 0===(r=f(r))||(l[q]=r)}return l};h.defaults={},a.removeCookie=function(b,c){return void 0===a.cookie(b)?!1:(a.cookie(b,"",a.extend({},c,{expires:-1})),!a.cookie(b))}});
// tipsy, facebook style tooltips for jquery
// version 1.0.0a
// (c) 2008-2010 jason frame [jason@onehackoranother.com]
// releated under the MIT license

(function($) {
    
    function fixTitle($ele) {
        if ($ele.attr('title') || typeof($ele.attr('original-title')) != 'string') {
            $ele.attr('original-title', $ele.attr('title') || '').removeAttr('title');
        }
    }
    
    function Tipsy(element, options) {
        this.$element = $(element);
        this.options = options;
        this.enabled = true;
        fixTitle(this.$element);
    }
    
    Tipsy.prototype = {
        show: function() {
            var title = this.getTitle();
            if (title && this.enabled) {
                var $tip = this.tip();
                
                $tip.find('.tipsy-inner')[this.options.html ? 'html' : 'text'](title);
                $tip[0].className = 'tipsy'; // reset classname in case of dynamic gravity
                $tip.remove().css({top: 0, left: 0, visibility: 'hidden', display: 'block'}).appendTo(document.body);
                
                var pos = $.extend({}, this.$element.offset(), {
                    width: this.$element[0].offsetWidth,
                    height: this.$element[0].offsetHeight
                });
                
                var actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
                var gravity = (typeof this.options.gravity == 'function')
                                ? this.options.gravity.call(this.$element[0])
                                : this.options.gravity;
                
                var tp;
                switch (gravity.charAt(0)) {
                    case 'n':
                        tp = {top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 's':
                        tp = {top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 'e':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset};
                        break;
                    case 'w':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset};
                        break;
                }
                
                if (gravity.length == 2) {
                    if (gravity.charAt(1) == 'w') {
                        tp.left = pos.left + pos.width / 2 - 15;
                    } else {
                        tp.left = pos.left + pos.width / 2 - actualWidth + 15;
                    }
                }
                
                $tip.css(tp).addClass('tipsy-' + gravity);
                
                if (this.options.fade) {
                    $tip.stop().css({opacity: 0, display: 'block', visibility: 'visible'}).animate({opacity: this.options.opacity});
                } else {
                    $tip.css({visibility: 'visible', opacity: this.options.opacity});
                }
            }
        },
        
        hide: function() {
            if (this.options.fade) {
                this.tip().stop().fadeOut(function() { $(this).remove(); });
            } else {
                this.tip().remove();
            }
        },
        
        getTitle: function() {
            var title, $e = this.$element, o = this.options;
            fixTitle($e);
            var title, o = this.options;
            if (typeof o.title == 'string') {
                title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
            } else if (typeof o.title == 'function') {
                title = o.title.call($e[0]);
            }
            title = ('' + title).replace(/(^\s*|\s*$)/, "");
            return title || o.fallback;
        },
        
        tip: function() {
            if (!this.$tip) {
                this.$tip = $('<div class="tipsy"></div>').html('<div class="tipsy-arrow"></div><div class="tipsy-inner"/></div>');
            }
            return this.$tip;
        },
        
        validate: function() {
            if (!this.$element[0].parentNode) {
                this.hide();
                this.$element = null;
                this.options = null;
            }
        },
        
        enable: function() { this.enabled = true; },
        disable: function() { this.enabled = false; },
        toggleEnabled: function() { this.enabled = !this.enabled; }
    };
    
    $.fn.tipsy = function(options) {
        
        if (options === true) {
            return this.data('tipsy');
        } else if (typeof options == 'string') {
            return this.data('tipsy')[options]();
        }
        
        options = $.extend({}, $.fn.tipsy.defaults, options);
        
        function get(ele) {
            var tipsy = $.data(ele, 'tipsy');
            if (!tipsy) {
                tipsy = new Tipsy(ele, $.fn.tipsy.elementOptions(ele, options));
                $.data(ele, 'tipsy', tipsy);
            }
            return tipsy;
        }
        
        function enter() {
            var tipsy = get(this);
            tipsy.hoverState = 'in';
            if (options.delayIn == 0) {
                tipsy.show();
            } else {
                setTimeout(function() { if (tipsy.hoverState == 'in') tipsy.show(); }, options.delayIn);
            }
        };
        
        function leave() {
            var tipsy = get(this);
            tipsy.hoverState = 'out';
            if (options.delayOut == 0) {
                tipsy.hide();
            } else {
                setTimeout(function() { if (tipsy.hoverState == 'out') tipsy.hide(); }, options.delayOut);
            }
        };
        
        if (!options.live) this.each(function() { get(this); });
        
        if (options.trigger != 'manual') {
            var binder   = options.live ? 'live' : 'bind',
                eventIn  = options.trigger == 'hover' ? 'mouseenter' : 'focus',
                eventOut = options.trigger == 'hover' ? 'mouseleave' : 'blur';
            this[binder](eventIn, enter)[binder](eventOut, leave);
        }
        
        return this;
        
    };
    
    $.fn.tipsy.defaults = {
        delayIn: 0,
        delayOut: 0,
        fade: false,
        fallback: '',
        gravity: 'n',
        html: false,
        live: false,
        offset: 0,
        opacity: 0.8,
        title: 'title',
        trigger: 'hover'
    };
    
    // Overwrite this method to provide options on a per-element basis.
    // For example, you could store the gravity in a 'tipsy-gravity' attribute:
    // return $.extend({}, options, {gravity: $(ele).attr('tipsy-gravity') || 'n' });
    // (remember - do not modify 'options' in place!)
    $.fn.tipsy.elementOptions = function(ele, options) {
        return $.metadata ? $.extend({}, options, $(ele).metadata()) : options;
    };
    
    $.fn.tipsy.autoNS = function() {
        return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
    };
    
    $.fn.tipsy.autoWE = function() {
        return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
    };
    
})(jQuery);
/* perfect-scrollbar v0.6.4 */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var ps = require('../main')
        , psInstances = require('../plugin/instances');

    function mountJQuery(jQuery) {
        jQuery.fn.perfectScrollbar = function (settingOrCommand) {
            return this.each(function () {
                if (typeof settingOrCommand === 'object' ||
                    typeof settingOrCommand === 'undefined') {
                    // If it's an object or none, initialize.
                    var settings = settingOrCommand;

                    if (!psInstances.get(this)) {
                        ps.initialize(this, settings);
                    }
                } else {
                    // Unless, it may be a command.
                    var command = settingOrCommand;

                    if (command === 'update') {
                        ps.update(this);
                    } else if (command === 'destroy') {
                        ps.destroy(this);
                    }
                }

                return jQuery(this);
            });
        };
    }

    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], mountJQuery);
    } else {
        var jq = window.jQuery ? window.jQuery : window.$;
        if (typeof jq !== 'undefined') {
            mountJQuery(jq);
        }
    }

    module.exports = mountJQuery;

},{"../main":7,"../plugin/instances":18}],2:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    function oldAdd(element, className) {
        var classes = element.className.split(' ');
        if (classes.indexOf(className) < 0) {
            classes.push(className);
        }
        element.className = classes.join(' ');
    }

    function oldRemove(element, className) {
        var classes = element.className.split(' ');
        var idx = classes.indexOf(className);
        if (idx >= 0) {
            classes.splice(idx, 1);
        }
        element.className = classes.join(' ');
    }

    exports.add = function (element, className) {
        if (element.classList) {
            element.classList.add(className);
        } else {
            oldAdd(element, className);
        }
    };

    exports.remove = function (element, className) {
        if (element.classList) {
            element.classList.remove(className);
        } else {
            oldRemove(element, className);
        }
    };

    exports.list = function (element) {
        if (element.classList) {
            return element.classList;
        } else {
            return element.className.split(' ');
        }
    };

},{}],3:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    exports.e = function (tagName, className) {
        var element = document.createElement(tagName);
        element.className = className;
        return element;
    };

    exports.appendTo = function (child, parent) {
        parent.appendChild(child);
        return child;
    };

    function cssGet(element, styleName) {
        return window.getComputedStyle(element)[styleName];
    }

    function cssSet(element, styleName, styleValue) {
        if (typeof styleValue === 'number') {
            styleValue = styleValue.toString() + 'px';
        }
        element.style[styleName] = styleValue;
        return element;
    }

    function cssMultiSet(element, obj) {
        for (var key in obj) {
            var val = obj[key];
            if (typeof val === 'number') {
                val = val.toString() + 'px';
            }
            element.style[key] = val;
        }
        return element;
    }

    exports.css = function (element, styleNameOrObject, styleValue) {
        if (typeof styleNameOrObject === 'object') {
            // multiple set with object
            return cssMultiSet(element, styleNameOrObject);
        } else {
            if (typeof styleValue === 'undefined') {
                return cssGet(element, styleNameOrObject);
            } else {
                return cssSet(element, styleNameOrObject, styleValue);
            }
        }
    };

    exports.matches = function (element, query) {
        if (typeof element.matches !== 'undefined') {
            return element.matches(query);
        } else {
            if (typeof element.matchesSelector !== 'undefined') {
                return element.matchesSelector(query);
            } else if (typeof element.webkitMatchesSelector !== 'undefined') {
                return element.webkitMatchesSelector(query);
            } else if (typeof element.mozMatchesSelector !== 'undefined') {
                return element.mozMatchesSelector(query);
            } else if (typeof element.msMatchesSelector !== 'undefined') {
                return element.msMatchesSelector(query);
            }
        }
    };

    exports.remove = function (element) {
        if (typeof element.remove !== 'undefined') {
            element.remove();
        } else {
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
        }
    };

},{}],4:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var EventElement = function (element) {
        this.element = element;
        this.events = {};
    };

    EventElement.prototype.bind = function (eventName, handler) {
        if (typeof this.events[eventName] === 'undefined') {
            this.events[eventName] = [];
        }
        this.events[eventName].push(handler);
        this.element.addEventListener(eventName, handler, false);
    };

    EventElement.prototype.unbind = function (eventName, handler) {
        var isHandlerProvided = (typeof handler !== 'undefined');
        this.events[eventName] = this.events[eventName].filter(function (hdlr) {
            if (isHandlerProvided && hdlr !== handler) {
                return true;
            }
            this.element.removeEventListener(eventName, hdlr, false);
            return false;
        }, this);
    };

    EventElement.prototype.unbindAll = function () {
        for (var name in this.events) {
            this.unbind(name);
        }
    };

    var EventManager = function () {
        this.eventElements = [];
    };

    EventManager.prototype.eventElement = function (element) {
        var ee = this.eventElements.filter(function (eventElement) {
            return eventElement.element === element;
        })[0];
        if (typeof ee === 'undefined') {
            ee = new EventElement(element);
            this.eventElements.push(ee);
        }
        return ee;
    };

    EventManager.prototype.bind = function (element, eventName, handler) {
        this.eventElement(element).bind(eventName, handler);
    };

    EventManager.prototype.unbind = function (element, eventName, handler) {
        this.eventElement(element).unbind(eventName, handler);
    };

    EventManager.prototype.unbindAll = function () {
        for (var i = 0; i < this.eventElements.length; i++) {
            this.eventElements[i].unbindAll();
        }
    };

    EventManager.prototype.once = function (element, eventName, handler) {
        var ee = this.eventElement(element);
        var onceHandler = function (e) {
            ee.unbind(eventName, onceHandler);
            handler(e);
        };
        ee.bind(eventName, onceHandler);
    };

    module.exports = EventManager;

},{}],5:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    module.exports = (function () {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return function () {
            return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                s4() + '-' + s4() + s4() + s4();
        };
    })();

},{}],6:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var cls = require('./class')
        , d = require('./dom');

    exports.toInt = function (x) {
        return parseInt(x, 10) || 0;
    };

    exports.clone = function (obj) {
        if (obj === null) {
            return null;
        } else if (typeof obj === 'object') {
            var result = {};
            for (var key in obj) {
                result[key] = this.clone(obj[key]);
            }
            return result;
        } else {
            return obj;
        }
    };

    exports.extend = function (original, source) {
        var result = this.clone(original);
        for (var key in source) {
            result[key] = this.clone(source[key]);
        }
        return result;
    };

    exports.isEditable = function (el) {
        return d.matches(el, "input,[contenteditable]") ||
            d.matches(el, "select,[contenteditable]") ||
            d.matches(el, "textarea,[contenteditable]") ||
            d.matches(el, "button,[contenteditable]");
    };

    exports.removePsClasses = function (element) {
        var clsList = cls.list(element);
        for (var i = 0; i < clsList.length; i++) {
            var className = clsList[i];
            if (className.indexOf('ps-') === 0) {
                cls.remove(element, className);
            }
        }
    };

    exports.outerWidth = function (element) {
        return this.toInt(d.css(element, 'width')) +
            this.toInt(d.css(element, 'paddingLeft')) +
            this.toInt(d.css(element, 'paddingRight')) +
            this.toInt(d.css(element, 'borderLeftWidth')) +
            this.toInt(d.css(element, 'borderRightWidth'));
    };

    exports.startScrolling = function (element, axis) {
        cls.add(element, 'ps-in-scrolling');
        if (typeof axis !== 'undefined') {
            cls.add(element, 'ps-' + axis);
        } else {
            cls.add(element, 'ps-x');
            cls.add(element, 'ps-y');
        }
    };

    exports.stopScrolling = function (element, axis) {
        cls.remove(element, 'ps-in-scrolling');
        if (typeof axis !== 'undefined') {
            cls.remove(element, 'ps-' + axis);
        } else {
            cls.remove(element, 'ps-x');
            cls.remove(element, 'ps-y');
        }
    };

    exports.env = {
        isWebKit: 'WebkitAppearance' in document.documentElement.style,
        supportsTouch: (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),
        supportsIePointer: window.navigator.msMaxTouchPoints !== null
    };

},{"./class":2,"./dom":3}],7:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var destroy = require('./plugin/destroy')
        , initialize = require('./plugin/initialize')
        , update = require('./plugin/update');

    module.exports = {
        initialize: initialize,
        update: update,
        destroy: destroy
    };

},{"./plugin/destroy":9,"./plugin/initialize":17,"./plugin/update":20}],8:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    module.exports = {
        wheelSpeed: 1,
        wheelPropagation: false,
        swipePropagation: true,
        minScrollbarLength: null,
        maxScrollbarLength: null,
        useBothWheelAxes: false,
        useKeyboard: true,
        suppressScrollX: false,
        suppressScrollY: false,
        scrollXMarginOffset: 0,
        scrollYMarginOffset: 0,
        stopPropagationOnClick: true
    };

},{}],9:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var d = require('../lib/dom')
        , h = require('../lib/helper')
        , instances = require('./instances');

    module.exports = function (element) {
        var i = instances.get(element);

        if (!i) {
            return;
        }

        i.event.unbindAll();
        d.remove(i.scrollbarX);
        d.remove(i.scrollbarY);
        d.remove(i.scrollbarXRail);
        d.remove(i.scrollbarYRail);
        h.removePsClasses(element);

        instances.remove(element);
    };

},{"../lib/dom":3,"../lib/helper":6,"./instances":18}],10:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var h = require('../../lib/helper')
        , instances = require('../instances')
        , updateGeometry = require('../update-geometry');

    function bindClickRailHandler(element, i) {
        function pageOffset(el) {
            return el.getBoundingClientRect();
        }
        var stopPropagation = window.Event.prototype.stopPropagation.bind;

        if (i.settings.stopPropagationOnClick) {
            i.event.bind(i.scrollbarY, 'click', stopPropagation);
        }
        i.event.bind(i.scrollbarYRail, 'click', function (e) {
            var halfOfScrollbarLength = h.toInt(i.scrollbarYHeight / 2);
            var positionTop = i.railYRatio * (e.pageY - window.scrollY - pageOffset(i.scrollbarYRail).top - halfOfScrollbarLength);
            var maxPositionTop = i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
            var positionRatio = positionTop / maxPositionTop;

            if (positionRatio < 0) {
                positionRatio = 0;
            } else if (positionRatio > 1) {
                positionRatio = 1;
            }

            element.scrollTop = (i.contentHeight - i.containerHeight) * positionRatio;
            updateGeometry(element);

            e.stopPropagation();
        });

        if (i.settings.stopPropagationOnClick) {
            i.event.bind(i.scrollbarX, 'click', stopPropagation);
        }
        i.event.bind(i.scrollbarXRail, 'click', function (e) {
            var halfOfScrollbarLength = h.toInt(i.scrollbarXWidth / 2);
            var positionLeft = i.railXRatio * (e.pageX - window.scrollX - pageOffset(i.scrollbarXRail).left - halfOfScrollbarLength);
            var maxPositionLeft = i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
            var positionRatio = positionLeft / maxPositionLeft;

            if (positionRatio < 0) {
                positionRatio = 0;
            } else if (positionRatio > 1) {
                positionRatio = 1;
            }

            element.scrollLeft = ((i.contentWidth - i.containerWidth) * positionRatio) - i.negativeScrollAdjustment;
            updateGeometry(element);

            e.stopPropagation();
        });
    }

    module.exports = function (element) {
        var i = instances.get(element);
        bindClickRailHandler(element, i);
    };

},{"../../lib/helper":6,"../instances":18,"../update-geometry":19}],11:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var d = require('../../lib/dom')
        , h = require('../../lib/helper')
        , instances = require('../instances')
        , updateGeometry = require('../update-geometry');

    function bindMouseScrollXHandler(element, i) {
        var currentLeft = null;
        var currentPageX = null;

        function updateScrollLeft(deltaX) {
            var newLeft = currentLeft + (deltaX * i.railXRatio);
            var maxLeft = i.scrollbarXRail.getBoundingClientRect().left + (i.railXRatio * (i.railXWidth - i.scrollbarXWidth));

            if (newLeft < 0) {
                i.scrollbarXLeft = 0;
            } else if (newLeft > maxLeft) {
                i.scrollbarXLeft = maxLeft;
            } else {
                i.scrollbarXLeft = newLeft;
            }

            var scrollLeft = h.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - (i.railXRatio * i.scrollbarXWidth))) - i.negativeScrollAdjustment;
            element.scrollLeft = scrollLeft;
        }

        var mouseMoveHandler = function (e) {
            updateScrollLeft(e.pageX - currentPageX);
            updateGeometry(element);
            e.stopPropagation();
            e.preventDefault();
        };

        var mouseUpHandler = function () {
            h.stopScrolling(element, 'x');
            i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
        };

        i.event.bind(i.scrollbarX, 'mousedown', function (e) {
            currentPageX = e.pageX;
            currentLeft = h.toInt(d.css(i.scrollbarX, 'left')) * i.railXRatio;
            h.startScrolling(element, 'x');

            i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
            i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

            e.stopPropagation();
            e.preventDefault();
        });
    }

    function bindMouseScrollYHandler(element, i) {
        var currentTop = null;
        var currentPageY = null;

        function updateScrollTop(deltaY) {
            var newTop = currentTop + (deltaY * i.railYRatio);
            var maxTop = i.scrollbarYRail.getBoundingClientRect().top + (i.railYRatio * (i.railYHeight - i.scrollbarYHeight));

            if (newTop < 0) {
                i.scrollbarYTop = 0;
            } else if (newTop > maxTop) {
                i.scrollbarYTop = maxTop;
            } else {
                i.scrollbarYTop = newTop;
            }

            var scrollTop = h.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - (i.railYRatio * i.scrollbarYHeight)));
            element.scrollTop = scrollTop;
        }

        var mouseMoveHandler = function (e) {
            updateScrollTop(e.pageY - currentPageY);
            updateGeometry(element);
            e.stopPropagation();
            e.preventDefault();
        };

        var mouseUpHandler = function () {
            h.stopScrolling(element, 'y');
            i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
        };

        i.event.bind(i.scrollbarY, 'mousedown', function (e) {
            currentPageY = e.pageY;
            currentTop = h.toInt(d.css(i.scrollbarY, 'top')) * i.railYRatio;
            h.startScrolling(element, 'y');

            i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
            i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

            e.stopPropagation();
            e.preventDefault();
        });
    }

    module.exports = function (element) {
        var i = instances.get(element);
        bindMouseScrollXHandler(element, i);
        bindMouseScrollYHandler(element, i);
    };

},{"../../lib/dom":3,"../../lib/helper":6,"../instances":18,"../update-geometry":19}],12:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var h = require('../../lib/helper')
        , instances = require('../instances')
        , updateGeometry = require('../update-geometry');

    function bindKeyboardHandler(element, i) {
        var hovered = false;
        i.event.bind(element, 'mouseenter', function () {
            hovered = true;
        });
        i.event.bind(element, 'mouseleave', function () {
            hovered = false;
        });

        var shouldPrevent = false;
        function shouldPreventDefault(deltaX, deltaY) {
            var scrollTop = element.scrollTop;
            if (deltaX === 0) {
                if (!i.scrollbarYActive) {
                    return false;
                }
                if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
                    return !i.settings.wheelPropagation;
                }
            }

            var scrollLeft = element.scrollLeft;
            if (deltaY === 0) {
                if (!i.scrollbarXActive) {
                    return false;
                }
                if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
                    return !i.settings.wheelPropagation;
                }
            }
            return true;
        }

        i.event.bind(i.ownerDocument, 'keydown', function (e) {
            if (e.isDefaultPrevented && e.isDefaultPrevented()) {
                return;
            }

            if (!hovered) {
                return;
            }

            var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
            if (activeElement) {
                // go deeper if element is a webcomponent
                while (activeElement.shadowRoot) {
                    activeElement = activeElement.shadowRoot.activeElement;
                }
                if (h.isEditable(activeElement)) {
                    return;
                }
            }

            var deltaX = 0;
            var deltaY = 0;

            switch (e.which) {
                case 37: // left
                    deltaX = -30;
                    break;
                case 38: // up
                    deltaY = 30;
                    break;
                case 39: // right
                    deltaX = 30;
                    break;
                case 40: // down
                    deltaY = -30;
                    break;
                case 33: // page up
                    deltaY = 90;
                    break;
                case 32: // space bar
                case 34: // page down
                    deltaY = -90;
                    break;
                case 35: // end
                    if (e.ctrlKey) {
                        deltaY = -i.contentHeight;
                    } else {
                        deltaY = -i.containerHeight;
                    }
                    break;
                case 36: // home
                    if (e.ctrlKey) {
                        deltaY = element.scrollTop;
                    } else {
                        deltaY = i.containerHeight;
                    }
                    break;
                default:
                    return;
            }

            element.scrollTop = element.scrollTop - deltaY;
            element.scrollLeft = element.scrollLeft + deltaX;
            updateGeometry(element);

            shouldPrevent = shouldPreventDefault(deltaX, deltaY);
            if (shouldPrevent) {
                e.preventDefault();
            }
        });
    }

    module.exports = function (element) {
        var i = instances.get(element);
        bindKeyboardHandler(element, i);
    };

},{"../../lib/helper":6,"../instances":18,"../update-geometry":19}],13:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var h = require('../../lib/helper')
        , instances = require('../instances')
        , updateGeometry = require('../update-geometry');

    function bindMouseWheelHandler(element, i) {
        var shouldPrevent = false;

        function shouldPreventDefault(deltaX, deltaY) {
            var scrollTop = element.scrollTop;
            if (deltaX === 0) {
                if (!i.scrollbarYActive) {
                    return false;
                }
                if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
                    return !i.settings.wheelPropagation;
                }
            }

            var scrollLeft = element.scrollLeft;
            if (deltaY === 0) {
                if (!i.scrollbarXActive) {
                    return false;
                }
                if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
                    return !i.settings.wheelPropagation;
                }
            }
            return true;
        }

        function getDeltaFromEvent(e) {
            var deltaX = e.deltaX;
            var deltaY = -1 * e.deltaY;

            if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
                // OS X Safari
                deltaX = -1 * e.wheelDeltaX / 6;
                deltaY = e.wheelDeltaY / 6;
            }

            if (e.deltaMode && e.deltaMode === 1) {
                // Firefox in deltaMode 1: Line scrolling
                deltaX *= 10;
                // deltaY *= 10;
                // @OmertaModification
                deltaY *= 13;
            }

            if (deltaX !== deltaX && deltaY !== deltaY/* NaN checks */) {
                // IE in some mouse drivers
                deltaX = 0;
                deltaY = e.wheelDelta;
            }

            return [deltaX, deltaY];
        }

        function shouldBeConsumedByTextarea(deltaX, deltaY) {
            var hoveredTextarea = element.querySelector('textarea:hover');
            if (hoveredTextarea) {
                var maxScrollTop = hoveredTextarea.scrollHeight - hoveredTextarea.clientHeight;
                if (maxScrollTop > 0) {
                    if (!(hoveredTextarea.scrollTop === 0 && deltaY > 0) &&
                        !(hoveredTextarea.scrollTop === maxScrollTop && deltaY < 0)) {
                        return true;
                    }
                }
                var maxScrollLeft = hoveredTextarea.scrollLeft - hoveredTextarea.clientWidth;
                if (maxScrollLeft > 0) {
                    if (!(hoveredTextarea.scrollLeft === 0 && deltaX < 0) &&
                        !(hoveredTextarea.scrollLeft === maxScrollLeft && deltaX > 0)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function mousewheelHandler(e) {
            // FIXME: this is a quick fix for the select problem in FF and IE.
            // If there comes an effective way to deal with the problem,
            // this lines should be removed.
            if (!h.env.isWebKit && element.querySelector('select:focus')) {
                return;
            }

            var delta = getDeltaFromEvent(e);

            var deltaX = delta[0];
            var deltaY = delta[1];

            if (shouldBeConsumedByTextarea(deltaX, deltaY)) {
                return;
            }

            shouldPrevent = false;
            if (!i.settings.useBothWheelAxes) {
                // deltaX will only be used for horizontal scrolling and deltaY will
                // only be used for vertical scrolling - this is the default
                element.scrollTop = element.scrollTop - (deltaY * i.settings.wheelSpeed);
                element.scrollLeft = element.scrollLeft + (deltaX * i.settings.wheelSpeed);
            } else if (i.scrollbarYActive && !i.scrollbarXActive) {
                // only vertical scrollbar is active and useBothWheelAxes option is
                // active, so let's scroll vertical bar using both mouse wheel axes
                if (deltaY) {
                    element.scrollTop = element.scrollTop - (deltaY * i.settings.wheelSpeed);
                } else {
                    element.scrollTop = element.scrollTop + (deltaX * i.settings.wheelSpeed);
                }
                shouldPrevent = true;
            } else if (i.scrollbarXActive && !i.scrollbarYActive) {
                // useBothWheelAxes and only horizontal bar is active, so use both
                // wheel axes for horizontal bar
                if (deltaX) {
                    element.scrollLeft = element.scrollLeft + (deltaX * i.settings.wheelSpeed);
                } else {
                    element.scrollLeft = element.scrollLeft - (deltaY * i.settings.wheelSpeed);
                }
                shouldPrevent = true;
            }

            updateGeometry(element);

            shouldPrevent = (shouldPrevent || shouldPreventDefault(deltaX, deltaY));
            if (shouldPrevent) {
                e.stopPropagation();
                e.preventDefault();
            }
        }

        if (typeof window.onwheel !== "undefined") {
            i.event.bind(element, 'wheel', mousewheelHandler);
        } else if (typeof window.onmousewheel !== "undefined") {
            i.event.bind(element, 'mousewheel', mousewheelHandler);
        }
    }

    module.exports = function (element) {
        var i = instances.get(element);
        bindMouseWheelHandler(element, i);
    };

},{"../../lib/helper":6,"../instances":18,"../update-geometry":19}],14:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var instances = require('../instances')
        , updateGeometry = require('../update-geometry');

    function bindNativeScrollHandler(element, i) {
        i.event.bind(element, 'scroll', function () {
            updateGeometry(element);
        });
    }

    module.exports = function (element) {
        var i = instances.get(element);
        bindNativeScrollHandler(element, i);
    };

},{"../instances":18,"../update-geometry":19}],15:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var h = require('../../lib/helper')
        , instances = require('../instances')
        , updateGeometry = require('../update-geometry');

    function bindSelectionHandler(element, i) {
        function getRangeNode() {
            var selection = window.getSelection ? window.getSelection() :
                document.getSelection ? document.getSelection() : '';
            if (selection.toString().length === 0) {
                return null;
            } else {
                return selection.getRangeAt(0).commonAncestorContainer;
            }
        }

        var scrollingLoop = null;
        var scrollDiff = {top: 0, left: 0};
        function startScrolling() {
            if (!scrollingLoop) {
                scrollingLoop = setInterval(function () {
                    if (!instances.get(element)) {
                        clearInterval(scrollingLoop);
                        return;
                    }

                    element.scrollTop = element.scrollTop + scrollDiff.top;
                    element.scrollLeft = element.scrollLeft + scrollDiff.left;
                    updateGeometry(element);
                }, 50); // every .1 sec
            }
        }
        function stopScrolling() {
            if (scrollingLoop) {
                clearInterval(scrollingLoop);
                scrollingLoop = null;
            }
            h.stopScrolling(element);
        }

        var isSelected = false;
        i.event.bind(i.ownerDocument, 'selectionchange', function () {
            if (element.contains(getRangeNode())) {
                isSelected = true;
            } else {
                isSelected = false;
                stopScrolling();
            }
        });
        i.event.bind(window, 'mouseup', function () {
            if (isSelected) {
                isSelected = false;
                stopScrolling();
            }
        });

        i.event.bind(window, 'mousemove', function (e) {
            if (isSelected) {
                var mousePosition = {x: e.pageX, y: e.pageY};
                var containerGeometry = {
                    left: element.offsetLeft,
                    right: element.offsetLeft + element.offsetWidth,
                    top: element.offsetTop,
                    bottom: element.offsetTop + element.offsetHeight
                };

                if (mousePosition.x < containerGeometry.left + 3) {
                    scrollDiff.left = -5;
                    h.startScrolling(element, 'x');
                } else if (mousePosition.x > containerGeometry.right - 3) {
                    scrollDiff.left = 5;
                    h.startScrolling(element, 'x');
                } else {
                    scrollDiff.left = 0;
                }

                if (mousePosition.y < containerGeometry.top + 3) {
                    if (containerGeometry.top + 3 - mousePosition.y < 5) {
                        scrollDiff.top = -5;
                    } else {
                        scrollDiff.top = -20;
                    }
                    h.startScrolling(element, 'y');
                } else if (mousePosition.y > containerGeometry.bottom - 3) {
                    if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
                        scrollDiff.top = 5;
                    } else {
                        scrollDiff.top = 20;
                    }
                    h.startScrolling(element, 'y');
                } else {
                    scrollDiff.top = 0;
                }

                if (scrollDiff.top === 0 && scrollDiff.left === 0) {
                    stopScrolling();
                } else {
                    startScrolling();
                }
            }
        });
    }

    module.exports = function (element) {
        var i = instances.get(element);
        bindSelectionHandler(element, i);
    };

},{"../../lib/helper":6,"../instances":18,"../update-geometry":19}],16:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var instances = require('../instances')
        , updateGeometry = require('../update-geometry');

    function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
        function shouldPreventDefault(deltaX, deltaY) {
            var scrollTop = element.scrollTop;
            var scrollLeft = element.scrollLeft;
            var magnitudeX = Math.abs(deltaX);
            var magnitudeY = Math.abs(deltaY);

            if (magnitudeY > magnitudeX) {
                // user is perhaps trying to swipe up/down the page

                if (((deltaY < 0) && (scrollTop === i.contentHeight - i.containerHeight)) ||
                    ((deltaY > 0) && (scrollTop === 0))) {
                    return !i.settings.swipePropagation;
                }
            } else if (magnitudeX > magnitudeY) {
                // user is perhaps trying to swipe left/right across the page

                if (((deltaX < 0) && (scrollLeft === i.contentWidth - i.containerWidth)) ||
                    ((deltaX > 0) && (scrollLeft === 0))) {
                    return !i.settings.swipePropagation;
                }
            }

            return true;
        }

        function applyTouchMove(differenceX, differenceY) {
            element.scrollTop = element.scrollTop - differenceY;
            element.scrollLeft = element.scrollLeft - differenceX;

            updateGeometry(element);
        }

        var startOffset = {};
        var startTime = 0;
        var speed = {};
        var easingLoop = null;
        var inGlobalTouch = false;
        var inLocalTouch = false;

        function globalTouchStart() {
            inGlobalTouch = true;
        }
        function globalTouchEnd() {
            inGlobalTouch = false;
        }

        function getTouch(e) {
            if (e.targetTouches) {
                return e.targetTouches[0];
            } else {
                // Maybe IE pointer
                return e;
            }
        }
        function shouldHandle(e) {
            if (e.targetTouches && e.targetTouches.length === 1) {
                return true;
            }
            if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
                return true;
            }
            return false;
        }
        function touchStart(e) {
            if (shouldHandle(e)) {
                inLocalTouch = true;

                var touch = getTouch(e);

                startOffset.pageX = touch.pageX;
                startOffset.pageY = touch.pageY;

                startTime = (new Date()).getTime();

                if (easingLoop !== null) {
                    clearInterval(easingLoop);
                }

                e.stopPropagation();
            }
        }
        function touchMove(e) {
            if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
                var touch = getTouch(e);

                var currentOffset = {pageX: touch.pageX, pageY: touch.pageY};

                var differenceX = currentOffset.pageX - startOffset.pageX;
                var differenceY = currentOffset.pageY - startOffset.pageY;

                applyTouchMove(differenceX, differenceY);
                startOffset = currentOffset;

                var currentTime = (new Date()).getTime();

                var timeGap = currentTime - startTime;
                if (timeGap > 0) {
                    speed.x = differenceX / timeGap;
                    speed.y = differenceY / timeGap;
                    startTime = currentTime;
                }

                if (shouldPreventDefault(differenceX, differenceY)) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
        }
        function touchEnd() {
            if (!inGlobalTouch && inLocalTouch) {
                inLocalTouch = false;

                clearInterval(easingLoop);
                easingLoop = setInterval(function () {
                    if (!instances.get(element)) {
                        clearInterval(easingLoop);
                        return;
                    }

                    if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
                        clearInterval(easingLoop);
                        return;
                    }

                    applyTouchMove(speed.x * 30, speed.y * 30);

                    speed.x *= 0.8;
                    speed.y *= 0.8;
                }, 10);
            }
        }

        if (supportsTouch) {
            i.event.bind(window, 'touchstart', globalTouchStart);
            i.event.bind(window, 'touchend', globalTouchEnd);
            i.event.bind(element, 'touchstart', touchStart);
            i.event.bind(element, 'touchmove', touchMove);
            i.event.bind(element, 'touchend', touchEnd);
        }

        if (supportsIePointer) {
            if (window.PointerEvent) {
                i.event.bind(window, 'pointerdown', globalTouchStart);
                i.event.bind(window, 'pointerup', globalTouchEnd);
                i.event.bind(element, 'pointerdown', touchStart);
                i.event.bind(element, 'pointermove', touchMove);
                i.event.bind(element, 'pointerup', touchEnd);
            } else if (window.MSPointerEvent) {
                i.event.bind(window, 'MSPointerDown', globalTouchStart);
                i.event.bind(window, 'MSPointerUp', globalTouchEnd);
                i.event.bind(element, 'MSPointerDown', touchStart);
                i.event.bind(element, 'MSPointerMove', touchMove);
                i.event.bind(element, 'MSPointerUp', touchEnd);
            }
        }
    }

    module.exports = function (element, supportsTouch, supportsIePointer) {
        var i = instances.get(element);
        bindTouchHandler(element, i, supportsTouch, supportsIePointer);
    };

},{"../instances":18,"../update-geometry":19}],17:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var cls = require('../lib/class')
        , h = require('../lib/helper')
        , instances = require('./instances')
        , updateGeometry = require('./update-geometry');

// Handlers
    var clickRailHandler = require('./handler/click-rail')
        , dragScrollbarHandler = require('./handler/drag-scrollbar')
        , keyboardHandler = require('./handler/keyboard')
        , mouseWheelHandler = require('./handler/mouse-wheel')
        , nativeScrollHandler = require('./handler/native-scroll')
        , selectionHandler = require('./handler/selection')
        , touchHandler = require('./handler/touch');

    module.exports = function (element, userSettings) {
        userSettings = typeof userSettings === 'object' ? userSettings : {};

        cls.add(element, 'ps-container');

        // Create a plugin instance.
        var i = instances.add(element);

        i.settings = h.extend(i.settings, userSettings);

        clickRailHandler(element);
        dragScrollbarHandler(element);
        mouseWheelHandler(element);
        nativeScrollHandler(element);
        selectionHandler(element);

        if (h.env.supportsTouch || h.env.supportsIePointer) {
            touchHandler(element, h.env.supportsTouch, h.env.supportsIePointer);
        }
        if (i.settings.useKeyboard) {
            keyboardHandler(element);
        }

        updateGeometry(element);
    };

},{"../lib/class":2,"../lib/helper":6,"./handler/click-rail":10,"./handler/drag-scrollbar":11,"./handler/keyboard":12,"./handler/mouse-wheel":13,"./handler/native-scroll":14,"./handler/selection":15,"./handler/touch":16,"./instances":18,"./update-geometry":19}],18:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var d = require('../lib/dom')
        , defaultSettings = require('./default-setting')
        , EventManager = require('../lib/event-manager')
        , guid = require('../lib/guid')
        , h = require('../lib/helper');

    var instances = {};

    function Instance(element) {
        var i = this;

        i.settings = h.clone(defaultSettings);
        i.containerWidth = null;
        i.containerHeight = null;
        i.contentWidth = null;
        i.contentHeight = null;

        i.isRtl = d.css(element, 'direction') === "rtl";
        i.isNegativeScroll = (function () {
            var originalScrollLeft = element.scrollLeft;
            var result = null;
            element.scrollLeft = -1;
            result = element.scrollLeft < 0;
            element.scrollLeft = originalScrollLeft;
            return result;
        })();
        i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
        i.event = new EventManager();
        i.ownerDocument = element.ownerDocument || document;

        i.scrollbarXRail = d.appendTo(d.e('div', 'ps-scrollbar-x-rail'), element);
        i.scrollbarX = d.appendTo(d.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
        i.scrollbarXActive = null;
        i.scrollbarXWidth = null;
        i.scrollbarXLeft = null;
        i.scrollbarXBottom = h.toInt(d.css(i.scrollbarXRail, 'bottom'));
        i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
        i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : h.toInt(d.css(i.scrollbarXRail, 'top'));
        i.railBorderXWidth = h.toInt(d.css(i.scrollbarXRail, 'borderLeftWidth')) + h.toInt(d.css(i.scrollbarXRail, 'borderRightWidth'));
        // Set rail to display:block to calculate margins
        d.css(i.scrollbarXRail, 'display', 'block');
        i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
        d.css(i.scrollbarXRail, 'display', '');
        i.railXWidth = null;
        i.railXRatio = null;

        i.scrollbarYRail = d.appendTo(d.e('div', 'ps-scrollbar-y-rail'), element);
        i.scrollbarY = d.appendTo(d.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
        i.scrollbarYActive = null;
        i.scrollbarYHeight = null;
        i.scrollbarYTop = null;
        i.scrollbarYRight = h.toInt(d.css(i.scrollbarYRail, 'right'));
        i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
        i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : h.toInt(d.css(i.scrollbarYRail, 'left'));
        i.scrollbarYOuterWidth = i.isRtl ? h.outerWidth(i.scrollbarY) : null;
        i.railBorderYWidth = h.toInt(d.css(i.scrollbarYRail, 'borderTopWidth')) + h.toInt(d.css(i.scrollbarYRail, 'borderBottomWidth'));
        d.css(i.scrollbarYRail, 'display', 'block');
        i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));
        d.css(i.scrollbarYRail, 'display', '');
        i.railYHeight = null;
        i.railYRatio = null;
    }

    function getId(element) {
        if (typeof element.dataset === 'undefined') {
            return element.getAttribute('data-ps-id');
        } else {
            return element.dataset.psId;
        }
    }

    function setId(element, id) {
        if (typeof element.dataset === 'undefined') {
            element.setAttribute('data-ps-id', id);
        } else {
            element.dataset.psId = id;
        }
    }

    function removeId(element) {
        if (typeof element.dataset === 'undefined') {
            element.removeAttribute('data-ps-id');
        } else {
            delete element.dataset.psId;
        }
    }

    exports.add = function (element) {
        var newId = guid();
        setId(element, newId);
        instances[newId] = new Instance(element);
        return instances[newId];
    };

    exports.remove = function (element) {
        delete instances[getId(element)];
        removeId(element);
    };

    exports.get = function (element) {
        return instances[getId(element)];
    };

},{"../lib/dom":3,"../lib/event-manager":4,"../lib/guid":5,"../lib/helper":6,"./default-setting":8}],19:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var cls = require('../lib/class')
        , d = require('../lib/dom')
        , h = require('../lib/helper')
        , instances = require('./instances');

    function getThumbSize(i, thumbSize) {
        if (i.settings.minScrollbarLength) {
            thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
        }
        if (i.settings.maxScrollbarLength) {
            thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
        }
        return thumbSize;
    }

    function updateCss(element, i) {
        var xRailOffset = {width: i.railXWidth};
        if (i.isRtl) {
            xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
        } else {
            xRailOffset.left = element.scrollLeft;
        }
        if (i.isScrollbarXUsingBottom) {
            xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
        } else {
            xRailOffset.top = i.scrollbarXTop + element.scrollTop;
        }
        d.css(i.scrollbarXRail, xRailOffset);

        var yRailOffset = {top: element.scrollTop, height: i.railYHeight};
        if (i.isScrollbarYUsingRight) {
            if (i.isRtl) {
                yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth;
            } else {
                yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
            }
        } else {
            if (i.isRtl) {
                yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
            } else {
                yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
            }
        }
        d.css(i.scrollbarYRail, yRailOffset);

        d.css(i.scrollbarX, {left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth});
        d.css(i.scrollbarY, {top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth});
    }

    module.exports = function (element) {
        var i = instances.get(element);

        i.containerWidth = element.clientWidth;
        i.containerHeight = element.clientHeight;
        i.contentWidth = element.scrollWidth;
        i.contentHeight = element.scrollHeight;

        if (!element.contains(i.scrollbarXRail)) {
            d.appendTo(i.scrollbarXRail, element);
        }
        if (!element.contains(i.scrollbarYRail)) {
            d.appendTo(i.scrollbarYRail, element);
        }

        if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
            i.scrollbarXActive = true;
            i.railXWidth = i.containerWidth - i.railXMarginWidth;
            i.railXRatio = i.containerWidth / i.railXWidth;
            i.scrollbarXWidth = getThumbSize(i, h.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
            i.scrollbarXLeft = h.toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
        } else {
            i.scrollbarXActive = false;
            i.scrollbarXWidth = 0;
            i.scrollbarXLeft = 0;
            element.scrollLeft = 0;
        }

        if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
            i.scrollbarYActive = true;
            i.railYHeight = i.containerHeight - i.railYMarginHeight;
            i.railYRatio = i.containerHeight / i.railYHeight;
            i.scrollbarYHeight = getThumbSize(i, h.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
            i.scrollbarYTop = h.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
        } else {
            i.scrollbarYActive = false;
            i.scrollbarYHeight = 0;
            i.scrollbarYTop = 0;
            element.scrollTop = 0;
        }

        if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
            i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
        }
        if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
            i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
        }

        updateCss(element, i);

        cls[i.scrollbarXActive ? 'add' : 'remove'](element, 'ps-active-x');
        cls[i.scrollbarYActive ? 'add' : 'remove'](element, 'ps-active-y');
    };

},{"../lib/class":2,"../lib/dom":3,"../lib/helper":6,"./instances":18}],20:[function(require,module,exports){
    /* Copyright (c) 2015 Hyunje Alex Jun and other contributors
     * Licensed under the MIT License
     */
    'use strict';

    var d = require('../lib/dom')
        , h = require('../lib/helper')
        , instances = require('./instances')
        , updateGeometry = require('./update-geometry');

    module.exports = function (element) {
        var i = instances.get(element);

        if (!i) {
            return;
        }

        // Recalcuate negative scrollLeft adjustment
        i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;

        // Recalculate rail margins
        d.css(i.scrollbarXRail, 'display', 'block');
        d.css(i.scrollbarYRail, 'display', 'block');
        i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
        i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));

        // Hide scrollbars not to affect scrollWidth and scrollHeight
        d.css(i.scrollbarXRail, 'display', 'none');
        d.css(i.scrollbarYRail, 'display', 'none');

        updateGeometry(element);

        d.css(i.scrollbarXRail, 'display', '');
        d.css(i.scrollbarYRail, 'display', '');
    };

},{"../lib/dom":3,"../lib/helper":6,"./instances":18,"./update-geometry":19}]},{},[1]);

/*
 == malihu jquery custom scrollbar plugin ==
 Version: 3.0.9
 Plugin URI: http://manos.malihu.gr/jquery-custom-content-scroller
 Author: malihu
 Author URI: http://manos.malihu.gr
 License: MIT License (MIT)
 */

/*
 Copyright 2010 Manos Malihutsakis (email: manos@malihu.gr)

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */

/*
 The code below is fairly long, fully commented and should be normally used in development.
 For production, use either the minified jquery.mCustomScrollbar.min.js script or
 the production-ready jquery.mCustomScrollbar.concat.min.js which contains the plugin
 and dependencies (minified).
 */

(function(factory){
    if(typeof module!=="undefined" && module.exports){
        module.exports=factory;
    }else{
        factory(jQuery,window,document);
    }
}(function($){
    (function(init){
        var _rjs=typeof define==="function" && define.amd, /* RequireJS */
            _njs=typeof module !== "undefined" && module.exports, /* NodeJS */
            _dlp=("https:"==document.location.protocol) ? "https:" : "http:", /* location protocol */
            _url="cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.12/jquery.mousewheel.min.js";
        if(!_rjs){
            if(_njs){
                require("jquery-mousewheel")($);
            }else{
                /* load jquery-mousewheel plugin (via CDN) if it's not present or not loaded via RequireJS
                 (works when mCustomScrollbar fn is called on window load) */
                $.event.special.mousewheel || $("head").append(decodeURI("%3Cscript src="+_dlp+"//"+_url+"%3E%3C/script%3E"));
            }
        }
        init();
    }(function(){

        /*
         ----------------------------------------
         PLUGIN NAMESPACE, PREFIX, DEFAULT SELECTOR(S)
         ----------------------------------------
         */

        var pluginNS="mCustomScrollbar",
            pluginPfx="mCS",
            defaultSelector=".mCustomScrollbar",





        /*
         ----------------------------------------
         DEFAULT OPTIONS
         ----------------------------------------
         */

            defaults={
                /*
                 set element/content width/height programmatically
                 values: boolean, pixels, percentage
                 option						default
                 -------------------------------------
                 setWidth					false
                 setHeight					false
                 */
                /*
                 set the initial css top property of content
                 values: string (e.g. "-100px", "10%" etc.)
                 */
                setTop:0,
                /*
                 set the initial css left property of content
                 values: string (e.g. "-100px", "10%" etc.)
                 */
                setLeft:0,
                /*
                 scrollbar axis (vertical and/or horizontal scrollbars)
                 values (string): "y", "x", "yx"
                 */
                axis:"y",
                /*
                 position of scrollbar relative to content
                 values (string): "inside", "outside" ("outside" requires elements with position:relative)
                 */
                scrollbarPosition:"inside",
                /*
                 scrolling inertia
                 values: integer (milliseconds)
                 */
                scrollInertia:950,
                /*
                 auto-adjust scrollbar dragger length
                 values: boolean
                 */
                autoDraggerLength:true,
                /*
                 auto-hide scrollbar when idle
                 values: boolean
                 option						default
                 -------------------------------------
                 autoHideScrollbar			false
                 */
                /*
                 auto-expands scrollbar on mouse-over and dragging
                 values: boolean
                 option						default
                 -------------------------------------
                 autoExpandScrollbar			false
                 */
                /*
                 always show scrollbar, even when there's nothing to scroll
                 values: integer (0=disable, 1=always show dragger rail and buttons, 2=always show dragger rail, dragger and buttons), boolean
                 */
                alwaysShowScrollbar:0,
                /*
                 scrolling always snaps to a multiple of this number in pixels
                 values: integer
                 option						default
                 -------------------------------------
                 snapAmount					null
                 */
                /*
                 when snapping, snap with this number in pixels as an offset
                 values: integer
                 */
                snapOffset:0,
                /*
                 mouse-wheel scrolling
                 */
                mouseWheel:{
                    /*
                     enable mouse-wheel scrolling
                     values: boolean
                     */
                    enable:true,
                    /*
                     scrolling amount in pixels
                     values: "auto", integer
                     */
                    scrollAmount:"auto",
                    /*
                     mouse-wheel scrolling axis
                     the default scrolling direction when both vertical and horizontal scrollbars are present
                     values (string): "y", "x"
                     */
                    axis:"y",
                    /*
                     prevent the default behaviour which automatically scrolls the parent element(s) when end of scrolling is reached
                     values: boolean
                     option						default
                     -------------------------------------
                     preventDefault				null
                     */
                    /*
                     the reported mouse-wheel delta value. The number of lines (translated to pixels) one wheel notch scrolls.
                     values: "auto", integer
                     "auto" uses the default OS/browser value
                     */
                    deltaFactor:"auto",
                    /*
                     normalize mouse-wheel delta to -1 or 1 (disables mouse-wheel acceleration)
                     values: boolean
                     option						default
                     -------------------------------------
                     normalizeDelta				null
                     */
                    /*
                     invert mouse-wheel scrolling direction
                     values: boolean
                     option						default
                     -------------------------------------
                     invert						null
                     */
                    /*
                     the tags that disable mouse-wheel when cursor is over them
                     */
                    disableOver:["select","option","keygen","datalist","textarea"]
                },
                /*
                 scrollbar buttons
                 */
                scrollButtons:{
                    /*
                     enable scrollbar buttons
                     values: boolean
                     option						default
                     -------------------------------------
                     enable						null
                     */
                    /*
                     scrollbar buttons scrolling type
                     values (string): "stepless", "stepped"
                     */
                    scrollType:"stepless",
                    /*
                     scrolling amount in pixels
                     values: "auto", integer
                     */
                    scrollAmount:"auto"
                    /*
                     tabindex of the scrollbar buttons
                     values: false, integer
                     option						default
                     -------------------------------------
                     tabindex					null
                     */
                },
                /*
                 keyboard scrolling
                 */
                keyboard:{
                    /*
                     enable scrolling via keyboard
                     values: boolean
                     */
                    enable:true,
                    /*
                     keyboard scrolling type
                     values (string): "stepless", "stepped"
                     */
                    scrollType:"stepless",
                    /*
                     scrolling amount in pixels
                     values: "auto", integer
                     */
                    scrollAmount:"auto"
                },
                /*
                 enable content touch-swipe scrolling
                 values: boolean, integer, string (number)
                 integer values define the axis-specific minimum amount required for scrolling momentum
                 */
                contentTouchScroll:25,
                /*
                 advanced option parameters
                 */
                advanced:{
                    /*
                     auto-expand content horizontally (for "x" or "yx" axis)
                     values: boolean
                     option						default
                     -------------------------------------
                     autoExpandHorizontalScroll	null
                     */
                    /*
                     auto-scroll to elements with focus
                     */
                    autoScrollOnFocus:"input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
                    /*
                     auto-update scrollbars on content, element or viewport resize
                     should be true for fluid layouts/elements, adding/removing content dynamically, hiding/showing elements, content with images etc.
                     values: boolean
                     */
                    updateOnContentResize:true,
                    /*
                     auto-update scrollbars each time each image inside the element is fully loaded
                     values: boolean
                     */
                    updateOnImageLoad:true,
                    /*
                     auto-update scrollbars based on the amount and size changes of specific selectors
                     useful when you need to update the scrollbar(s) automatically, each time a type of element is added, removed or changes its size
                     values: boolean, string (e.g. "ul li" will auto-update scrollbars each time list-items inside the element are changed)
                     a value of true (boolean) will auto-update scrollbars each time any element is changed
                     option						default
                     -------------------------------------
                     updateOnSelectorChange		null
                     */
                    /*
                     extra selectors that'll release scrollbar dragging upon mouseup, pointerup, touchend etc. (e.g. "selector-1, selector-2")
                     option						default
                     -------------------------------------
                     releaseDraggableSelectors	null
                     */
                    /*
                     auto-update timeout
                     values: integer (milliseconds)
                     */
                    autoUpdateTimeout:60
                },
                /*
                 scrollbar theme
                 values: string (see CSS/plugin URI for a list of ready-to-use themes)
                 */
                theme:"light",
                /*
                 user defined callback functions
                 */
                callbacks:{
                    /*
                     Available callbacks:
                     callback					default
                     -------------------------------------
                     onInit						null
                     onScrollStart				null
                     onScroll					null
                     onTotalScroll				null
                     onTotalScrollBack			null
                     whileScrolling				null
                     onOverflowY					null
                     onOverflowX					null
                     onOverflowYNone				null
                     onOverflowXNone				null
                     onImageLoad					null
                     onSelectorChange			null
                     onUpdate					null
                     */
                    onTotalScrollOffset:0,
                    onTotalScrollBackOffset:0,
                    alwaysTriggerOffsets:true
                }
                /*
                 add scrollbar(s) on all elements matching the current selector, now and in the future
                 values: boolean, string
                 string values: "on" (enable), "once" (disable after first invocation), "off" (disable)
                 liveSelector values: string (selector)
                 option						default
                 -------------------------------------
                 live						false
                 liveSelector				null
                 */
            },





        /*
         ----------------------------------------
         VARS, CONSTANTS
         ----------------------------------------
         */

            totalInstances=0, /* plugin instances amount */
            liveTimers={}, /* live option timers */
            oldIE=(window.attachEvent && !window.addEventListener) ? 1 : 0, /* detect IE < 9 */
            touchActive=false,touchable, /* global touch vars (for touch and pointer events) */
        /* general plugin classes */
            classes=[
                "mCSB_dragger_onDrag","mCSB_scrollTools_onDrag","mCS_img_loaded","mCS_disabled","mCS_destroyed","mCS_no_scrollbar",
                "mCS-autoHide","mCS-dir-rtl","mCS_no_scrollbar_y","mCS_no_scrollbar_x","mCS_y_hidden","mCS_x_hidden","mCSB_draggerContainer",
                "mCSB_buttonUp","mCSB_buttonDown","mCSB_buttonLeft","mCSB_buttonRight"
            ],





        /*
         ----------------------------------------
         METHODS
         ----------------------------------------
         */

            methods={

                /*
                 plugin initialization method
                 creates the scrollbar(s), plugin data object and options
                 ----------------------------------------
                 */

                init:function(options){

                    var options=$.extend(true,{},defaults,options),
                        selector=_selector.call(this); /* validate selector */

                    /*
                     if live option is enabled, monitor for elements matching the current selector and
                     apply scrollbar(s) when found (now and in the future)
                     */
                    if(options.live){
                        var liveSelector=options.liveSelector || this.selector || defaultSelector, /* live selector(s) */
                            $liveSelector=$(liveSelector); /* live selector(s) as jquery object */
                        if(options.live==="off"){
                            /*
                             disable live if requested
                             usage: $(selector).mCustomScrollbar({live:"off"});
                             */
                            removeLiveTimers(liveSelector);
                            return;
                        }
                        liveTimers[liveSelector]=setTimeout(function(){
                            /* call mCustomScrollbar fn on live selector(s) every half-second */
                            $liveSelector.mCustomScrollbar(options);
                            if(options.live==="once" && $liveSelector.length){
                                /* disable live after first invocation */
                                removeLiveTimers(liveSelector);
                            }
                        },500);
                    }else{
                        removeLiveTimers(liveSelector);
                    }

                    /* options backward compatibility (for versions < 3.0.0) and normalization */
                    options.setWidth=(options.set_width) ? options.set_width : options.setWidth;
                    options.setHeight=(options.set_height) ? options.set_height : options.setHeight;
                    options.axis=(options.horizontalScroll) ? "x" : _findAxis(options.axis);
                    options.scrollInertia=options.scrollInertia>0 && options.scrollInertia<17 ? 17 : options.scrollInertia;
                    if(typeof options.mouseWheel!=="object" &&  options.mouseWheel==true){ /* old school mouseWheel option (non-object) */
                        options.mouseWheel={enable:true,scrollAmount:"auto",axis:"y",preventDefault:false,deltaFactor:"auto",normalizeDelta:false,invert:false}
                    }
                    options.mouseWheel.scrollAmount=!options.mouseWheelPixels ? options.mouseWheel.scrollAmount : options.mouseWheelPixels;
                    options.mouseWheel.normalizeDelta=!options.advanced.normalizeMouseWheelDelta ? options.mouseWheel.normalizeDelta : options.advanced.normalizeMouseWheelDelta;
                    options.scrollButtons.scrollType=_findScrollButtonsType(options.scrollButtons.scrollType);

                    _theme(options); /* theme-specific options */

                    /* plugin constructor */
                    return $(selector).each(function(){

                        var $this=$(this);

                        if(!$this.data(pluginPfx)){ /* prevent multiple instantiations */

                            /* store options and create objects in jquery data */
                            $this.data(pluginPfx,{
                                idx:++totalInstances, /* instance index */
                                opt:options, /* options */
                                scrollRatio:{y:null,x:null}, /* scrollbar to content ratio */
                                overflowed:null, /* overflowed axis */
                                contentReset:{y:null,x:null}, /* object to check when content resets */
                                bindEvents:false, /* object to check if events are bound */
                                tweenRunning:false, /* object to check if tween is running */
                                sequential:{}, /* sequential scrolling object */
                                langDir:$this.css("direction"), /* detect/store direction (ltr or rtl) */
                                cbOffsets:null, /* object to check whether callback offsets always trigger */
                                /*
                                 object to check how scrolling events where last triggered
                                 "internal" (default - triggered by this script), "external" (triggered by other scripts, e.g. via scrollTo method)
                                 usage: object.data("mCS").trigger
                                 */
                                trigger:null
                            });

                            var d=$this.data(pluginPfx),o=d.opt,
                            /* HTML data attributes */
                                htmlDataAxis=$this.data("mcs-axis"),htmlDataSbPos=$this.data("mcs-scrollbar-position"),htmlDataTheme=$this.data("mcs-theme");

                            if(htmlDataAxis){o.axis=htmlDataAxis;} /* usage example: data-mcs-axis="y" */
                            if(htmlDataSbPos){o.scrollbarPosition=htmlDataSbPos;} /* usage example: data-mcs-scrollbar-position="outside" */
                            if(htmlDataTheme){ /* usage example: data-mcs-theme="minimal" */
                                o.theme=htmlDataTheme;
                                _theme(o); /* theme-specific options */
                            }

                            _pluginMarkup.call(this); /* add plugin markup */

                            $("#mCSB_"+d.idx+"_container img:not(."+classes[2]+")").addClass(classes[2]); /* flag loaded images */

                            methods.update.call(null,$this); /* call the update method */

                        }

                    });

                },
                /* ---------------------------------------- */



                /*
                 plugin update method
                 updates content and scrollbar(s) values, events and status
                 ----------------------------------------
                 usage: $(selector).mCustomScrollbar("update");
                 */

                update:function(el,cb){

                    var selector=el || _selector.call(this); /* validate selector */

                    return $(selector).each(function(){

                        var $this=$(this);

                        if($this.data(pluginPfx)){ /* check if plugin has initialized */

                            var d=$this.data(pluginPfx),o=d.opt,
                                mCSB_container=$("#mCSB_"+d.idx+"_container"),
                                mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];

                            if(!mCSB_container.length){return;}

                            if(d.tweenRunning){_stop($this);} /* stop any running tweens while updating */

                            /* if element was disabled or destroyed, remove class(es) */
                            if($this.hasClass(classes[3])){$this.removeClass(classes[3]);}
                            if($this.hasClass(classes[4])){$this.removeClass(classes[4]);}

                            _maxHeight.call(this); /* detect/set css max-height value */

                            _expandContentHorizontally.call(this); /* expand content horizontally */

                            if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
                                mCSB_container.css("width",_contentWidth(mCSB_container.children()));
                            }

                            d.overflowed=_overflowed.call(this); /* determine if scrolling is required */

                            _scrollbarVisibility.call(this); /* show/hide scrollbar(s) */

                            /* auto-adjust scrollbar dragger length analogous to content */
                            if(o.autoDraggerLength){_setDraggerLength.call(this);}

                            _scrollRatio.call(this); /* calculate and store scrollbar to content ratio */

                            _bindEvents.call(this); /* bind scrollbar events */

                            /* reset scrolling position and/or events */
                            var to=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)];
                            if(o.axis!=="x"){ /* y/yx axis */
                                if(!d.overflowed[0]){ /* y scrolling is not required */
                                    _resetContentPosition.call(this); /* reset content position */
                                    if(o.axis==="y"){
                                        _unbindEvents.call(this);
                                    }else if(o.axis==="yx" && d.overflowed[1]){
                                        _scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
                                    }
                                }else if(mCSB_dragger[0].height()>mCSB_dragger[0].parent().height()){
                                    _resetContentPosition.call(this); /* reset content position */
                                }else{ /* y scrolling is required */
                                    _scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
                                    d.contentReset.y=null;
                                }
                            }
                            if(o.axis!=="y"){ /* x/yx axis */
                                if(!d.overflowed[1]){ /* x scrolling is not required */
                                    _resetContentPosition.call(this); /* reset content position */
                                    if(o.axis==="x"){
                                        _unbindEvents.call(this);
                                    }else if(o.axis==="yx" && d.overflowed[0]){
                                        _scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
                                    }
                                }else if(mCSB_dragger[1].width()>mCSB_dragger[1].parent().width()){
                                    _resetContentPosition.call(this); /* reset content position */
                                }else{ /* x scrolling is required */
                                    _scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
                                    d.contentReset.x=null;
                                }
                            }

                            /* callbacks: onImageLoad, onSelectorChange, onUpdate */
                            if(cb && d){
                                if(cb===2 && o.callbacks.onImageLoad && typeof o.callbacks.onImageLoad==="function"){
                                    o.callbacks.onImageLoad.call(this);
                                }else if(cb===3 && o.callbacks.onSelectorChange && typeof o.callbacks.onSelectorChange==="function"){
                                    o.callbacks.onSelectorChange.call(this);
                                }else if(o.callbacks.onUpdate && typeof o.callbacks.onUpdate==="function"){
                                    o.callbacks.onUpdate.call(this);
                                }
                            }

                            _autoUpdate.call(this); /* initialize automatic updating (for dynamic content, fluid layouts etc.) */

                        }

                    });

                },
                /* ---------------------------------------- */



                /*
                 plugin scrollTo method
                 triggers a scrolling event to a specific value
                 ----------------------------------------
                 usage: $(selector).mCustomScrollbar("scrollTo",value,options);
                 */

                scrollTo:function(val,options){

                    /* prevent silly things like $(selector).mCustomScrollbar("scrollTo",undefined); */
                    if(typeof val=="undefined" || val==null){return;}

                    var selector=_selector.call(this); /* validate selector */

                    return $(selector).each(function(){

                        var $this=$(this);

                        if($this.data(pluginPfx)){ /* check if plugin has initialized */

                            var d=$this.data(pluginPfx),o=d.opt,
                            /* method default options */
                                methodDefaults={
                                    trigger:"external", /* method is by default triggered externally (e.g. from other scripts) */
                                    scrollInertia:o.scrollInertia, /* scrolling inertia (animation duration) */
                                    scrollEasing:"mcsEaseInOut", /* animation easing */
                                    moveDragger:false, /* move dragger instead of content */
                                    timeout:60, /* scroll-to delay */
                                    callbacks:true, /* enable/disable callbacks */
                                    onStart:true,
                                    onUpdate:true,
                                    onComplete:true
                                },
                                methodOptions=$.extend(true,{},methodDefaults,options),
                                to=_arr.call(this,val),dur=methodOptions.scrollInertia>0 && methodOptions.scrollInertia<17 ? 17 : methodOptions.scrollInertia;

                            /* translate yx values to actual scroll-to positions */
                            to[0]=_to.call(this,to[0],"y");
                            to[1]=_to.call(this,to[1],"x");

                            /*
                             check if scroll-to value moves the dragger instead of content.
                             Only pixel values apply on dragger (e.g. 100, "100px", "-=100" etc.)
                             */
                            if(methodOptions.moveDragger){
                                to[0]*=d.scrollRatio.y;
                                to[1]*=d.scrollRatio.x;
                            }

                            methodOptions.dur=dur;

                            setTimeout(function(){
                                /* do the scrolling */
                                if(to[0]!==null && typeof to[0]!=="undefined" && o.axis!=="x" && d.overflowed[0]){ /* scroll y */
                                    methodOptions.dir="y";
                                    methodOptions.overwrite="all";
                                    _scrollTo($this,to[0].toString(),methodOptions);
                                }
                                if(to[1]!==null && typeof to[1]!=="undefined" && o.axis!=="y" && d.overflowed[1]){ /* scroll x */
                                    methodOptions.dir="x";
                                    methodOptions.overwrite="none";
                                    _scrollTo($this,to[1].toString(),methodOptions);
                                }
                            },methodOptions.timeout);

                        }

                    });

                },
                /* ---------------------------------------- */



                /*
                 plugin stop method
                 stops scrolling animation
                 ----------------------------------------
                 usage: $(selector).mCustomScrollbar("stop");
                 */
                stop:function(){

                    var selector=_selector.call(this); /* validate selector */

                    return $(selector).each(function(){

                        var $this=$(this);

                        if($this.data(pluginPfx)){ /* check if plugin has initialized */

                            _stop($this);

                        }

                    });

                },
                /* ---------------------------------------- */



                /*
                 plugin disable method
                 temporarily disables the scrollbar(s)
                 ----------------------------------------
                 usage: $(selector).mCustomScrollbar("disable",reset);
                 reset (boolean): resets content position to 0
                 */
                disable:function(r){

                    var selector=_selector.call(this); /* validate selector */

                    return $(selector).each(function(){

                        var $this=$(this);

                        if($this.data(pluginPfx)){ /* check if plugin has initialized */

                            var d=$this.data(pluginPfx);

                            _autoUpdate.call(this,"remove"); /* remove automatic updating */

                            _unbindEvents.call(this); /* unbind events */

                            if(r){_resetContentPosition.call(this);} /* reset content position */

                            _scrollbarVisibility.call(this,true); /* show/hide scrollbar(s) */

                            $this.addClass(classes[3]); /* add disable class */

                        }

                    });

                },
                /* ---------------------------------------- */



                /*
                 plugin destroy method
                 completely removes the scrollbar(s) and returns the element to its original state
                 ----------------------------------------
                 usage: $(selector).mCustomScrollbar("destroy");
                 */
                destroy:function(){

                    var selector=_selector.call(this); /* validate selector */

                    return $(selector).each(function(){

                        var $this=$(this);

                        if($this.data(pluginPfx)){ /* check if plugin has initialized */

                            var d=$this.data(pluginPfx),o=d.opt,
                                mCustomScrollBox=$("#mCSB_"+d.idx),
                                mCSB_container=$("#mCSB_"+d.idx+"_container"),
                                scrollbar=$(".mCSB_"+d.idx+"_scrollbar");

                            if(o.live){removeLiveTimers(o.liveSelector || $(selector).selector);} /* remove live timers */

                            _autoUpdate.call(this,"remove"); /* remove automatic updating */

                            _unbindEvents.call(this); /* unbind events */

                            _resetContentPosition.call(this); /* reset content position */

                            $this.removeData(pluginPfx); /* remove plugin data object */

                            _delete(this,"mcs"); /* delete callbacks object */

                            /* remove plugin markup */
                            scrollbar.remove(); /* remove scrollbar(s) first (those can be either inside or outside plugin's inner wrapper) */
                            mCSB_container.find("img."+classes[2]).removeClass(classes[2]); /* remove loaded images flag */
                            mCustomScrollBox.replaceWith(mCSB_container.contents()); /* replace plugin's inner wrapper with the original content */
                            /* remove plugin classes from the element and add destroy class */
                            $this.removeClass(pluginNS+" _"+pluginPfx+"_"+d.idx+" "+classes[6]+" "+classes[7]+" "+classes[5]+" "+classes[3]).addClass(classes[4]);

                        }

                    });

                }
                /* ---------------------------------------- */

            },





        /*
         ----------------------------------------
         FUNCTIONS
         ----------------------------------------
         */

        /* validates selector (if selector is invalid or undefined uses the default one) */
            _selector=function(){
                return (typeof $(this)!=="object" || $(this).length<1) ? defaultSelector : this;
            },
        /* -------------------- */


        /* changes options according to theme */
            _theme=function(obj){
                var fixedSizeScrollbarThemes=["rounded","rounded-dark","rounded-dots","rounded-dots-dark"],
                    nonExpandedScrollbarThemes=["rounded-dots","rounded-dots-dark","3d","3d-dark","3d-thick","3d-thick-dark","inset","inset-dark","inset-2","inset-2-dark","inset-3","inset-3-dark"],
                    disabledScrollButtonsThemes=["minimal","minimal-dark"],
                    enabledAutoHideScrollbarThemes=["minimal","minimal-dark"],
                    scrollbarPositionOutsideThemes=["minimal","minimal-dark"];
                obj.autoDraggerLength=$.inArray(obj.theme,fixedSizeScrollbarThemes) > -1 ? false : obj.autoDraggerLength;
                obj.autoExpandScrollbar=$.inArray(obj.theme,nonExpandedScrollbarThemes) > -1 ? false : obj.autoExpandScrollbar;
                obj.scrollButtons.enable=$.inArray(obj.theme,disabledScrollButtonsThemes) > -1 ? false : obj.scrollButtons.enable;
                obj.autoHideScrollbar=$.inArray(obj.theme,enabledAutoHideScrollbarThemes) > -1 ? true : obj.autoHideScrollbar;
                obj.scrollbarPosition=$.inArray(obj.theme,scrollbarPositionOutsideThemes) > -1 ? "outside" : obj.scrollbarPosition;
            },
        /* -------------------- */


        /* live option timers removal */
            removeLiveTimers=function(selector){
                if(liveTimers[selector]){
                    clearTimeout(liveTimers[selector]);
                    _delete(liveTimers,selector);
                }
            },
        /* -------------------- */


        /* normalizes axis option to valid values: "y", "x", "yx" */
            _findAxis=function(val){
                return (val==="yx" || val==="xy" || val==="auto") ? "yx" : (val==="x" || val==="horizontal") ? "x" : "y";
            },
        /* -------------------- */


        /* normalizes scrollButtons.scrollType option to valid values: "stepless", "stepped" */
            _findScrollButtonsType=function(val){
                return (val==="stepped" || val==="pixels" || val==="step" || val==="click") ? "stepped" : "stepless";
            },
        /* -------------------- */


        /* generates plugin markup */
            _pluginMarkup=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    expandClass=o.autoExpandScrollbar ? " "+classes[1]+"_expand" : "",
                    scrollbar=["<div id='mCSB_"+d.idx+"_scrollbar_vertical' class='mCSB_scrollTools mCSB_"+d.idx+"_scrollbar mCS-"+o.theme+" mCSB_scrollTools_vertical"+expandClass+"'><div class='"+classes[12]+"'><div id='mCSB_"+d.idx+"_dragger_vertical' class='mCSB_dragger' style='position:absolute;' oncontextmenu='return false;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>","<div id='mCSB_"+d.idx+"_scrollbar_horizontal' class='mCSB_scrollTools mCSB_"+d.idx+"_scrollbar mCS-"+o.theme+" mCSB_scrollTools_horizontal"+expandClass+"'><div class='"+classes[12]+"'><div id='mCSB_"+d.idx+"_dragger_horizontal' class='mCSB_dragger' style='position:absolute;' oncontextmenu='return false;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
                    wrapperClass=o.axis==="yx" ? "mCSB_vertical_horizontal" : o.axis==="x" ? "mCSB_horizontal" : "mCSB_vertical",
                    scrollbars=o.axis==="yx" ? scrollbar[0]+scrollbar[1] : o.axis==="x" ? scrollbar[1] : scrollbar[0],
                    contentWrapper=o.axis==="yx" ? "<div id='mCSB_"+d.idx+"_container_wrapper' class='mCSB_container_wrapper' />" : "",
                    autoHideClass=o.autoHideScrollbar ? " "+classes[6] : "",
                    scrollbarDirClass=(o.axis!=="x" && d.langDir==="rtl") ? " "+classes[7] : "";
                if(o.setWidth){$this.css("width",o.setWidth);} /* set element width */
                if(o.setHeight){$this.css("height",o.setHeight);} /* set element height */
                o.setLeft=(o.axis!=="y" && d.langDir==="rtl") ? "989999px" : o.setLeft; /* adjust left position for rtl direction */
                $this.addClass(pluginNS+" _"+pluginPfx+"_"+d.idx+autoHideClass+scrollbarDirClass).wrapInner("<div id='mCSB_"+d.idx+"' class='mCustomScrollBox mCS-"+o.theme+" "+wrapperClass+"'><div id='mCSB_"+d.idx+"_container' class='mCSB_container' style='position:relative; top:"+o.setTop+"; left:"+o.setLeft+";' dir="+d.langDir+" /></div>");
                var mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container");
                if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
                    mCSB_container.css("width",_contentWidth(mCSB_container.children()));
                }
                if(o.scrollbarPosition==="outside"){
                    if($this.css("position")==="static"){ /* requires elements with non-static position */
                        $this.css("position","relative");
                    }
                    $this.css("overflow","visible");
                    mCustomScrollBox.addClass("mCSB_outside").after(scrollbars);
                }else{
                    mCustomScrollBox.addClass("mCSB_inside").append(scrollbars);
                    mCSB_container.wrap(contentWrapper);
                }
                _scrollButtons.call(this); /* add scrollbar buttons */
                /* minimum dragger length */
                var mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
                mCSB_dragger[0].css("min-height",mCSB_dragger[0].height());
                mCSB_dragger[1].css("min-width",mCSB_dragger[1].width());
            },
        /* -------------------- */


        /* calculates content width */
            _contentWidth=function(el){
                return Math.max.apply(Math,el.map(function(){return $(this).outerWidth(true);}).get());
            },
        /* -------------------- */


        /* expands content horizontally */
            _expandContentHorizontally=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCSB_container=$("#mCSB_"+d.idx+"_container");
                if(o.advanced.autoExpandHorizontalScroll && o.axis!=="y"){
                    /*
                     wrap content with an infinite width div and set its position to absolute and width to auto.
                     Setting width to auto before calculating the actual width is important!
                     We must let the browser set the width as browser zoom values are impossible to calculate.
                     */
                    mCSB_container.css({"position":"absolute","width":"auto"})
                        .wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />")
                        .css({ /* set actual width, original position and un-wrap */
                            /*
                             get the exact width (with decimals) and then round-up.
                             Using jquery outerWidth() will round the width value which will mess up with inner elements that have non-integer width
                             */
                            "width":(Math.ceil(mCSB_container[0].getBoundingClientRect().right+0.4)-Math.floor(mCSB_container[0].getBoundingClientRect().left)),
                            "position":"relative"
                        }).unwrap();
                }
            },
        /* -------------------- */


        /* adds scrollbar buttons */
            _scrollButtons=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCSB_scrollTools=$(".mCSB_"+d.idx+"_scrollbar:first"),
                    tabindex=!_isNumeric(o.scrollButtons.tabindex) ? "" : "tabindex='"+o.scrollButtons.tabindex+"'",
                    btnHTML=[
                        "<a href='#' class='"+classes[13]+"' oncontextmenu='return false;' "+tabindex+" />",
                        "<a href='#' class='"+classes[14]+"' oncontextmenu='return false;' "+tabindex+" />",
                        "<a href='#' class='"+classes[15]+"' oncontextmenu='return false;' "+tabindex+" />",
                        "<a href='#' class='"+classes[16]+"' oncontextmenu='return false;' "+tabindex+" />"
                    ],
                    btn=[(o.axis==="x" ? btnHTML[2] : btnHTML[0]),(o.axis==="x" ? btnHTML[3] : btnHTML[1]),btnHTML[2],btnHTML[3]];
                if(o.scrollButtons.enable){
                    mCSB_scrollTools.prepend(btn[0]).append(btn[1]).next(".mCSB_scrollTools").prepend(btn[2]).append(btn[3]);
                }
            },
        /* -------------------- */


        /* detects/sets css max-height value */
            _maxHeight=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mh=$this.css("max-height") || "none",pct=mh.indexOf("%")!==-1,
                    bs=$this.css("box-sizing");
                if(mh!=="none"){
                    var val=pct ? $this.parent().height()*parseInt(mh)/100 : parseInt(mh);
                    /* if element's css box-sizing is "border-box", subtract any paddings and/or borders from max-height value */
                    if(bs==="border-box"){val-=(($this.innerHeight()-$this.height())+($this.outerHeight()-$this.innerHeight()));}
                    mCustomScrollBox.css("max-height",Math.round(val));
                }
            },
        /* -------------------- */


        /* auto-adjusts scrollbar dragger length */
            _setDraggerLength=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
                    ratio=[mCustomScrollBox.height()/mCSB_container.outerHeight(false),mCustomScrollBox.width()/mCSB_container.outerWidth(false)],
                    l=[
                        parseInt(mCSB_dragger[0].css("min-height")),Math.round(ratio[0]*mCSB_dragger[0].parent().height()),
                        parseInt(mCSB_dragger[1].css("min-width")),Math.round(ratio[1]*mCSB_dragger[1].parent().width())
                    ],
                    h=oldIE && (l[1]<l[0]) ? l[0] : l[1],w=oldIE && (l[3]<l[2]) ? l[2] : l[3];
                mCSB_dragger[0].css({
                    "height":h,"max-height":(mCSB_dragger[0].parent().height()-10)
                }).find(".mCSB_dragger_bar").css({"line-height":l[0]+"px"});
                mCSB_dragger[1].css({
                    "width":w,"max-width":(mCSB_dragger[1].parent().width()-10)
                });
            },
        /* -------------------- */


        /* calculates scrollbar to content ratio */
            _scrollRatio=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
                    scrollAmount=[mCSB_container.outerHeight(false)-mCustomScrollBox.height(),mCSB_container.outerWidth(false)-mCustomScrollBox.width()],
                    ratio=[
                        scrollAmount[0]/(mCSB_dragger[0].parent().height()-mCSB_dragger[0].height()),
                        scrollAmount[1]/(mCSB_dragger[1].parent().width()-mCSB_dragger[1].width())
                    ];
                d.scrollRatio={y:ratio[0],x:ratio[1]};
            },
        /* -------------------- */


        /* toggles scrolling classes */
            _onDragClasses=function(el,action,xpnd){
                var expandClass=xpnd ? classes[0]+"_expanded" : "",
                    scrollbar=el.closest(".mCSB_scrollTools");
                if(action==="active"){
                    el.toggleClass(classes[0]+" "+expandClass); scrollbar.toggleClass(classes[1]);
                    el[0]._draggable=el[0]._draggable ? 0 : 1;
                }else{
                    if(!el[0]._draggable){
                        if(action==="hide"){
                            el.removeClass(classes[0]); scrollbar.removeClass(classes[1]);
                        }else{
                            el.addClass(classes[0]); scrollbar.addClass(classes[1]);
                        }
                    }
                }
            },
        /* -------------------- */


        /* checks if content overflows its container to determine if scrolling is required */
            _overflowed=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    contentHeight=d.overflowed==null ? mCSB_container.height() : mCSB_container.outerHeight(false),
                    contentWidth=d.overflowed==null ? mCSB_container.width() : mCSB_container.outerWidth(false);
                return [contentHeight>mCustomScrollBox.height(),contentWidth>mCustomScrollBox.width()];
            },
        /* -------------------- */


        /* resets content position to 0 */
            _resetContentPosition=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
                _stop($this); /* stop any current scrolling before resetting */
                if((o.axis!=="x" && !d.overflowed[0]) || (o.axis==="y" && d.overflowed[0])){ /* reset y */
                    mCSB_dragger[0].add(mCSB_container).css("top",0);
                    _scrollTo($this,"_resetY");
                }
                if((o.axis!=="y" && !d.overflowed[1]) || (o.axis==="x" && d.overflowed[1])){ /* reset x */
                    var cx=dx=0;
                    if(d.langDir==="rtl"){ /* adjust left position for rtl direction */
                        cx=mCustomScrollBox.width()-mCSB_container.outerWidth(false);
                        dx=Math.abs(cx/d.scrollRatio.x);
                    }
                    mCSB_container.css("left",cx);
                    mCSB_dragger[1].css("left",dx);
                    _scrollTo($this,"_resetX");
                }
            },
        /* -------------------- */


        /* binds scrollbar events */
            _bindEvents=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt;
                if(!d.bindEvents){ /* check if events are already bound */
                    _draggable.call(this);
                    if(o.contentTouchScroll){_contentDraggable.call(this);}
                    _selectable.call(this);
                    if(o.mouseWheel.enable){ /* bind mousewheel fn when plugin is available */
                        function _mwt(){
                            mousewheelTimeout=setTimeout(function(){
                                if(!$.event.special.mousewheel){
                                    _mwt();
                                }else{
                                    clearTimeout(mousewheelTimeout);
                                    _mousewheel.call($this[0]);
                                }
                            },100);
                        }
                        var mousewheelTimeout;
                        _mwt();
                    }
                    _draggerRail.call(this);
                    _wrapperScroll.call(this);
                    if(o.advanced.autoScrollOnFocus){_focus.call(this);}
                    if(o.scrollButtons.enable){_buttons.call(this);}
                    if(o.keyboard.enable){_keyboard.call(this);}
                    d.bindEvents=true;
                }
            },
        /* -------------------- */


        /* unbinds scrollbar events */
            _unbindEvents=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    namespace=pluginPfx+"_"+d.idx,
                    sb=".mCSB_"+d.idx+"_scrollbar",
                    sel=$("#mCSB_"+d.idx+",#mCSB_"+d.idx+"_container,#mCSB_"+d.idx+"_container_wrapper,"+sb+" ."+classes[12]+",#mCSB_"+d.idx+"_dragger_vertical,#mCSB_"+d.idx+"_dragger_horizontal,"+sb+">a"),
                    mCSB_container=$("#mCSB_"+d.idx+"_container");
                if(o.advanced.releaseDraggableSelectors){sel.add($(o.advanced.releaseDraggableSelectors));}
                if(d.bindEvents){ /* check if events are bound */
                    /* unbind namespaced events from document/selectors */
                    $(document).unbind("."+namespace);
                    sel.each(function(){
                        $(this).unbind("."+namespace);
                    });
                    /* clear and delete timeouts/objects */
                    clearTimeout($this[0]._focusTimeout); _delete($this[0],"_focusTimeout");
                    clearTimeout(d.sequential.step); _delete(d.sequential,"step");
                    clearTimeout(mCSB_container[0].onCompleteTimeout); _delete(mCSB_container[0],"onCompleteTimeout");
                    d.bindEvents=false;
                }
            },
        /* -------------------- */


        /* toggles scrollbar visibility */
            _scrollbarVisibility=function(disabled){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    contentWrapper=$("#mCSB_"+d.idx+"_container_wrapper"),
                    content=contentWrapper.length ? contentWrapper : $("#mCSB_"+d.idx+"_container"),
                    scrollbar=[$("#mCSB_"+d.idx+"_scrollbar_vertical"),$("#mCSB_"+d.idx+"_scrollbar_horizontal")],
                    mCSB_dragger=[scrollbar[0].find(".mCSB_dragger"),scrollbar[1].find(".mCSB_dragger")];
                if(o.axis!=="x"){
                    if(d.overflowed[0] && !disabled){
                        scrollbar[0].add(mCSB_dragger[0]).add(scrollbar[0].children("a")).css("display","block");
                        content.removeClass(classes[8]+" "+classes[10]);
                    }else{
                        if(o.alwaysShowScrollbar){
                            if(o.alwaysShowScrollbar!==2){mCSB_dragger[0].css("display","none");}
                            content.removeClass(classes[10]);
                        }else{
                            scrollbar[0].css("display","none");
                            content.addClass(classes[10]);
                        }
                        content.addClass(classes[8]);
                    }
                }
                if(o.axis!=="y"){
                    if(d.overflowed[1] && !disabled){
                        scrollbar[1].add(mCSB_dragger[1]).add(scrollbar[1].children("a")).css("display","block");
                        content.removeClass(classes[9]+" "+classes[11]);
                    }else{
                        if(o.alwaysShowScrollbar){
                            if(o.alwaysShowScrollbar!==2){mCSB_dragger[1].css("display","none");}
                            content.removeClass(classes[11]);
                        }else{
                            scrollbar[1].css("display","none");
                            content.addClass(classes[11]);
                        }
                        content.addClass(classes[9]);
                    }
                }
                if(!d.overflowed[0] && !d.overflowed[1]){
                    $this.addClass(classes[5]);
                }else{
                    $this.removeClass(classes[5]);
                }
            },
        /* -------------------- */


        /* returns input coordinates of pointer, touch and mouse events (relative to document) */
            _coordinates=function(e){
                var t=e.type;
                switch(t){
                    case "pointerdown": case "MSPointerDown": case "pointermove": case "MSPointerMove": case "pointerup": case "MSPointerUp":
                    return e.target.ownerDocument!==document ? [e.originalEvent.screenY,e.originalEvent.screenX,false] : [e.originalEvent.pageY,e.originalEvent.pageX,false];
                    break;
                    case "touchstart": case "touchmove": case "touchend":
                    var touch=e.originalEvent.touches[0] || e.originalEvent.changedTouches[0],
                        touches=e.originalEvent.touches.length || e.originalEvent.changedTouches.length;
                    return e.target.ownerDocument!==document ? [touch.screenY,touch.screenX,touches>1] : [touch.pageY,touch.pageX,touches>1];
                    break;
                    default:
                        return [e.pageY,e.pageX,false];
                }
            },
        /* -------------------- */


        /*
         SCROLLBAR DRAG EVENTS
         scrolls content via scrollbar dragging
         */
            _draggable=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    namespace=pluginPfx+"_"+d.idx,
                    draggerId=["mCSB_"+d.idx+"_dragger_vertical","mCSB_"+d.idx+"_dragger_horizontal"],
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=$("#"+draggerId[0]+",#"+draggerId[1]),
                    draggable,dragY,dragX,
                    rds=o.advanced.releaseDraggableSelectors ? mCSB_dragger.add($(o.advanced.releaseDraggableSelectors)) : mCSB_dragger;
                mCSB_dragger.bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
                    e.stopImmediatePropagation();
                    e.preventDefault();
                    if(!_mouseBtnLeft(e)){return;} /* left mouse button only */
                    touchActive=true;
                    if(oldIE){document.onselectstart=function(){return false;}} /* disable text selection for IE < 9 */
                    _iframe(false); /* enable scrollbar dragging over iframes by disabling their events */
                    _stop($this);
                    draggable=$(this);
                    var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
                        h=draggable.height()+offset.top,w=draggable.width()+offset.left;
                    if(y<h && y>0 && x<w && x>0){
                        dragY=y;
                        dragX=x;
                    }
                    _onDragClasses(draggable,"active",o.autoExpandScrollbar);
                }).bind("touchmove."+namespace,function(e){
                    e.stopImmediatePropagation();
                    e.preventDefault();
                    var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
                    _drag(dragY,dragX,y,x);
                });
                $(document).bind("mousemove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace,function(e){
                    if(draggable){
                        var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
                        if(dragY===y){return;} /* has it really moved? */
                        _drag(dragY,dragX,y,x);
                    }
                }).add(rds).bind("mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
                    if(draggable){
                        _onDragClasses(draggable,"active",o.autoExpandScrollbar);
                        draggable=null;
                    }
                    touchActive=false;
                    if(oldIE){document.onselectstart=null;} /* enable text selection for IE < 9 */
                    _iframe(true); /* enable iframes events */
                });
                function _iframe(evt){
                    var el=mCSB_container.find("iframe");
                    if(!el.length){return;} /* check if content contains iframes */
                    var val=!evt ? "none" : "auto";
                    el.css("pointer-events",val); /* for IE11, iframe's display property should not be "block" */
                }
                function _drag(dragY,dragX,y,x){
                    mCSB_container[0].idleTimer=o.scrollInertia<233 ? 250 : 0;
                    if(draggable.attr("id")===draggerId[1]){
                        var dir="x",to=((draggable[0].offsetLeft-dragX)+x)*d.scrollRatio.x;
                    }else{
                        var dir="y",to=((draggable[0].offsetTop-dragY)+y)*d.scrollRatio.y;
                    }
                    _scrollTo($this,to.toString(),{dir:dir,drag:true});
                }
            },
        /* -------------------- */


        /*
         TOUCH SWIPE EVENTS
         scrolls content via touch swipe
         Emulates the native touch-swipe scrolling with momentum found in iOS, Android and WP devices
         */
            _contentDraggable=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    namespace=pluginPfx+"_"+d.idx,
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
                    dragY,dragX,touchStartY,touchStartX,touchMoveY=[],touchMoveX=[],startTime,runningTime,endTime,distance,speed,amount,
                    durA=0,durB,overwrite=o.axis==="yx" ? "none" : "all",touchIntent=[],touchDrag,docDrag,
                    iframe=mCSB_container.find("iframe"),
                    events=[
                        "touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace, //start
                        "touchmove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace, //move
                        "touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace //end
                    ];
                mCSB_container.bind(events[0],function(e){
                    _onTouchstart(e);
                }).bind(events[1],function(e){
                    _onTouchmove(e);
                });
                mCustomScrollBox.bind(events[0],function(e){
                    _onTouchstart2(e);
                }).bind(events[2],function(e){
                    _onTouchend(e);
                });
                if(iframe.length){
                    iframe.each(function(){
                        $(this).load(function(){
                            /* bind events on accessible iframes */
                            if(_canAccessIFrame(this)){
                                $(this.contentDocument || this.contentWindow.document).bind(events[0],function(e){
                                    _onTouchstart(e);
                                    _onTouchstart2(e);
                                }).bind(events[1],function(e){
                                    _onTouchmove(e);
                                }).bind(events[2],function(e){
                                    _onTouchend(e);
                                });
                            }
                        });
                    });
                }
                function _onTouchstart(e){
                    if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){touchable=0; return;}
                    touchable=1; touchDrag=0; docDrag=0;
                    $this.removeClass("mCS_touch_action");
                    var offset=mCSB_container.offset();
                    dragY=_coordinates(e)[0]-offset.top;
                    dragX=_coordinates(e)[1]-offset.left;
                    touchIntent=[_coordinates(e)[0],_coordinates(e)[1]];
                }
                function _onTouchmove(e){
                    if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
                    e.stopImmediatePropagation();
                    if(docDrag && !touchDrag){return;}
                    runningTime=_getTime();
                    var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
                        easing="mcsLinearOut";
                    touchMoveY.push(y);
                    touchMoveX.push(x);
                    touchIntent[2]=Math.abs(_coordinates(e)[0]-touchIntent[0]); touchIntent[3]=Math.abs(_coordinates(e)[1]-touchIntent[1]);
                    if(d.overflowed[0]){
                        var limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height(),
                            prevent=((dragY-y)>0 && (y-dragY)>-(limit*d.scrollRatio.y) && (touchIntent[3]*2<touchIntent[2] || o.axis==="yx"));
                    }
                    if(d.overflowed[1]){
                        var limitX=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width(),
                            preventX=((dragX-x)>0 && (x-dragX)>-(limitX*d.scrollRatio.x) && (touchIntent[2]*2<touchIntent[3] || o.axis==="yx"));
                    }
                    if(prevent || preventX){ /* prevent native document scrolling */
                        e.preventDefault();
                        touchDrag=1;
                    }else{
                        docDrag=1;
                        $this.addClass("mCS_touch_action");
                    }
                    amount=o.axis==="yx" ? [(dragY-y),(dragX-x)] : o.axis==="x" ? [null,(dragX-x)] : [(dragY-y),null];
                    mCSB_container[0].idleTimer=250;
                    if(d.overflowed[0]){_drag(amount[0],durA,easing,"y","all",true);}
                    if(d.overflowed[1]){_drag(amount[1],durA,easing,"x",overwrite,true);}
                }
                function _onTouchstart2(e){
                    if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){touchable=0; return;}
                    touchable=1;
                    e.stopImmediatePropagation();
                    _stop($this);
                    startTime=_getTime();
                    var offset=mCustomScrollBox.offset();
                    touchStartY=_coordinates(e)[0]-offset.top;
                    touchStartX=_coordinates(e)[1]-offset.left;
                    touchMoveY=[]; touchMoveX=[];
                }
                function _onTouchend(e){
                    if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
                    e.stopImmediatePropagation();
                    touchDrag=0; docDrag=0;
                    endTime=_getTime();
                    var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
                    if((endTime-runningTime)>30){return;}
                    speed=1000/(endTime-startTime);
                    var easing="mcsEaseOut",slow=speed<2.5,
                        diff=slow ? [touchMoveY[touchMoveY.length-2],touchMoveX[touchMoveX.length-2]] : [0,0];
                    distance=slow ? [(y-diff[0]),(x-diff[1])] : [y-touchStartY,x-touchStartX];
                    var absDistance=[Math.abs(distance[0]),Math.abs(distance[1])];
                    speed=slow ? [Math.abs(distance[0]/4),Math.abs(distance[1]/4)] : [speed,speed];
                    var a=[
                        Math.abs(mCSB_container[0].offsetTop)-(distance[0]*_m((absDistance[0]/speed[0]),speed[0])),
                        Math.abs(mCSB_container[0].offsetLeft)-(distance[1]*_m((absDistance[1]/speed[1]),speed[1]))
                    ];
                    amount=o.axis==="yx" ? [a[0],a[1]] : o.axis==="x" ? [null,a[1]] : [a[0],null];
                    durB=[(absDistance[0]*4)+o.scrollInertia,(absDistance[1]*4)+o.scrollInertia];
                    var md=parseInt(o.contentTouchScroll) || 0; /* absolute minimum distance required */
                    amount[0]=absDistance[0]>md ? amount[0] : 0;
                    amount[1]=absDistance[1]>md ? amount[1] : 0;
                    if(d.overflowed[0]){_drag(amount[0],durB[0],easing,"y",overwrite,false);}
                    if(d.overflowed[1]){_drag(amount[1],durB[1],easing,"x",overwrite,false);}
                }
                function _m(ds,s){
                    var r=[s*1.5,s*2,s/1.5,s/2];
                    if(ds>90){
                        return s>4 ? r[0] : r[3];
                    }else if(ds>60){
                        return s>3 ? r[3] : r[2];
                    }else if(ds>30){
                        return s>8 ? r[1] : s>6 ? r[0] : s>4 ? s : r[2];
                    }else{
                        return s>8 ? s : r[3];
                    }
                }
                function _drag(amount,dur,easing,dir,overwrite,drag){
                    if(!amount){return;}
                    _scrollTo($this,amount.toString(),{dur:dur,scrollEasing:easing,dir:dir,overwrite:overwrite,drag:drag});
                }
            },
        /* -------------------- */


        /*
         SELECT TEXT EVENTS
         scrolls content when text is selected
         */
            _selectable=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
                    namespace=pluginPfx+"_"+d.idx,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    action;
                mCSB_container.bind("mousedown."+namespace,function(e){
                    if(touchable){return;}
                    if(!action){action=1; touchActive=true;}
                }).add(document).bind("mousemove."+namespace,function(e){
                    if(!touchable && action && _sel()){
                        var offset=mCSB_container.offset(),
                            y=_coordinates(e)[0]-offset.top+mCSB_container[0].offsetTop,x=_coordinates(e)[1]-offset.left+mCSB_container[0].offsetLeft;
                        if(y>0 && y<wrapper.height() && x>0 && x<wrapper.width()){
                            if(seq.step){_seq("off",null,"stepped");}
                        }else{
                            if(o.axis!=="x" && d.overflowed[0]){
                                if(y<0){
                                    _seq("on",38);
                                }else if(y>wrapper.height()){
                                    _seq("on",40);
                                }
                            }
                            if(o.axis!=="y" && d.overflowed[1]){
                                if(x<0){
                                    _seq("on",37);
                                }else if(x>wrapper.width()){
                                    _seq("on",39);
                                }
                            }
                        }
                    }
                }).bind("mouseup."+namespace,function(e){
                    if(touchable){return;}
                    if(action){action=0; _seq("off",null);}
                    touchActive=false;
                });
                function _sel(){
                    return 	window.getSelection ? window.getSelection().toString() :
                        document.selection && document.selection.type!="Control" ? document.selection.createRange().text : 0;
                }
                function _seq(a,c,s){
                    seq.type=s && action ? "stepped" : "stepless";
                    seq.scrollAmount=10;
                    _sequentialScroll($this,a,c,"mcsLinearOut",s ? 60 : null);
                }
            },
        /* -------------------- */


        /*
         MOUSE WHEEL EVENT
         scrolls content via mouse-wheel
         via mouse-wheel plugin (https://github.com/brandonaaron/jquery-mousewheel)
         */
            _mousewheel=function(){
                if(!$(this).data(pluginPfx)){return;} /* Check if the scrollbar is ready to use mousewheel events (issue: #185) */
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    namespace=pluginPfx+"_"+d.idx,
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
                    iframe=$("#mCSB_"+d.idx+"_container").find("iframe");
                if(iframe.length){
                    iframe.each(function(){
                        $(this).load(function(){
                            /* bind events on accessible iframes */
                            if(_canAccessIFrame(this)){
                                $(this.contentDocument || this.contentWindow.document).bind("mousewheel."+namespace,function(e,delta){
                                    _onMousewheel(e,delta);
                                });
                            }
                        });
                    });
                }
                mCustomScrollBox.bind("mousewheel."+namespace,function(e,delta){
                    _onMousewheel(e,delta);
                });
                function _onMousewheel(e,delta){
                    _stop($this);
                    if(_disableMousewheel($this,e.target)){return;} /* disables mouse-wheel when hovering specific elements */
                    var deltaFactor=o.mouseWheel.deltaFactor!=="auto" ? parseInt(o.mouseWheel.deltaFactor) : (oldIE && e.deltaFactor<100) ? 100 : e.deltaFactor || 100;
                    if(o.axis==="x" || o.mouseWheel.axis==="x"){
                        var dir="x",
                            px=[Math.round(deltaFactor*d.scrollRatio.x),parseInt(o.mouseWheel.scrollAmount)],
                            amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.width() ? mCustomScrollBox.width()*0.9 : px[0],
                            contentPos=Math.abs($("#mCSB_"+d.idx+"_container")[0].offsetLeft),
                            draggerPos=mCSB_dragger[1][0].offsetLeft,
                            limit=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width(),
                            dlt=e.deltaX || e.deltaY || delta;
                    }else{
                        var dir="y",
                            px=[Math.round(deltaFactor*d.scrollRatio.y),parseInt(o.mouseWheel.scrollAmount)],
                            amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.height() ? mCustomScrollBox.height()*0.9 : px[0],
                            contentPos=Math.abs($("#mCSB_"+d.idx+"_container")[0].offsetTop),
                            draggerPos=mCSB_dragger[0][0].offsetTop,
                            limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height(),
                            dlt=e.deltaY || delta;
                    }
                    if((dir==="y" && !d.overflowed[0]) || (dir==="x" && !d.overflowed[1])){return;}
                    if(o.mouseWheel.invert || e.webkitDirectionInvertedFromDevice){dlt=-dlt;}
                    if(o.mouseWheel.normalizeDelta){dlt=dlt<0 ? -1 : 1;}
                    if((dlt>0 && draggerPos!==0) || (dlt<0 && draggerPos!==limit) || o.mouseWheel.preventDefault){
                        e.stopImmediatePropagation();
                        e.preventDefault();
                    }
                    _scrollTo($this,(contentPos-(dlt*amount)).toString(),{dir:dir});
                }
            },
        /* -------------------- */


        /* checks if iframe can be accessed */
            _canAccessIFrame=function(iframe){
                var html=null;
                try{
                    var doc=iframe.contentDocument || iframe.contentWindow.document;
                    html=doc.body.innerHTML;
                }catch(err){/* do nothing */}
                return(html!==null);
            },
        /* -------------------- */


        /* disables mouse-wheel when hovering specific elements like select, datalist etc. */
            _disableMousewheel=function(el,target){
                var tag=target.nodeName.toLowerCase(),
                    tags=el.data(pluginPfx).opt.mouseWheel.disableOver,
                /* elements that require focus */
                    focusTags=["select","textarea"];
                return $.inArray(tag,tags) > -1 && !($.inArray(tag,focusTags) > -1 && !$(target).is(":focus"));
            },
        /* -------------------- */


        /*
         DRAGGER RAIL CLICK EVENT
         scrolls content via dragger rail
         */
            _draggerRail=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    namespace=pluginPfx+"_"+d.idx,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    mCSB_draggerContainer=$(".mCSB_"+d.idx+"_scrollbar ."+classes[12]);
                mCSB_draggerContainer.bind("touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
                    touchActive=true;
                }).bind("touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
                    touchActive=false;
                }).bind("click."+namespace,function(e){
                    if($(e.target).hasClass(classes[12]) || $(e.target).hasClass("mCSB_draggerRail")){
                        _stop($this);
                        var el=$(this),mCSB_dragger=el.find(".mCSB_dragger");
                        if(el.parent(".mCSB_scrollTools_horizontal").length>0){
                            if(!d.overflowed[1]){return;}
                            var dir="x",
                                clickDir=e.pageX>mCSB_dragger.offset().left ? -1 : 1,
                                to=Math.abs(mCSB_container[0].offsetLeft)-(clickDir*(wrapper.width()*0.9));
                        }else{
                            if(!d.overflowed[0]){return;}
                            var dir="y",
                                clickDir=e.pageY>mCSB_dragger.offset().top ? -1 : 1,
                                to=Math.abs(mCSB_container[0].offsetTop)-(clickDir*(wrapper.height()*0.9));
                        }
                        _scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
                    }
                });
            },
        /* -------------------- */


        /*
         FOCUS EVENT
         scrolls content via element focus (e.g. clicking an input, pressing TAB key etc.)
         */
            _focus=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    namespace=pluginPfx+"_"+d.idx,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent();
                mCSB_container.bind("focusin."+namespace,function(e){
                    var el=$(document.activeElement),
                        nested=mCSB_container.find(".mCustomScrollBox").length,
                        dur=0;
                    if(!el.is(o.advanced.autoScrollOnFocus)){return;}
                    _stop($this);
                    clearTimeout($this[0]._focusTimeout);
                    $this[0]._focusTimer=nested ? (dur+17)*nested : 0;
                    $this[0]._focusTimeout=setTimeout(function(){
                        var	to=[_childPos(el)[0],_childPos(el)[1]],
                            contentPos=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft],
                            isVisible=[
                                (contentPos[0]+to[0]>=0 && contentPos[0]+to[0]<wrapper.height()-el.outerHeight(false)),
                                (contentPos[1]+to[1]>=0 && contentPos[0]+to[1]<wrapper.width()-el.outerWidth(false))
                            ],
                            overwrite=(o.axis==="yx" && !isVisible[0] && !isVisible[1]) ? "none" : "all";
                        if(o.axis!=="x" && !isVisible[0]){
                            _scrollTo($this,to[0].toString(),{dir:"y",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
                        }
                        if(o.axis!=="y" && !isVisible[1]){
                            _scrollTo($this,to[1].toString(),{dir:"x",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
                        }
                    },$this[0]._focusTimer);
                });
            },
        /* -------------------- */


        /* sets content wrapper scrollTop/scrollLeft always to 0 */
            _wrapperScroll=function(){
                var $this=$(this),d=$this.data(pluginPfx),
                    namespace=pluginPfx+"_"+d.idx,
                    wrapper=$("#mCSB_"+d.idx+"_container").parent();
                wrapper.bind("scroll."+namespace,function(e){
                    if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){
                        $(".mCSB_"+d.idx+"_scrollbar").css("visibility","hidden"); /* hide scrollbar(s) */
                    }
                });
            },
        /* -------------------- */


        /*
         BUTTONS EVENTS
         scrolls content via up, down, left and right buttons
         */
            _buttons=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
                    namespace=pluginPfx+"_"+d.idx,
                    sel=".mCSB_"+d.idx+"_scrollbar",
                    btn=$(sel+">a");
                btn.bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace+" mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace+" mouseout."+namespace+" pointerout."+namespace+" MSPointerOut."+namespace+" click."+namespace,function(e){
                    e.preventDefault();
                    if(!_mouseBtnLeft(e)){return;} /* left mouse button only */
                    var btnClass=$(this).attr("class");
                    seq.type=o.scrollButtons.scrollType;
                    switch(e.type){
                        case "mousedown": case "touchstart": case "pointerdown": case "MSPointerDown":
                        if(seq.type==="stepped"){return;}
                        touchActive=true;
                        d.tweenRunning=false;
                        _seq("on",btnClass);
                        break;
                        case "mouseup": case "touchend": case "pointerup": case "MSPointerUp":
                        case "mouseout": case "pointerout": case "MSPointerOut":
                        if(seq.type==="stepped"){return;}
                        touchActive=false;
                        if(seq.dir){_seq("off",btnClass);}
                        break;
                        case "click":
                            if(seq.type!=="stepped" || d.tweenRunning){return;}
                            _seq("on",btnClass);
                            break;
                    }
                    function _seq(a,c){
                        seq.scrollAmount=o.snapAmount || o.scrollButtons.scrollAmount;
                        _sequentialScroll($this,a,c);
                    }
                });
            },
        /* -------------------- */


        /*
         KEYBOARD EVENTS
         scrolls content via keyboard
         Keys: up arrow, down arrow, left arrow, right arrow, PgUp, PgDn, Home, End
         */
            _keyboard=function(){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
                    namespace=pluginPfx+"_"+d.idx,
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    editables="input,textarea,select,datalist,keygen,[contenteditable='true']",
                    iframe=mCSB_container.find("iframe"),
                    events=["blur."+namespace+" keydown."+namespace+" keyup."+namespace];
                if(iframe.length){
                    iframe.each(function(){
                        $(this).load(function(){
                            /* bind events on accessible iframes */
                            if(_canAccessIFrame(this)){
                                $(this.contentDocument || this.contentWindow.document).bind(events[0],function(e){
                                    _onKeyboard(e);
                                });
                            }
                        });
                    });
                }
                mCustomScrollBox.attr("tabindex","0").bind(events[0],function(e){
                    _onKeyboard(e);
                });
                function _onKeyboard(e){
                    switch(e.type){
                        case "blur":
                            if(d.tweenRunning && seq.dir){_seq("off",null);}
                            break;
                        case "keydown": case "keyup":
                        var code=e.keyCode ? e.keyCode : e.which,action="on";
                        if((o.axis!=="x" && (code===38 || code===40)) || (o.axis!=="y" && (code===37 || code===39))){
                            /* up (38), down (40), left (37), right (39) arrows */
                            if(((code===38 || code===40) && !d.overflowed[0]) || ((code===37 || code===39) && !d.overflowed[1])){return;}
                            if(e.type==="keyup"){action="off";}
                            if(!$(document.activeElement).is(editables)){
                                e.preventDefault();
                                e.stopImmediatePropagation();
                                _seq(action,code);
                            }
                        }else if(code===33 || code===34){
                            /* PgUp (33), PgDn (34) */
                            if(d.overflowed[0] || d.overflowed[1]){
                                e.preventDefault();
                                e.stopImmediatePropagation();
                            }
                            if(e.type==="keyup"){
                                _stop($this);
                                var keyboardDir=code===34 ? -1 : 1;
                                if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
                                    var dir="x",to=Math.abs(mCSB_container[0].offsetLeft)-(keyboardDir*(wrapper.width()*0.9));
                                }else{
                                    var dir="y",to=Math.abs(mCSB_container[0].offsetTop)-(keyboardDir*(wrapper.height()*0.9));
                                }
                                _scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
                            }
                        }else if(code===35 || code===36){
                            /* End (35), Home (36) */
                            if(!$(document.activeElement).is(editables)){
                                if(d.overflowed[0] || d.overflowed[1]){
                                    e.preventDefault();
                                    e.stopImmediatePropagation();
                                }
                                if(e.type==="keyup"){
                                    if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
                                        var dir="x",to=code===35 ? Math.abs(wrapper.width()-mCSB_container.outerWidth(false)) : 0;
                                    }else{
                                        var dir="y",to=code===35 ? Math.abs(wrapper.height()-mCSB_container.outerHeight(false)) : 0;
                                    }
                                    _scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
                                }
                            }
                        }
                        break;
                    }
                    function _seq(a,c){
                        seq.type=o.keyboard.scrollType;
                        seq.scrollAmount=o.snapAmount || o.keyboard.scrollAmount;
                        if(seq.type==="stepped" && d.tweenRunning){return;}
                        _sequentialScroll($this,a,c);
                    }
                }
            },
        /* -------------------- */


        /* scrolls content sequentially (used when scrolling via buttons, keyboard arrows etc.) */
            _sequentialScroll=function(el,action,trigger,e,s){
                var d=el.data(pluginPfx),o=d.opt,seq=d.sequential,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    once=seq.type==="stepped" ? true : false,
                    steplessSpeed=o.scrollInertia < 26 ? 26 : o.scrollInertia, /* 26/1.5=17 */
                    steppedSpeed=o.scrollInertia < 1 ? 17 : o.scrollInertia;
                switch(action){
                    case "on":
                        seq.dir=[
                            (trigger===classes[16] || trigger===classes[15] || trigger===39 || trigger===37 ? "x" : "y"),
                            (trigger===classes[13] || trigger===classes[15] || trigger===38 || trigger===37 ? -1 : 1)
                        ];
                        _stop(el);
                        if(_isNumeric(trigger) && seq.type==="stepped"){return;}
                        _on(once);
                        break;
                    case "off":
                        _off();
                        if(once || (d.tweenRunning && seq.dir)){
                            _on(true);
                        }
                        break;
                }
                /* starts sequence */
                function _on(once){
                    var c=seq.type!=="stepped", /* continuous scrolling */
                        t=s ? s : !once ? 1000/60 : c ? steplessSpeed/1.5 : steppedSpeed, /* timer */
                        m=!once ? 2.5 : c ? 7.5 : 40, /* multiplier */
                        contentPos=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)],
                        ratio=[d.scrollRatio.y>10 ? 10 : d.scrollRatio.y,d.scrollRatio.x>10 ? 10 : d.scrollRatio.x],
                        amount=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*(ratio[1]*m)) : contentPos[0]+(seq.dir[1]*(ratio[0]*m)),
                        px=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*parseInt(seq.scrollAmount)) : contentPos[0]+(seq.dir[1]*parseInt(seq.scrollAmount)),
                        to=seq.scrollAmount!=="auto" ? px : amount,
                        easing=e ? e : !once ? "mcsLinear" : c ? "mcsLinearOut" : "mcsEaseInOut",
                        onComplete=!once ? false : true;
                    if(once && t<17){
                        to=seq.dir[0]==="x" ? contentPos[1] : contentPos[0];
                    }
                    _scrollTo(el,to.toString(),{dir:seq.dir[0],scrollEasing:easing,dur:t,onComplete:onComplete});
                    if(once){
                        seq.dir=false;
                        return;
                    }
                    clearTimeout(seq.step);
                    seq.step=setTimeout(function(){
                        _on();
                    },t);
                }
                /* stops sequence */
                function _off(){
                    clearTimeout(seq.step);
                    _delete(seq,"step");
                    _stop(el);
                }
            },
        /* -------------------- */


        /* returns a yx array from value */
            _arr=function(val){
                var o=$(this).data(pluginPfx).opt,vals=[];
                if(typeof val==="function"){val=val();} /* check if the value is a single anonymous function */
                /* check if value is object or array, its length and create an array with yx values */
                if(!(val instanceof Array)){ /* object value (e.g. {y:"100",x:"100"}, 100 etc.) */
                    vals[0]=val.y ? val.y : val.x || o.axis==="x" ? null : val;
                    vals[1]=val.x ? val.x : val.y || o.axis==="y" ? null : val;
                }else{ /* array value (e.g. [100,100]) */
                    vals=val.length>1 ? [val[0],val[1]] : o.axis==="x" ? [null,val[0]] : [val[0],null];
                }
                /* check if array values are anonymous functions */
                if(typeof vals[0]==="function"){vals[0]=vals[0]();}
                if(typeof vals[1]==="function"){vals[1]=vals[1]();}
                return vals;
            },
        /* -------------------- */


        /* translates values (e.g. "top", 100, "100px", "#id") to actual scroll-to positions */
            _to=function(val,dir){
                if(val==null || typeof val=="undefined"){return;}
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    t=typeof val;
                if(!dir){dir=o.axis==="x" ? "x" : "y";}
                var contentLength=dir==="x" ? mCSB_container.outerWidth(false) : mCSB_container.outerHeight(false),
                    contentPos=dir==="x" ? mCSB_container[0].offsetLeft : mCSB_container[0].offsetTop,
                    cssProp=dir==="x" ? "left" : "top";
                switch(t){
                    case "function": /* this currently is not used. Consider removing it */
                        return val();
                        break;
                    case "object": /* js/jquery object */
                        var obj=val.jquery ? val : $(val);
                        if(!obj.length){return;}
                        return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
                        break;
                    case "string": case "number":
                    if(_isNumeric(val)){ /* numeric value */
                        return Math.abs(val);
                    }else if(val.indexOf("%")!==-1){ /* percentage value */
                        return Math.abs(contentLength*parseInt(val)/100);
                    }else if(val.indexOf("-=")!==-1){ /* decrease value */
                        return Math.abs(contentPos-parseInt(val.split("-=")[1]));
                    }else if(val.indexOf("+=")!==-1){ /* inrease value */
                        var p=(contentPos+parseInt(val.split("+=")[1]));
                        return p>=0 ? 0 : Math.abs(p);
                    }else if(val.indexOf("px")!==-1 && _isNumeric(val.split("px")[0])){ /* pixels string value (e.g. "100px") */
                        return Math.abs(val.split("px")[0]);
                    }else{
                        if(val==="top" || val==="left"){ /* special strings */
                            return 0;
                        }else if(val==="bottom"){
                            return Math.abs(wrapper.height()-mCSB_container.outerHeight(false));
                        }else if(val==="right"){
                            return Math.abs(wrapper.width()-mCSB_container.outerWidth(false));
                        }else if(val==="first" || val==="last"){
                            var obj=mCSB_container.find(":"+val);
                            return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
                        }else{
                            if($(val).length){ /* jquery selector */
                                return dir==="x" ? _childPos($(val))[1] : _childPos($(val))[0];
                            }else{ /* other values (e.g. "100em") */
                                mCSB_container.css(cssProp,val);
                                methods.update.call(null,$this[0]);
                                return;
                            }
                        }
                    }
                    break;
                }
            },
        /* -------------------- */


        /* calls the update method automatically */
            _autoUpdate=function(rem){
                var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
                    mCSB_container=$("#mCSB_"+d.idx+"_container");
                if(rem){
                    /*
                     removes autoUpdate timer
                     usage: _autoUpdate.call(this,"remove");
                     */
                    clearTimeout(mCSB_container[0].autoUpdate);
                    _delete(mCSB_container[0],"autoUpdate");
                    return;
                }
                var	wrapper=mCSB_container.parent(),
                    scrollbar=[$("#mCSB_"+d.idx+"_scrollbar_vertical"),$("#mCSB_"+d.idx+"_scrollbar_horizontal")],
                    scrollbarSize=function(){return [
                        scrollbar[0].is(":visible") ? scrollbar[0].outerHeight(true) : 0, /* returns y-scrollbar height */
                        scrollbar[1].is(":visible") ? scrollbar[1].outerWidth(true) : 0 /* returns x-scrollbar width */
                    ]},
                    oldSelSize=sizesSum(),newSelSize,
                    os=[mCSB_container.outerHeight(false),mCSB_container.outerWidth(false),wrapper.height(),wrapper.width(),scrollbarSize()[0],scrollbarSize()[1]],ns,
                    oldImgsLen=imgSum(),newImgsLen;
                upd();
                function upd(){
                    clearTimeout(mCSB_container[0].autoUpdate);
                    if($this.parents("html").length===0){
                        /* check element in dom tree */
                        $this=null;
                        return;
                    }
                    mCSB_container[0].autoUpdate=setTimeout(function(){
                        /* update on specific selector(s) length and size change */
                        if(o.advanced.updateOnSelectorChange){
                            newSelSize=sizesSum();
                            if(newSelSize!==oldSelSize){
                                doUpd(3);
                                oldSelSize=newSelSize;
                                return;
                            }
                        }
                        /* update on main element and scrollbar size changes */
                        if(o.advanced.updateOnContentResize){
                            ns=[mCSB_container.outerHeight(false),mCSB_container.outerWidth(false),wrapper.height(),wrapper.width(),scrollbarSize()[0],scrollbarSize()[1]];
                            if(ns[0]!==os[0] || ns[1]!==os[1] || ns[2]!==os[2] || ns[3]!==os[3] || ns[4]!==os[4] || ns[5]!==os[5]){
                                doUpd(ns[0]!==os[0] || ns[1]!==os[1]);
                                os=ns;
                            }
                        }
                        /* update on image load */
                        if(o.advanced.updateOnImageLoad){
                            newImgsLen=imgSum();
                            if(newImgsLen!==oldImgsLen){
                                mCSB_container.find("img").each(function(){
                                    imgLoader(this);
                                });
                                oldImgsLen=newImgsLen;
                            }
                        }
                        if(o.advanced.updateOnSelectorChange || o.advanced.updateOnContentResize || o.advanced.updateOnImageLoad){upd();}
                    },o.advanced.autoUpdateTimeout);
                }
                /* returns images amount */
                function imgSum(){
                    var total=0
                    if(o.advanced.updateOnImageLoad){total=mCSB_container.find("img").length;}
                    return total;
                }
                /* a tiny image loader */
                function imgLoader(el){
                    if($(el).hasClass(classes[2])){doUpd(); return;}
                    var img=new Image();
                    function createDelegate(contextObject,delegateMethod){
                        return function(){return delegateMethod.apply(contextObject,arguments);}
                    }
                    function imgOnLoad(){
                        this.onload=null;
                        $(el).addClass(classes[2]);
                        doUpd(2);
                    }
                    img.onload=createDelegate(img,imgOnLoad);
                    img.src=el.src;
                }
                /* returns the total height and width sum of all elements matching the selector */
                function sizesSum(){
                    if(o.advanced.updateOnSelectorChange===true){o.advanced.updateOnSelectorChange="*";}
                    var total=0,sel=mCSB_container.find(o.advanced.updateOnSelectorChange);
                    if(o.advanced.updateOnSelectorChange && sel.length>0){sel.each(function(){total+=$(this).height()+$(this).width();});}
                    return total;
                }
                /* calls the update method */
                function doUpd(cb){
                    clearTimeout(mCSB_container[0].autoUpdate);
                    methods.update.call(null,$this[0],cb);
                }
            },
        /* -------------------- */


        /* snaps scrolling to a multiple of a pixels number */
            _snapAmount=function(to,amount,offset){
                return (Math.round(to/amount)*amount-offset);
            },
        /* -------------------- */


        /* stops content and scrollbar animations */
            _stop=function(el){
                var d=el.data(pluginPfx),
                    sel=$("#mCSB_"+d.idx+"_container,#mCSB_"+d.idx+"_container_wrapper,#mCSB_"+d.idx+"_dragger_vertical,#mCSB_"+d.idx+"_dragger_horizontal");
                sel.each(function(){
                    _stopTween.call(this);
                });
            },
        /* -------------------- */


        /*
         ANIMATES CONTENT
         This is where the actual scrolling happens
         */
            _scrollTo=function(el,to,options){
                var d=el.data(pluginPfx),o=d.opt,
                    defaults={
                        trigger:"internal",
                        dir:"y",
                        scrollEasing:"mcsEaseOut",
                        drag:false,
                        dur:o.scrollInertia,
                        overwrite:"all",
                        callbacks:true,
                        onStart:true,
                        onUpdate:true,
                        onComplete:true
                    },
                    options=$.extend(defaults,options),
                    dur=[options.dur,(options.drag ? 0 : options.dur)],
                    mCustomScrollBox=$("#mCSB_"+d.idx),
                    mCSB_container=$("#mCSB_"+d.idx+"_container"),
                    wrapper=mCSB_container.parent(),
                    totalScrollOffsets=o.callbacks.onTotalScrollOffset ? _arr.call(el,o.callbacks.onTotalScrollOffset) : [0,0],
                    totalScrollBackOffsets=o.callbacks.onTotalScrollBackOffset ? _arr.call(el,o.callbacks.onTotalScrollBackOffset) : [0,0];
                d.trigger=options.trigger;
                if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){ /* always reset scrollTop/Left */
                    $(".mCSB_"+d.idx+"_scrollbar").css("visibility","visible");
                    wrapper.scrollTop(0).scrollLeft(0);
                }
                if(to==="_resetY" && !d.contentReset.y){
                    /* callbacks: onOverflowYNone */
                    if(_cb("onOverflowYNone")){o.callbacks.onOverflowYNone.call(el[0]);}
                    d.contentReset.y=1;
                }
                if(to==="_resetX" && !d.contentReset.x){
                    /* callbacks: onOverflowXNone */
                    if(_cb("onOverflowXNone")){o.callbacks.onOverflowXNone.call(el[0]);}
                    d.contentReset.x=1;
                }
                if(to==="_resetY" || to==="_resetX"){return;}
                if((d.contentReset.y || !el[0].mcs) && d.overflowed[0]){
                    /* callbacks: onOverflowY */
                    if(_cb("onOverflowY")){o.callbacks.onOverflowY.call(el[0]);}
                    d.contentReset.x=null;
                }
                if((d.contentReset.x || !el[0].mcs) && d.overflowed[1]){
                    /* callbacks: onOverflowX */
                    if(_cb("onOverflowX")){o.callbacks.onOverflowX.call(el[0]);}
                    d.contentReset.x=null;
                }
                if(o.snapAmount){to=_snapAmount(to,o.snapAmount,o.snapOffset);} /* scrolling snapping */
                switch(options.dir){
                    case "x":
                        var mCSB_dragger=$("#mCSB_"+d.idx+"_dragger_horizontal"),
                            property="left",
                            contentPos=mCSB_container[0].offsetLeft,
                            limit=[
                                mCustomScrollBox.width()-mCSB_container.outerWidth(false),
                                mCSB_dragger.parent().width()-mCSB_dragger.width()
                            ],
                            scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.x)],
                            tso=totalScrollOffsets[1],
                            tsbo=totalScrollBackOffsets[1],
                            totalScrollOffset=tso>0 ? tso/d.scrollRatio.x : 0,
                            totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.x : 0;
                        break;
                    case "y":
                        var mCSB_dragger=$("#mCSB_"+d.idx+"_dragger_vertical"),
                            property="top",
                            contentPos=mCSB_container[0].offsetTop,
                            limit=[
                                mCustomScrollBox.height()-mCSB_container.outerHeight(false),
                                mCSB_dragger.parent().height()-mCSB_dragger.height()
                            ],
                            scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.y)],
                            tso=totalScrollOffsets[0],
                            tsbo=totalScrollBackOffsets[0],
                            totalScrollOffset=tso>0 ? tso/d.scrollRatio.y : 0,
                            totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.y : 0;
                        break;
                }
                if(scrollTo[1]<0 || (scrollTo[0]===0 && scrollTo[1]===0)){
                    scrollTo=[0,0];
                }else if(scrollTo[1]>=limit[1]){
                    scrollTo=[limit[0],limit[1]];
                }else{
                    scrollTo[0]=-scrollTo[0];
                }
                if(!el[0].mcs){
                    _mcs();  /* init mcs object (once) to make it available before callbacks */
                    if(_cb("onInit")){o.callbacks.onInit.call(el[0]);} /* callbacks: onInit */
                }
                clearTimeout(mCSB_container[0].onCompleteTimeout);
                if(!d.tweenRunning && ((contentPos===0 && scrollTo[0]>=0) || (contentPos===limit[0] && scrollTo[0]<=limit[0]))){return;}
                _tweenTo(mCSB_dragger[0],property,Math.round(scrollTo[1]),dur[1],options.scrollEasing);
                _tweenTo(mCSB_container[0],property,Math.round(scrollTo[0]),dur[0],options.scrollEasing,options.overwrite,{
                    onStart:function(){
                        if(options.callbacks && options.onStart && !d.tweenRunning){
                            /* callbacks: onScrollStart */
                            if(_cb("onScrollStart")){_mcs(); o.callbacks.onScrollStart.call(el[0]);}
                            d.tweenRunning=true;
                            _onDragClasses(mCSB_dragger);
                            d.cbOffsets=_cbOffsets();
                        }
                    },onUpdate:function(){
                        if(options.callbacks && options.onUpdate){
                            /* callbacks: whileScrolling */
                            if(_cb("whileScrolling")){_mcs(); o.callbacks.whileScrolling.call(el[0]);}
                        }
                    },onComplete:function(){
                        if(options.callbacks && options.onComplete){
                            if(o.axis==="yx"){clearTimeout(mCSB_container[0].onCompleteTimeout);}
                            var t=mCSB_container[0].idleTimer || 0;
                            mCSB_container[0].onCompleteTimeout=setTimeout(function(){
                                /* callbacks: onScroll, onTotalScroll, onTotalScrollBack */
                                if(_cb("onScroll")){_mcs(); o.callbacks.onScroll.call(el[0]);}
                                if(_cb("onTotalScroll") && scrollTo[1]>=limit[1]-totalScrollOffset && d.cbOffsets[0]){_mcs(); o.callbacks.onTotalScroll.call(el[0]);}
                                if(_cb("onTotalScrollBack") && scrollTo[1]<=totalScrollBackOffset && d.cbOffsets[1]){_mcs(); o.callbacks.onTotalScrollBack.call(el[0]);}
                                d.tweenRunning=false;
                                mCSB_container[0].idleTimer=0;
                                _onDragClasses(mCSB_dragger,"hide");
                            },t);
                        }
                    }
                });
                /* checks if callback function exists */
                function _cb(cb){
                    return d && o.callbacks[cb] && typeof o.callbacks[cb]==="function";
                }
                /* checks whether callback offsets always trigger */
                function _cbOffsets(){
                    return [o.callbacks.alwaysTriggerOffsets || contentPos>=limit[0]+tso,o.callbacks.alwaysTriggerOffsets || contentPos<=-tsbo];
                }
                /*
                 populates object with useful values for the user
                 values:
                 content: this.mcs.content
                 content top position: this.mcs.top
                 content left position: this.mcs.left
                 dragger top position: this.mcs.draggerTop
                 dragger left position: this.mcs.draggerLeft
                 scrolling y percentage: this.mcs.topPct
                 scrolling x percentage: this.mcs.leftPct
                 scrolling direction: this.mcs.direction
                 */
                function _mcs(){
                    var cp=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft], /* content position */
                        dp=[mCSB_dragger[0].offsetTop,mCSB_dragger[0].offsetLeft], /* dragger position */
                        cl=[mCSB_container.outerHeight(false),mCSB_container.outerWidth(false)], /* content length */
                        pl=[mCustomScrollBox.height(),mCustomScrollBox.width()]; /* content parent length */
                    el[0].mcs={
                        content:mCSB_container, /* original content wrapper as jquery object */
                        top:cp[0],left:cp[1],draggerTop:dp[0],draggerLeft:dp[1],
                        topPct:Math.round((100*Math.abs(cp[0]))/(Math.abs(cl[0])-pl[0])),leftPct:Math.round((100*Math.abs(cp[1]))/(Math.abs(cl[1])-pl[1])),
                        direction:options.dir
                    };
                    /*
                     this refers to the original element containing the scrollbar(s)
                     usage: this.mcs.top, this.mcs.leftPct etc.
                     */
                }
            },
        /* -------------------- */


        /*
         CUSTOM JAVASCRIPT ANIMATION TWEEN
         Lighter and faster than jquery animate() and css transitions
         Animates top/left properties and includes easings
         */
            _tweenTo=function(el,prop,to,duration,easing,overwrite,callbacks){
                if(!el._mTween){el._mTween={top:{},left:{}};}
                var callbacks=callbacks || {},
                    onStart=callbacks.onStart || function(){},onUpdate=callbacks.onUpdate || function(){},onComplete=callbacks.onComplete || function(){},
                    startTime=_getTime(),_delay,progress=0,from=el.offsetTop,elStyle=el.style,_request,tobj=el._mTween[prop];
                if(prop==="left"){from=el.offsetLeft;}
                var diff=to-from;
                tobj.stop=0;
                if(overwrite!=="none"){_cancelTween();}
                _startTween();
                function _step(){
                    if(tobj.stop){return;}
                    if(!progress){onStart.call();}
                    progress=_getTime()-startTime;
                    _tween();
                    if(progress>=tobj.time){
                        tobj.time=(progress>tobj.time) ? progress+_delay-(progress-tobj.time) : progress+_delay-1;
                        if(tobj.time<progress+1){tobj.time=progress+1;}
                    }
                    if(tobj.time<duration){tobj.id=_request(_step);}else{onComplete.call();}
                }
                function _tween(){
                    if(duration>0){
                        tobj.currVal=_ease(tobj.time,from,diff,duration,easing);
                        elStyle[prop]=Math.round(tobj.currVal)+"px";
                    }else{
                        elStyle[prop]=to+"px";
                    }
                    onUpdate.call();
                }
                function _startTween(){
                    _delay=1000/60;
                    tobj.time=progress+_delay;
                    _request=(!window.requestAnimationFrame) ? function(f){_tween(); return setTimeout(f,0.01);} : window.requestAnimationFrame;
                    tobj.id=_request(_step);
                }
                function _cancelTween(){
                    if(tobj.id==null){return;}
                    if(!window.requestAnimationFrame){clearTimeout(tobj.id);
                    }else{window.cancelAnimationFrame(tobj.id);}
                    tobj.id=null;
                }
                function _ease(t,b,c,d,type){
                    switch(type){
                        case "linear": case "mcsLinear":
                        return c*t/d + b;
                        break;
                        case "mcsLinearOut":
                            t/=d; t--; return c * Math.sqrt(1 - t*t) + b;
                            break;
                        case "easeInOutSmooth":
                            t/=d/2;
                            if(t<1) return c/2*t*t + b;
                            t--;
                            return -c/2 * (t*(t-2) - 1) + b;
                            break;
                        case "easeInOutStrong":
                            t/=d/2;
                            if(t<1) return c/2 * Math.pow( 2, 10 * (t - 1) ) + b;
                            t--;
                            return c/2 * ( -Math.pow( 2, -10 * t) + 2 ) + b;
                            break;
                        case "easeInOut": case "mcsEaseInOut":
                        t/=d/2;
                        if(t<1) return c/2*t*t*t + b;
                        t-=2;
                        return c/2*(t*t*t + 2) + b;
                        break;
                        case "easeOutSmooth":
                            t/=d; t--;
                            return -c * (t*t*t*t - 1) + b;
                            break;
                        case "easeOutStrong":
                            return c * ( -Math.pow( 2, -10 * t/d ) + 1 ) + b;
                            break;
                        case "easeOut": case "mcsEaseOut": default:
                        var ts=(t/=d)*t,tc=ts*t;
                        return b+c*(0.499999999999997*tc*ts + -2.5*ts*ts + 5.5*tc + -6.5*ts + 4*t);
                    }
                }
            },
        /* -------------------- */


        /* returns current time */
            _getTime=function(){
                if(window.performance && window.performance.now){
                    return window.performance.now();
                }else{
                    if(window.performance && window.performance.webkitNow){
                        return window.performance.webkitNow();
                    }else{
                        if(Date.now){return Date.now();}else{return new Date().getTime();}
                    }
                }
            },
        /* -------------------- */


        /* stops a tween */
            _stopTween=function(){
                var el=this;
                if(!el._mTween){el._mTween={top:{},left:{}};}
                var props=["top","left"];
                for(var i=0; i<props.length; i++){
                    var prop=props[i];
                    if(el._mTween[prop].id){
                        if(!window.requestAnimationFrame){clearTimeout(el._mTween[prop].id);
                        }else{window.cancelAnimationFrame(el._mTween[prop].id);}
                        el._mTween[prop].id=null;
                        el._mTween[prop].stop=1;
                    }
                }
            },
        /* -------------------- */


        /* deletes a property (avoiding the exception thrown by IE) */
            _delete=function(c,m){
                try{delete c[m];}catch(e){c[m]=null;}
            },
        /* -------------------- */


        /* detects left mouse button */
            _mouseBtnLeft=function(e){
                return !(e.which && e.which!==1);
            },
        /* -------------------- */


        /* detects if pointer type event is touch */
            _pointerTouch=function(e){
                var t=e.originalEvent.pointerType;
                return !(t && t!=="touch" && t!==2);
            },
        /* -------------------- */


        /* checks if value is numeric */
            _isNumeric=function(val){
                return !isNaN(parseFloat(val)) && isFinite(val);
            },
        /* -------------------- */


        /* returns element position according to content */
            _childPos=function(el){
                var p=el.parents(".mCSB_container");
                return [el.offset().top-p.offset().top,el.offset().left-p.offset().left];
            };
        /* -------------------- */





        /*
         ----------------------------------------
         PLUGIN SETUP
         ----------------------------------------
         */

        /* plugin constructor functions */
        $.fn[pluginNS]=function(method){ /* usage: $(selector).mCustomScrollbar(); */
            if(methods[method]){
                return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
            }else if(typeof method==="object" || !method){
                return methods.init.apply(this,arguments);
            }else{
                $.error("Method "+method+" does not exist");
            }
        };
        $[pluginNS]=function(method){ /* usage: $.mCustomScrollbar(); */
            if(methods[method]){
                return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
            }else if(typeof method==="object" || !method){
                return methods.init.apply(this,arguments);
            }else{
                $.error("Method "+method+" does not exist");
            }
        };

        /*
         allow setting plugin default options.
         usage: $.mCustomScrollbar.defaults.scrollInertia=500;
         to apply any changed default options on default selectors (below), use inside document ready fn
         e.g.: $(document).ready(function(){ $.mCustomScrollbar.defaults.scrollInertia=500; });
         */
        $[pluginNS].defaults=defaults;

        /*
         add window object (window.mCustomScrollbar)
         usage: if(window.mCustomScrollbar){console.log("custom scrollbar plugin loaded");}
         */
        window[pluginNS]=true;

        $(window).load(function(){

            $(defaultSelector)[pluginNS](); /* add scrollbars automatically on default selector */

            /* extend jQuery expressions */
            $.extend($.expr[":"],{
                /* checks if element is within scrollable viewport */
                mcsInView:$.expr[":"].mcsInView || function(el){
                    var $el=$(el),content=$el.parents(".mCSB_container"),wrapper,cPos;
                    if(!content.length){return;}
                    wrapper=content.parent();
                    cPos=[content[0].offsetTop,content[0].offsetLeft];
                    return 	cPos[0]+_childPos($el)[0]>=0 && cPos[0]+_childPos($el)[0]<wrapper.height()-$el.outerHeight(false) &&
                        cPos[1]+_childPos($el)[1]>=0 && cPos[1]+_childPos($el)[1]<wrapper.width()-$el.outerWidth(false);
                },
                /* checks if element is overflowed having visible scrollbar(s) */
                mcsOverflow:$.expr[":"].mcsOverflow || function(el){
                    var d=$(el).data(pluginPfx);
                    if(!d){return;}
                    return d.overflowed[0] || d.overflowed[1];
                }
            });

        });

    }))}));
/**
 * TimeTo jQuery plug-in
 * Show countdown timer or realtime clock
 *
 *@example http://lexxus.github.io/jq-timeTo/
 *
 * @author Alexey Teterin <altmoc@gmail.com>
 * @version 1.0.13
 * @license MIT http://opensource.org/licenses/MIT
 * @date 2014-01-17
 */
(function (factory) {
    if (typeof exports === 'object') {
        // CommonJS (Node)
        var jQuery = require('jquery');
        module.exports = factory(jQuery || $);
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else {
        // globals
        factory(jQuery || $);
    }
}(function ($) {

    var methods = {
        start: function(sec){
            if(sec) init.call(this, sec);
            var me = this,
                intervalId = setTimeout(function(){ tick.call(me); }, 1000);

            // save start time
            this.data('ttStartTime', (new Date()).getTime());
            this.data('intervalId', intervalId);
        },

        stop: function(){
            var data = this.data();

            if(data.intervalId){
                clearTimeout(data.intervalId);
                this.data('intervalId', null);
            }
            return data;
        },
        
        reset: function(sec){
            var data = methods.stop.call(this);

            this.find('div').css({ backgroundPosition: 'left center' });
            this.find('ul').parent().removeClass('timeTo-alert');

            if(typeof sec === "undefined") { sec = data.value; }
            if (data.vals) { data.vals = null; }
            init.call(this, sec);
        }

    };
    
    var dictionary = {
        en:{days:'days',   hours:'hours',  min:'minutes',  sec:'seconds'},
        ru:{days:'дней',   hours:'часов',  min:'минут',    sec:'секунд'},
        ua:{days:'днiв',   hours:'годин',  min:'хвилин',   sec:'секунд'},
        de:{days:'Tag',    hours:'Uhr',    min:'Minuten',  sec:'Secunden'},
        fr:{days:'jours',  hours:'heures', min:'minutes',  sec:'secondes'},
        sp:{days:'días',   hours:'horas',  min:'minutos',  sec:'segundos'},
        it:{days:'giorni', hours:'ore',    min:'minuti',   sec:'secondi'},
        nl:{days:'dagen',  hours:'uren',   min:'minuten',  sec:'seconden'},
        no:{days:'dager',  hours:'timer',  min:'minutter', sec:'sekunder'},
        pt:{days:'dias',   hours:'horas',  min:'minutos',  sec:'segundos'},
        tr:{days:'gün',   hours:'saat',  min:'dakika',     sec:'saniye'}
    };
    
    if(typeof $.support.transition === 'undefined'){
        $.support.transition = (function(){
            var thisBody = document.body || document.documentElement,
                thisStyle = thisBody.style,
                support = thisStyle.transition !== undefined || thisStyle.WebkitTransition !== undefined || thisStyle.MozTransition !== undefined || thisStyle.MsTransition !== undefined || thisStyle.OTransition !== undefined;

            return support;
        })();
    }
    
    $.fn.timeTo = function(){
        var defaults = {
                callback: null,          // callback function for exec when timer out
                captionSize: 0,          // font-size by pixels for captions, if 0 then calculate automaticaly
                countdown: true,         // is countdown or real clock
                countdownAlertLimit: 10, // limit in seconds when display red background
                displayCaptions: false,  // display captions under digit groups
                displayDays: 0,          // display day timer, count of days digits
                displayHours: true,      // display hours
                displaySeconds: true,
                fontFamily: "Verdana, sans-serif",
                topTransition: 50,

                fontSize: 28,            // font-size of a digit by pixels
                lang: 'en',              // language of caption
                seconds: 0,              // timer's countdown value in seconds
                start: true,             // true to start timer immediately
                theme: "white",          // 'white' or 'black' theme fo timer's view
                
                vals: [0, 0, 0, 0, 0, 0, 0, 0, 0],  // private, current value of each digit
                limits: [9, 9, 9, 2, 9, 5, 9, 5, 9],// private, max value of each digit
                iSec: 8,            // private, index of second digit
                iHour: 4,           // private, index of hour digit
                tickTimeout: 1000,  // timeout betweet each timer tick in miliseconds
                intervalId: null    // private
            },
            method, options = {};

        for(var i = 0, arg; arg = arguments[i]; ++i){
            if(i == 0 && typeof arg === "string"){
                method = arg;
            }else{
                if(typeof arg == "object"){
                    if(typeof arg.getTime === 'function'){
                        options.timeTo = arg;
                    }else {
                        options = $.extend(options, arg);
                    }
                }else{
                    if(typeof arg == "function"){
                        options.callback = arg;
                    }else{
                        var v = parseInt(arg);
                        if(!isNaN(v)){
                            options.seconds = v;
                        }
                    }
                }
            }
        }
        // set time for countdown to
        if(options.timeTo){
            var time,
                now = (new Date()).getTime();

            if(options.timeTo.getTime){ // set time as date object
                time = options.timeTo.getTime();
            }else if(typeof options.timeTo === 'number'){  // set time as integer in millisec
                time = options.timeTo;
            }
            if(options.timeTo > now){
                options.seconds = Math.floor((time - now) / 1000);
            }
        }else if(options.time || !options.seconds){
            var time = options.time;

            if(!time) time = new Date();

            if(typeof time === 'object' && time.getTime){
                options.seconds = time.getHours()*3600 + time.getMinutes()*60 + time.getSeconds();
                options.countdown = false;
            }else if(typeof time === 'string'){
                var tt = time.split(':'),
                    sec = 0, m = 1, t;

                while(t = tt.pop()){
                    sec += t*m;
                    m *= 60;
                }
                options.seconds = sec;
                options.countdown = false;
            }
        }
        if(options.countdown !== false && options.seconds > 86400 && typeof options.displayDays === 'undefined') {
            var days = Math.floor(options.seconds / 86400);
            options.displayDays = days < 10 && 1 || days < 100 && 2 || 3;
        }else if(options.displayDays === true) {
            options.displayDays = 3;
        }else if(options.displayDays) {
            options.displayDays = options.displayDays > 0 ? Math.floor(options.displayDays) : 3;
        }

        
        return this.each(function(){
            var $this = $(this),
                data = $this.data(),
                i;

            if(!data.vals){ // new clock
                data = $.extend(defaults, options);
                data.height = Math.round(data.fontSize*100/93);
                data.width = Math.round(data.fontSize*.8 + data.height*.13);
                data.displayHours = !!(data.displayDays || data.displayHours);
                $this
                    .addClass('timeTo')
                    .addClass('timeTo-'+ data.theme)
                    .css({
                        fontFamily: data.fontFamily,
                        fontSize: data.fontSize +'px'
                    });

                var left = Math.round(data.height / 10),
                    ulhtml = '<ul><li>0</li><li>0</li></ul></div>',
                    style = '',
                    dhtml1 = '<div class="first">'+ ulhtml,
                    dhtml2 = '<div>'+ ulhtml,
                    dot2 = '<span>:</span>',
                    maxWidth = '',
                    displaySecVisible = (data.displaySeconds) ? ''  : 'display: none;',
                    captionSize = data.captionSize || Math.round(data.fontSize * 0.43);

                    thtml = (data.displayCaptions ?
                        (data.displayHours
                            ? '<figure>$1<figcaption style="font-size:'+ captionSize +'px">'+ dictionary[data.lang].hours +'</figcaption></figure>'+ dot2
                            : '') +
                        '<figure>$1<figcaption style="font-size:'+ captionSize +'px">'+ dictionary[data.lang].min +'</figcaption></figure>'+ '<i style="font-style: normal !important; '+ displaySecVisible +'">'+dot2+'</i>' +
                        '<figure style="'+displaySecVisible+'">$1<figcaption style="font-size:'+ captionSize +'px">'+ dictionary[data.lang].sec +'</figcaption></figure>'
                        : (data.displayHours ? '$1'+ dot2 : '') +'$1'+ dot2 +'$1'
                    ).replace(/\$1/g, dhtml1 + dhtml2);

                if(data.displayDays > 0){
                    var marginRight = data.fontSize * 0.4,
                        dhtml = dhtml1;
                    for(i = data.displayDays - 1; i > 0; i--) {
                        dhtml += i === 1 ? dhtml2.replace('">', ' margin-right:'+ Math.round(marginRight) +'px">') : dhtml2;
                    }
                    thtml = (data.displayCaptions ?
                        '<figure>$1<figcaption style="font-size:'+ captionSize +'px;">'+ dictionary[data.lang].days +'</figcaption></figure>'
                        : '$1').replace(
                            /\$1/, dhtml
                        ) + dot2 + thtml;
                }
                $this.html(thtml);
            }else{ // exists clock
                if(data.intervalId){
                    clearInterval(data.intervalId);
                    data.intervalId = null;
                }
                $.extend(data, options);
            }
            
            var $digits = $this.find('div');

            if($digits.length < data.vals.length){
                var dif = data.vals.length - $digits.length,
                    vals = data.vals, limits = data.limits;

                data.vals = [];
                data.limits = [];
                for(i = 0; i < $digits.length; i++){
                    data.vals[i] = vals[dif + i];
                    data.limits[i] = limits[dif + i];
                }
                data.iSec = data.vals.length - 1;
                data.iHour = data.vals.length - 5;
            }
            data.sec = data.seconds;
            $this.data(data);
            
            if(method && methods[method]){
                methods[ method ].call($this, data.seconds);
            }else if(data.start){
                methods.start.call($this, data.seconds);
            }else {
                init.call($this, data.seconds);
            }
        });
    };

    function init(sec){
        var data = this.data(),
            $digits = this.find('ul');

        if (!data.vals || $digits.length === 0) return;

        if(!sec) sec = data.seconds;

        var isInterval = false;
        if (data.intervalId) {
            isInterval = true;
            clearTimeout(data.intervalId);
        }

        var days = Math.floor(sec / 86400),
            rest = days * 86400,
            h = Math.floor((sec - rest) / 3600);

        rest += h * 3600;

        var m = Math.floor((sec - rest) / 60);
        
        rest += m * 60;
        
        var s = sec - rest,
            str = (days < 100 ? '0' + (days < 10 ? '0' : '') : '') + days + (h < 10 ? '0' : '') + h + (m < 10 ? '0' : '') + m + (s < 10 ? '0' : '') + s;

        for (var i = data.vals.length - 1, j = str.length - 1, v; i >= 0; i--, j--) {
            v = parseInt(str.substr(j, 1));
            data.vals[i] = v;
            $digits.eq(i).children().html(v);
        }
        if (isInterval) {
            var me = this;
            data.ttStartTime = Date.now();
            data.intervalId = setTimeout(function(){ tick.call(me); }, 1000);
            this.data('intervalId', data.intervalId);
        }
    }
        
    /**
     * Switch specified digit by digit index
     * @param {number} - digit index
     */
    function tick(digit) {

        var $digits = this.find('ul'),
            data = this.data();

        if (!data.vals || $digits.length == 0){
            if(data.intervalId){
                clearTimeout(data.intervalId);
                this.data('intervalId', null);
            }
            if(data.callback) data.callback();

            return;
        }
        if (digit == undefined) {
            digit = data.iSec;
        }

        var n = data.vals[digit],
            $ul = $digits.eq(digit),
            $li = $ul.children(),
            step = data.countdown ? -1 : 1,
            topTransition = data.topTransition || 50;

        // @OmertaModification Add configurable transition dimensions, before was just -50px
        var sTopTransition = topTransition * -1;
        sTopTransition = sTopTransition+'px';

        $li.eq(1).html(n);
        n += step;

        if(digit == data.iSec){
            var tickTimeout = data.tickTimeout,
                timeDiff = (new Date()).getTime() - data.ttStartTime;

            data.sec += step;

            tickTimeout += Math.abs(data.seconds - data.sec) * tickTimeout - timeDiff;

            data.intervalId = setTimeout(function(){ tick.call(me); }, tickTimeout);
        }
        
        if(n < 0 || n > data.limits[digit]) {
            if(n < 0)
            {
                n = data.limits[digit];
                if(digit == data.iHour && data.displayDays > 0 && digit > 0 && data.vals[digit-1] == 0) // fix for hours when day changing
                    n = 3;
            }
            else 
                n = 0;
            if(digit > 0){
                tick.call(this, digit-1);
            }
        }
        //$ul.removeClass('transition');
        //$ul.css({top:"-" + data.height + "px"});
        $li.eq(0).html(n);
        
        var me = this;
        
        if($.support.transition){
            $ul.addClass('transition');
            $ul.css({top:0});

            setTimeout(function(){
                $ul.removeClass('transition');
                $li.eq(1).html(n);
                $ul.css({top: sTopTransition});

                if(step > 0 || digit != data.iSec) return;

                if(data.sec == data.countdownAlertLimit){
                    $digits.parent().addClass('timeTo-alert');
                }
                if(data.sec === 0){
                    $digits.parent().removeClass('timeTo-alert');

                    if(data.intervalId){
                        clearTimeout(data.intervalId);
                        me.data('intervalId', null);
                    }

                    if(typeof data.callback === 'function') data.callback();
                }
            }, 410);
        }else{
            $ul.stop().animate({top:0}, 400, digit != data.iSec ? null : function(){
                $li.eq(1).html(n);
                $ul.css({top: sTopTransition});
                if(step > 0 || digit != data.iSec) return;

                if(data.sec == data.countdownAlertLimit){
                    $digits.parent().addClass('timeTo-alert');
                }else if(data.sec == 0){
                    $digits.parent().removeClass('timeTo-alert');

                    if(data.intervalId){
                        clearTimeout(data.intervalId);
                        me.data('intervalId', null);
                    }

                    if(typeof data.callback === 'function') data.callback();
                }
            });
        }
        data.vals[digit] = n;
        //this.data('vals', data.vals);
    }

    return jQuery;
    
}));

!function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('jquery'));
    } else {
        factory(root.jQuery);
    }
}(this, function($) {

    /*!
     @package noty - jQuery Notification Plugin
     @version version: 2.3.7
     @contributors https://github.com/needim/noty/graphs/contributors

     @documentation Examples and Documentation - http://needim.github.com/noty/

     @license Licensed under the MIT licenses: http://www.opensource.org/licenses/mit-license.php
     */

    if(typeof Object.create !== 'function') {
        Object.create = function(o) {
            function F() {
            }

            F.prototype = o;
            return new F();
        };
    }

    var NotyObject = {

        init: function(options) {

            // Mix in the passed in options with the default options
            this.options = $.extend({}, $.noty.defaults, options);

            this.options.layout = (this.options.custom) ? $.noty.layouts['inline'] : $.noty.layouts[this.options.layout];

            if($.noty.themes[this.options.theme])
                this.options.theme = $.noty.themes[this.options.theme];
            else
                options.themeClassName = this.options.theme;

            delete options.layout;
            delete options.theme;

            this.options = $.extend({}, this.options, this.options.layout.options);
            this.options.id = 'noty_' + (new Date().getTime() * Math.floor(Math.random() * 1000000));

            this.options = $.extend({}, this.options, options);

            // Build the noty dom initial structure
            this._build();

            // return this so we can chain/use the bridge with less code.
            return this;
        }, // end init

        _build: function() {

            // Generating noty bar
            var $bar = $('<div class="noty_bar noty_type_' + this.options.type + '"></div>').attr('id', this.options.id);
            $bar.append(this.options.template).find('.noty_text').html(this.options.text);

            this.$bar = (this.options.layout.parent.object !== null) ? $(this.options.layout.parent.object).css(this.options.layout.parent.css).append($bar) : $bar;

            if(this.options.themeClassName)
                this.$bar.addClass(this.options.themeClassName).addClass('noty_container_type_' + this.options.type);

            // Set buttons if available
            if(this.options.buttons) {

                // If we have button disable closeWith & timeout options
                this.options.closeWith = [];
                this.options.timeout = false;

                var $buttons = $('<div/>').addClass('noty_buttons');

                (this.options.layout.parent.object !== null) ? this.$bar.find('.noty_bar').append($buttons) : this.$bar.append($buttons);

                var self = this;

                $.each(this.options.buttons, function(i, button) {
                    var $button = $('<button/>').addClass((button.addClass) ? button.addClass : 'gray').html(button.text).attr('id', button.id ? button.id : 'button-' + i)
                        .attr('title', button.title)
                        .appendTo(self.$bar.find('.noty_buttons'))
                        .on('click', function(event) {
                            if($.isFunction(button.onClick)) {
                                button.onClick.call($button, self, event);
                            }
                        });
                });
            }

            // For easy access
            this.$message = this.$bar.find('.noty_message');
            this.$closeButton = this.$bar.find('.noty_close');
            this.$buttons = this.$bar.find('.noty_buttons');

            $.noty.store[this.options.id] = this; // store noty for api

        }, // end _build

        show: function() {

            var self = this;

            (self.options.custom) ? self.options.custom.find(self.options.layout.container.selector).append(self.$bar) : $(self.options.layout.container.selector).append(self.$bar);

            if(self.options.theme && self.options.theme.style)
                self.options.theme.style.apply(self);

            ($.type(self.options.layout.css) === 'function') ? this.options.layout.css.apply(self.$bar) : self.$bar.css(this.options.layout.css || {});

            self.$bar.addClass(self.options.layout.addClass);

            self.options.layout.container.style.apply($(self.options.layout.container.selector), [self.options.within]);

            self.showing = true;

            if(self.options.theme && self.options.theme.style)
                self.options.theme.callback.onShow.apply(this);

            if($.inArray('click', self.options.closeWith) > -1)
                self.$bar.css('cursor', 'pointer').one('click', function(evt) {
                    self.stopPropagation(evt);
                    if(self.options.callback.onCloseClick) {
                        self.options.callback.onCloseClick.apply(self);
                    }
                    self.close();
                });

            if($.inArray('hover', self.options.closeWith) > -1)
                self.$bar.one('mouseenter', function() {
                    self.close();
                });

            if($.inArray('button', self.options.closeWith) > -1)
                self.$closeButton.one('click', function(evt) {
                    self.stopPropagation(evt);
                    self.close();
                });

            if($.inArray('button', self.options.closeWith) == -1)
                self.$closeButton.remove();

            if(self.options.callback.onShow)
                self.options.callback.onShow.apply(self);

            if (typeof self.options.animation.open == 'string') {
                self.$bar.css('height', self.$bar.innerHeight());
                self.$bar.on('click',function(e){
                    self.wasClicked = true;
                });
                self.$bar.show().addClass(self.options.animation.open).one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function() {
                    if(self.options.callback.afterShow) self.options.callback.afterShow.apply(self);
                    self.showing = false;
                    self.shown = true;
                    if(self.hasOwnProperty('wasClicked')){
                        self.$bar.off('click',function(e){
                            self.wasClicked = true;
                        });
                        self.close();
                    }
                });

            } else {
                self.$bar.animate(
                    self.options.animation.open,
                    self.options.animation.speed,
                    self.options.animation.easing,
                    function() {
                        if(self.options.callback.afterShow) self.options.callback.afterShow.apply(self);
                        self.showing = false;
                        self.shown = true;
                    });
            }

            // If noty is have a timeout option
            if(self.options.timeout)
                self.$bar.delay(self.options.timeout).promise().done(function() {
                    self.close();
                });

            return this;

        }, // end show

        close: function() {

            if(this.closed) return;
            if(this.$bar && this.$bar.hasClass('i-am-closing-now')) return;

            var self = this;

            if(this.showing) {
                self.$bar.queue(
                    function() {
                        self.close.apply(self);
                    }
                );
                return;
            }

            if(!this.shown && !this.showing) { // If we are still waiting in the queue just delete from queue
                var queue = [];
                $.each($.noty.queue, function(i, n) {
                    if(n.options.id != self.options.id) {
                        queue.push(n);
                    }
                });
                $.noty.queue = queue;
                return;
            }

            self.$bar.addClass('i-am-closing-now');

            if(self.options.callback.onClose) {
                self.options.callback.onClose.apply(self);
            }

            if (typeof self.options.animation.close == 'string') {
                self.$bar.addClass(self.options.animation.close).one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function() {
                    if(self.options.callback.afterClose) self.options.callback.afterClose.apply(self);
                    self.closeCleanUp();
                });
            } else {
                self.$bar.clearQueue().stop().animate(
                    self.options.animation.close,
                    self.options.animation.speed,
                    self.options.animation.easing,
                    function() {
                        if(self.options.callback.afterClose) self.options.callback.afterClose.apply(self);
                    })
                    .promise().done(function() {
                        self.closeCleanUp();
                    });
            }

        }, // end close

        closeCleanUp: function() {

            var self = this;

            // Modal Cleaning
            if(self.options.modal) {
                $.notyRenderer.setModalCount(-1);
                if($.notyRenderer.getModalCount() == 0) $('.noty_modal').fadeOut(self.options.animation.fadeSpeed, function() {
                    $(this).remove();
                });
            }

            // Layout Cleaning
            $.notyRenderer.setLayoutCountFor(self, -1);
            if($.notyRenderer.getLayoutCountFor(self) == 0) $(self.options.layout.container.selector).remove();

            // Make sure self.$bar has not been removed before attempting to remove it
            if(typeof self.$bar !== 'undefined' && self.$bar !== null) {

                if (typeof self.options.animation.close == 'string') {
                    self.$bar.css('transition', 'all 100ms ease').css('border', 0).css('margin', 0).height(0);
                    self.$bar.one('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function() {
                        self.$bar.remove();
                        self.$bar = null;
                        self.closed = true;

                        if(self.options.theme.callback && self.options.theme.callback.onClose) {
                            self.options.theme.callback.onClose.apply(self);
                        }
                    });
                } else {
                    self.$bar.remove();
                    self.$bar = null;
                    self.closed = true;
                }
            }

            delete $.noty.store[self.options.id]; // deleting noty from store

            if(self.options.theme.callback && self.options.theme.callback.onClose) {
                self.options.theme.callback.onClose.apply(self);
            }

            if(!self.options.dismissQueue) {
                // Queue render
                $.noty.ontap = true;

                $.notyRenderer.render();
            }

            if(self.options.maxVisible > 0 && self.options.dismissQueue) {
                $.notyRenderer.render();
            }

        }, // end close clean up

        setText: function(text) {
            if(!this.closed) {
                this.options.text = text;
                this.$bar.find('.noty_text').html(text);
            }
            return this;
        },

        setType: function(type) {
            if(!this.closed) {
                this.options.type = type;
                this.options.theme.style.apply(this);
                this.options.theme.callback.onShow.apply(this);
            }
            return this;
        },

        setTimeout: function(time) {
            if(!this.closed) {
                var self = this;
                this.options.timeout = time;
                self.$bar.delay(self.options.timeout).promise().done(function() {
                    self.close();
                });
            }
            return this;
        },

        stopPropagation: function(evt) {
            evt = evt || window.event;
            if(typeof evt.stopPropagation !== "undefined") {
                evt.stopPropagation();
            }
            else {
                evt.cancelBubble = true;
            }
        },

        closed : false,
        showing: false,
        shown  : false

    }; // end NotyObject

    $.notyRenderer = {};

    $.notyRenderer.init = function(options) {

        // Renderer creates a new noty
        var notification = Object.create(NotyObject).init(options);

        if(notification.options.killer)
            $.noty.closeAll();

        (notification.options.force) ? $.noty.queue.unshift(notification) : $.noty.queue.push(notification);

        $.notyRenderer.render();

        return ($.noty.returns == 'object') ? notification : notification.options.id;
    };

    $.notyRenderer.render = function() {

        var instance = $.noty.queue[0];

        if($.type(instance) === 'object') {
            if(instance.options.dismissQueue) {
                if(instance.options.maxVisible > 0) {
                    if($(instance.options.layout.container.selector + ' > li').length < instance.options.maxVisible) {
                        $.notyRenderer.show($.noty.queue.shift());
                    }
                    else {

                    }
                }
                else {
                    $.notyRenderer.show($.noty.queue.shift());
                }
            }
            else {
                if($.noty.ontap) {
                    $.notyRenderer.show($.noty.queue.shift());
                    $.noty.ontap = false;
                }
            }
        }
        else {
            $.noty.ontap = true; // Queue is over
        }

    };

    $.notyRenderer.show = function(notification) {

        if(notification.options.modal) {
            $.notyRenderer.createModalFor(notification);
            $.notyRenderer.setModalCount(+1);
        }

        // Where is the container?
        if(notification.options.custom) {
            if(notification.options.custom.find(notification.options.layout.container.selector).length == 0) {
                notification.options.custom.append($(notification.options.layout.container.object).addClass('i-am-new'));
            }
            else {
                notification.options.custom.find(notification.options.layout.container.selector).removeClass('i-am-new');
            }
        }
        else {
            if($(notification.options.layout.container.selector).length == 0) {
                $('body').append($(notification.options.layout.container.object).addClass('i-am-new'));
            }
            else {
                $(notification.options.layout.container.selector).removeClass('i-am-new');
            }
        }

        $.notyRenderer.setLayoutCountFor(notification, +1);

        notification.show();
    };

    $.notyRenderer.createModalFor = function(notification) {
        if($('.noty_modal').length == 0) {
            var modal = $('<div/>').addClass('noty_modal').addClass(notification.options.theme).data('noty_modal_count', 0);

            if(notification.options.theme.modal && notification.options.theme.modal.css)
                modal.css(notification.options.theme.modal.css);

            modal.prependTo($('body')).fadeIn(notification.options.animation.fadeSpeed);

            if($.inArray('backdrop', notification.options.closeWith) > -1)
                modal.on('click', function(e) {
                    $.noty.closeAll();
                });
        }
    };

    $.notyRenderer.getLayoutCountFor = function(notification) {
        return $(notification.options.layout.container.selector).data('noty_layout_count') || 0;
    };

    $.notyRenderer.setLayoutCountFor = function(notification, arg) {
        return $(notification.options.layout.container.selector).data('noty_layout_count', $.notyRenderer.getLayoutCountFor(notification) + arg);
    };

    $.notyRenderer.getModalCount = function() {
        return $('.noty_modal').data('noty_modal_count') || 0;
    };

    $.notyRenderer.setModalCount = function(arg) {
        return $('.noty_modal').data('noty_modal_count', $.notyRenderer.getModalCount() + arg);
    };

    // This is for custom container
    $.fn.noty = function(options) {
        options.custom = $(this);
        return $.notyRenderer.init(options);
    };

    $.noty = {};
    $.noty.queue = [];
    $.noty.ontap = true;
    $.noty.layouts = {};
    $.noty.themes = {};
    $.noty.returns = 'object';
    $.noty.store = {};

    $.noty.get = function(id) {
        return $.noty.store.hasOwnProperty(id) ? $.noty.store[id] : false;
    };

    $.noty.close = function(id) {
        return $.noty.get(id) ? $.noty.get(id).close() : false;
    };

    $.noty.setText = function(id, text) {
        return $.noty.get(id) ? $.noty.get(id).setText(text) : false;
    };

    $.noty.setType = function(id, type) {
        return $.noty.get(id) ? $.noty.get(id).setType(type) : false;
    };

    $.noty.clearQueue = function() {
        $.noty.queue = [];
    };

    $.noty.closeAll = function() {
        $.noty.clearQueue();
        $.each($.noty.store, function(id, noty) {
            noty.close();
        });
    };

    var windowAlert = window.alert;

    $.noty.consumeAlert = function(options) {
        window.alert = function(text) {
            if(options)
                options.text = text;
            else
                options = {text: text};

            $.notyRenderer.init(options);
        };
    };

    $.noty.stopConsumeAlert = function() {
        window.alert = windowAlert;
    };

    $.noty.defaults = {
        layout      : 'top',
        theme       : 'defaultTheme',
        type        : 'alert',
        text        : '',
        dismissQueue: true,
        template    : '<div class="noty_message"><span class="noty_text"></span><div class="noty_close"></div></div>',
        animation   : {
            open  : {height: 'toggle'},
            close : {height: 'toggle'},
            easing: 'swing',
            speed : 500,
            fadeSpeed: 'fast',
        },
        timeout     : false,
        force       : false,
        modal       : false,
        maxVisible  : 5,
        killer      : false,
        closeWith   : ['click'],
        callback    : {
            onShow      : function() {
            },
            afterShow   : function() {
            },
            onClose     : function() {
            },
            afterClose  : function() {
            },
            onCloseClick: function() {
            }
        },
        buttons     : false
    };

    $(window).on('resize', function() {
        $.each($.noty.layouts, function(index, layout) {
            layout.container.style.apply($(layout.container.selector));
        });
    });

    // Helpers
    window.noty = function noty(options) {
        return $.notyRenderer.init(options);
    };

    $.noty.layouts.bottom = {
        name     : 'bottom',
        options  : {},
        container: {
            object  : '<ul id="noty_bottom_layout_container" />',
            selector: 'ul#noty_bottom_layout_container',
            style   : function() {
                $(this).css({
                    bottom       : 0,
                    left         : '5%',
                    position     : 'fixed',
                    width        : '90%',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 9999999
                });
            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none'
        },
        addClass : ''
    };

    $.noty.layouts.bottomCenter = {
        name     : 'bottomCenter',
        options  : { // overrides options

        },
        container: {
            object  : '<ul id="noty_bottomCenter_layout_container" />',
            selector: 'ul#noty_bottomCenter_layout_container',
            style   : function() {
                $(this).css({
                    bottom       : 20,
                    left         : 0,
                    position     : 'fixed',
                    width        : '310px',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 10000000
                });

                $(this).css({
                    left: ($(window).width() - $(this).outerWidth(false)) / 2 + 'px'
                });
            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none',
            width  : '310px'
        },
        addClass : ''
    };


    $.noty.layouts.bottomLeft = {
        name     : 'bottomLeft',
        options  : { // overrides options

        },
        container: {
            object  : '<ul id="noty_bottomLeft_layout_container" />',
            selector: 'ul#noty_bottomLeft_layout_container',
            style   : function() {
                $(this).css({
                    bottom       : 20,
                    left         : 20,
                    position     : 'fixed',
                    width        : '310px',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 10000000
                });

                if(window.innerWidth < 600) {
                    $(this).css({
                        left: 5
                    });
                }
            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none',
            width  : '310px'
        },
        addClass : ''
    };
    $.noty.layouts.bottomRight = {
        name     : 'bottomRight',
        options  : { // overrides options

        },
        container: {
            object  : '<ul id="noty_bottomRight_layout_container" />',
            selector: 'ul#noty_bottomRight_layout_container',
            style   : function() {
                $(this).css({
                    bottom       : 20,
                    right        : 20,
                    position     : 'fixed',
                    width        : '310px',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 10000000
                });

                if(window.innerWidth < 600) {
                    $(this).css({
                        right: 5
                    });
                }
            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none',
            width  : '310px'
        },
        addClass : ''
    };
    $.noty.layouts.center = {
        name     : 'center',
        options  : { // overrides options

        },
        container: {
            object  : '<ul id="noty_center_layout_container" />',
            selector: 'ul#noty_center_layout_container',
            style   : function() {
                $(this).css({
                    position     : 'fixed',
                    width        : '310px',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 10000000
                });

                // getting hidden height
                var dupe = $(this).clone().css({visibility: "hidden", display: "block", position: "absolute", top: 0, left: 0}).attr('id', 'dupe');
                $("body").append(dupe);
                dupe.find('.i-am-closing-now').remove();
                dupe.find('li').css('display', 'block');
                var actual_height = dupe.height();
                dupe.remove();

                if($(this).hasClass('i-am-new')) {
                    $(this).css({
                        left: ($(window).width() - $(this).outerWidth(false)) / 2 + 'px',
                        top : ($(window).height() - actual_height) / 2 + 'px'
                    });
                }
                else {
                    $(this).animate({
                        left: ($(window).width() - $(this).outerWidth(false)) / 2 + 'px',
                        top : ($(window).height() - actual_height) / 2 + 'px'
                    }, 500);
                }

            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none',
            width  : '310px'
        },
        addClass : ''
    };
    $.noty.layouts.centerLeft = {
        name     : 'centerLeft',
        options  : { // overrides options

        },
        container: {
            object  : '<ul id="noty_centerLeft_layout_container" />',
            selector: 'ul#noty_centerLeft_layout_container',
            style   : function() {
                $(this).css({
                    left         : 20,
                    position     : 'fixed',
                    width        : '310px',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 10000000
                });

                // getting hidden height
                var dupe = $(this).clone().css({visibility: "hidden", display: "block", position: "absolute", top: 0, left: 0}).attr('id', 'dupe');
                $("body").append(dupe);
                dupe.find('.i-am-closing-now').remove();
                dupe.find('li').css('display', 'block');
                var actual_height = dupe.height();
                dupe.remove();

                if($(this).hasClass('i-am-new')) {
                    $(this).css({
                        top: ($(window).height() - actual_height) / 2 + 'px'
                    });
                }
                else {
                    $(this).animate({
                        top: ($(window).height() - actual_height) / 2 + 'px'
                    }, 500);
                }

                if(window.innerWidth < 600) {
                    $(this).css({
                        left: 5
                    });
                }

            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none',
            width  : '310px'
        },
        addClass : ''
    };

    $.noty.layouts.centerRight = {
        name     : 'centerRight',
        options  : { // overrides options

        },
        container: {
            object  : '<ul id="noty_centerRight_layout_container" />',
            selector: 'ul#noty_centerRight_layout_container',
            style   : function() {
                $(this).css({
                    right        : 20,
                    position     : 'fixed',
                    width        : '310px',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 10000000
                });

                // getting hidden height
                var dupe = $(this).clone().css({visibility: "hidden", display: "block", position: "absolute", top: 0, left: 0}).attr('id', 'dupe');
                $("body").append(dupe);
                dupe.find('.i-am-closing-now').remove();
                dupe.find('li').css('display', 'block');
                var actual_height = dupe.height();
                dupe.remove();

                if($(this).hasClass('i-am-new')) {
                    $(this).css({
                        top: ($(window).height() - actual_height) / 2 + 'px'
                    });
                }
                else {
                    $(this).animate({
                        top: ($(window).height() - actual_height) / 2 + 'px'
                    }, 500);
                }

                if(window.innerWidth < 600) {
                    $(this).css({
                        right: 5
                    });
                }

            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none',
            width  : '310px'
        },
        addClass : ''
    };
    $.noty.layouts.inline = {
        name     : 'inline',
        options  : {},
        container: {
            object  : '<ul class="noty_inline_layout_container" />',
            selector: 'ul.noty_inline_layout_container',
            style   : function() {
                $(this).css({
                    width        : '100%',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 9999999
                });
            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none'
        },
        addClass : ''
    };
    $.noty.layouts.top = {
        name     : 'top',
        options  : {},
        container: {
            object  : '<ul id="noty_top_layout_container" />',
            selector: 'ul#noty_top_layout_container',
            style   : function() {
                $(this).css({
                    top          : 0,
                    left         : '5%',
                    position     : 'fixed',
                    width        : '90%',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 9999999
                });
            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none'
        },
        addClass : ''
    };
    $.noty.layouts.topCenter = {
        name     : 'topCenter',
        options  : { // overrides options

        },
        container: {
            object  : '<ul id="noty_topCenter_layout_container" />',
            selector: 'ul#noty_topCenter_layout_container',
            style   : function() {
                $(this).css({
                    top          : 20,
                    left         : 0,
                    position     : 'fixed',
                    width        : '310px',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 10000000
                });

                $(this).css({
                    left: ($(window).width() - $(this).outerWidth(false)) / 2 + 'px'
                });
            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none',
            width  : '310px'
        },
        addClass : ''
    };

    $.noty.layouts.topLeft = {
        name     : 'topLeft',
        options  : { // overrides options

        },
        container: {
            object  : '<ul id="noty_topLeft_layout_container" />',
            selector: 'ul#noty_topLeft_layout_container',
            style   : function() {
                $(this).css({
                    top          : 20,
                    left         : 20,
                    position     : 'fixed',
                    width        : '310px',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 10000000
                });

                if(window.innerWidth < 600) {
                    $(this).css({
                        left: 5
                    });
                }
            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none',
            width  : '310px'
        },
        addClass : ''
    };
    $.noty.layouts.topRight = {
        name     : 'topRight',
        options  : { // overrides options

        },
        container: {
            object  : '<ul id="noty_topRight_layout_container" />',
            selector: 'ul#noty_topRight_layout_container',
            style   : function() {
                $(this).css({
                    top          : 20,
                    right        : 20,
                    position     : 'fixed',
                    width        : '310px',
                    height       : 'auto',
                    margin       : 0,
                    padding      : 0,
                    listStyleType: 'none',
                    zIndex       : 10000000
                });

                if(window.innerWidth < 600) {
                    $(this).css({
                        right: 5
                    });
                }
            }
        },
        parent   : {
            object  : '<li />',
            selector: 'li',
            css     : {}
        },
        css      : {
            display: 'none',
            width  : '310px'
        },
        addClass : ''
    };
    $.noty.themes.bootstrapTheme = {
        name: 'bootstrapTheme',
        modal: {
            css: {
                position: 'fixed',
                width: '100%',
                height: '100%',
                backgroundColor: '#000',
                zIndex: 10000,
                opacity: 0.6,
                display: 'none',
                left: 0,
                top: 0
            }
        },
        style: function() {

            var containerSelector = this.options.layout.container.selector;
            $(containerSelector).addClass('list-group');

            this.$closeButton.append('<span aria-hidden="true">&times;</span><span class="sr-only">Close</span>');
            this.$closeButton.addClass('close');

            this.$bar.addClass( "list-group-item" ).css('padding', '0px');

            switch (this.options.type) {
                case 'alert': case 'notification':
                this.$bar.addClass( "list-group-item-info" );
                break;
                case 'warning':
                    this.$bar.addClass( "list-group-item-warning" );
                    break;
                case 'error':
                    this.$bar.addClass( "list-group-item-danger" );
                    break;
                case 'information':
                    this.$bar.addClass("list-group-item-info");
                    break;
                case 'success':
                    this.$bar.addClass( "list-group-item-success" );
                    break;
            }

            this.$message.css({
                fontSize: '13px',
                lineHeight: '16px',
                textAlign: 'center',
                padding: '8px 10px 9px',
                width: 'auto',
                position: 'relative'
            });
        },
        callback: {
            onShow: function() {  },
            onClose: function() {  }
        }
    };


    $.noty.themes.defaultTheme = {
        name    : 'defaultTheme',
        helpers : {
            borderFix: function() {
                if(this.options.dismissQueue) {
                    var selector = this.options.layout.container.selector + ' ' + this.options.layout.parent.selector;
                    switch(this.options.layout.name) {
                        case 'top':
                            $(selector).css({borderRadius: '0px 0px 0px 0px'});
                            $(selector).last().css({borderRadius: '0px 0px 5px 5px'});
                            break;
                        case 'topCenter':
                        case 'topLeft':
                        case 'topRight':
                        case 'bottomCenter':
                        case 'bottomLeft':
                        case 'bottomRight':
                        case 'center':
                        case 'centerLeft':
                        case 'centerRight':
                        case 'inline':
                            $(selector).css({borderRadius: '0px 0px 0px 0px'});
                            $(selector).first().css({'border-top-left-radius': '5px', 'border-top-right-radius': '5px'});
                            $(selector).last().css({'border-bottom-left-radius': '5px', 'border-bottom-right-radius': '5px'});
                            break;
                        case 'bottom':
                            $(selector).css({borderRadius: '0px 0px 0px 0px'});
                            $(selector).first().css({borderRadius: '5px 5px 0px 0px'});
                            break;
                        default:
                            break;
                    }
                }
            }
        },
        modal   : {
            css: {
                position       : 'fixed',
                width          : '100%',
                height         : '100%',
                backgroundColor: '#000',
                zIndex         : 10000,
                opacity        : 0.6,
                display        : 'none',
                left           : 0,
                top            : 0
            }
        },
        style   : function() {

            this.$bar.css({
                overflow  : 'hidden',
                background: "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAoCAQAAAClM0ndAAAAhklEQVR4AdXO0QrCMBBE0bttkk38/w8WRERpdyjzVOc+HxhIHqJGMQcFFkpYRQotLLSw0IJ5aBdovruMYDA/kT8plF9ZKLFQcgF18hDj1SbQOMlCA4kao0iiXmah7qBWPdxpohsgVZyj7e5I9KcID+EhiDI5gxBYKLBQYKHAQoGFAoEks/YEGHYKB7hFxf0AAAAASUVORK5CYII=') repeat-x scroll left top #fff"
            });

            this.$message.css({
                fontSize  : '13px',
                lineHeight: '16px',
                textAlign : 'center',
                padding   : '8px 10px 9px',
                width     : 'auto',
                position  : 'relative'
            });

            this.$closeButton.css({
                position  : 'absolute',
                top       : 4, right: 4,
                width     : 10, height: 10,
                background: "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAxUlEQVR4AR3MPUoDURSA0e++uSkkOxC3IAOWNtaCIDaChfgXBMEZbQRByxCwk+BasgQRZLSYoLgDQbARxry8nyumPcVRKDfd0Aa8AsgDv1zp6pYd5jWOwhvebRTbzNNEw5BSsIpsj/kurQBnmk7sIFcCF5yyZPDRG6trQhujXYosaFoc+2f1MJ89uc76IND6F9BvlXUdpb6xwD2+4q3me3bysiHvtLYrUJto7PD/ve7LNHxSg/woN2kSz4txasBdhyiz3ugPGetTjm3XRokAAAAASUVORK5CYII=)",
                display   : 'none',
                cursor    : 'pointer'
            });

            this.$buttons.css({
                padding        : 5,
                textAlign      : 'right',
                borderTop      : '1px solid #ccc',
                backgroundColor: '#fff'
            });

            this.$buttons.find('button').css({
                marginLeft: 5
            });

            this.$buttons.find('button:first').css({
                marginLeft: 0
            });

            this.$bar.on({
                mouseenter: function() {
                    $(this).find('.noty_close').stop().fadeTo('normal', 1);
                },
                mouseleave: function() {
                    $(this).find('.noty_close').stop().fadeTo('normal', 0);
                }
            });

            switch(this.options.layout.name) {
                case 'top':
                    this.$bar.css({
                        borderRadius: '0px 0px 5px 5px',
                        borderBottom: '2px solid #eee',
                        borderLeft  : '2px solid #eee',
                        borderRight : '2px solid #eee',
                        boxShadow   : "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    break;
                case 'topCenter':
                case 'center':
                case 'bottomCenter':
                case 'inline':
                    this.$bar.css({
                        borderRadius: '5px',
                        border      : '1px solid #eee',
                        boxShadow   : "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    this.$message.css({fontSize: '13px', textAlign: 'center'});
                    break;
                case 'topLeft':
                case 'topRight':
                case 'bottomLeft':
                case 'bottomRight':
                case 'centerLeft':
                case 'centerRight':
                    this.$bar.css({
                        borderRadius: '5px',
                        border      : '1px solid #eee',
                        boxShadow   : "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    this.$message.css({fontSize: '13px', textAlign: 'left'});
                    break;
                case 'bottom':
                    this.$bar.css({
                        borderRadius: '5px 5px 0px 0px',
                        borderTop   : '2px solid #eee',
                        borderLeft  : '2px solid #eee',
                        borderRight : '2px solid #eee',
                        boxShadow   : "0 -2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    break;
                default:
                    this.$bar.css({
                        border   : '2px solid #eee',
                        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    break;
            }

            switch(this.options.type) {
                case 'alert':
                case 'notification':
                    this.$bar.css({backgroundColor: '#FFF', borderColor: '#CCC', color: '#444'});
                    break;
                case 'warning':
                    this.$bar.css({backgroundColor: '#FFEAA8', borderColor: '#FFC237', color: '#826200'});
                    this.$buttons.css({borderTop: '1px solid #FFC237'});
                    break;
                case 'error':
                    this.$bar.css({backgroundColor: 'red', borderColor: 'darkred', color: '#FFF'});
                    this.$message.css({fontWeight: 'bold'});
                    this.$buttons.css({borderTop: '1px solid darkred'});
                    break;
                case 'information':
                    this.$bar.css({backgroundColor: '#57B7E2', borderColor: '#0B90C4', color: '#FFF'});
                    this.$buttons.css({borderTop: '1px solid #0B90C4'});
                    break;
                case 'success':
                    this.$bar.css({backgroundColor: 'lightgreen', borderColor: '#50C24E', color: 'darkgreen'});
                    this.$buttons.css({borderTop: '1px solid #50C24E'});
                    break;
                default:
                    this.$bar.css({backgroundColor: '#FFF', borderColor: '#CCC', color: '#444'});
                    break;
            }
        },
        callback: {
            onShow : function() {
                $.noty.themes.defaultTheme.helpers.borderFix.apply(this);
            },
            onClose: function() {
                $.noty.themes.defaultTheme.helpers.borderFix.apply(this);
            }
        }
    };

    $.noty.themes.relax = {
        name    : 'relax',
        helpers : {},
        modal   : {
            css: {
                position       : 'fixed',
                width          : '100%',
                height         : '100%',
                backgroundColor: '#000',
                zIndex         : 10000,
                opacity        : 0.6,
                display        : 'none',
                left           : 0,
                top            : 0
            }
        },
        style   : function() {

            this.$bar.css({
                overflow    : 'hidden',
                margin      : '4px 0',
                borderRadius: '2px'
            });

            this.$message.css({
                fontSize  : '14px',
                lineHeight: '16px',
                textAlign : 'center',
                padding   : '10px',
                width     : 'auto',
                position  : 'relative'
            });

            this.$closeButton.css({
                position  : 'absolute',
                top       : 4, right: 4,
                width     : 10, height: 10,
                background: "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAxUlEQVR4AR3MPUoDURSA0e++uSkkOxC3IAOWNtaCIDaChfgXBMEZbQRByxCwk+BasgQRZLSYoLgDQbARxry8nyumPcVRKDfd0Aa8AsgDv1zp6pYd5jWOwhvebRTbzNNEw5BSsIpsj/kurQBnmk7sIFcCF5yyZPDRG6trQhujXYosaFoc+2f1MJ89uc76IND6F9BvlXUdpb6xwD2+4q3me3bysiHvtLYrUJto7PD/ve7LNHxSg/woN2kSz4txasBdhyiz3ugPGetTjm3XRokAAAAASUVORK5CYII=)",
                display   : 'none',
                cursor    : 'pointer'
            });

            this.$buttons.css({
                padding        : 5,
                textAlign      : 'right',
                borderTop      : '1px solid #ccc',
                backgroundColor: '#fff'
            });

            this.$buttons.find('button').css({
                marginLeft: 5
            });

            this.$buttons.find('button:first').css({
                marginLeft: 0
            });

            this.$bar.on({
                mouseenter: function() {
                    $(this).find('.noty_close').stop().fadeTo('normal', 1);
                },
                mouseleave: function() {
                    $(this).find('.noty_close').stop().fadeTo('normal', 0);
                }
            });

            switch(this.options.layout.name) {
                case 'top':
                    this.$bar.css({
                        borderBottom: '2px solid #eee',
                        borderLeft  : '2px solid #eee',
                        borderRight : '2px solid #eee',
                        borderTop   : '2px solid #eee',
                        boxShadow   : "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    break;
                case 'topCenter':
                case 'center':
                case 'bottomCenter':
                case 'inline':
                    this.$bar.css({
                        border   : '1px solid #eee',
                        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    this.$message.css({fontSize: '13px', textAlign: 'center'});
                    break;
                case 'topLeft':
                case 'topRight':
                case 'bottomLeft':
                case 'bottomRight':
                case 'centerLeft':
                case 'centerRight':
                    this.$bar.css({
                        border   : '1px solid #eee',
                        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    this.$message.css({fontSize: '13px', textAlign: 'left'});
                    break;
                case 'bottom':
                    this.$bar.css({
                        borderTop   : '2px solid #eee',
                        borderLeft  : '2px solid #eee',
                        borderRight : '2px solid #eee',
                        borderBottom: '2px solid #eee',
                        boxShadow   : "0 -2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    break;
                default:
                    this.$bar.css({
                        border   : '2px solid #eee',
                        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                    });
                    break;
            }

            switch(this.options.type) {
                case 'alert':
                case 'notification':
                    this.$bar.css({backgroundColor: '#FFF', borderColor: '#dedede', color: '#444'});
                    break;
                case 'warning':
                    this.$bar.css({backgroundColor: '#FFEAA8', borderColor: '#FFC237', color: '#826200'});
                    this.$buttons.css({borderTop: '1px solid #FFC237'});
                    break;
                case 'error':
                    this.$bar.css({backgroundColor: '#FF8181', borderColor: '#e25353', color: '#FFF'});
                    this.$message.css({fontWeight: 'bold'});
                    this.$buttons.css({borderTop: '1px solid darkred'});
                    break;
                case 'information':
                    this.$bar.css({backgroundColor: '#78C5E7', borderColor: '#3badd6', color: '#FFF'});
                    this.$buttons.css({borderTop: '1px solid #0B90C4'});
                    break;
                case 'success':
                    this.$bar.css({backgroundColor: '#BCF5BC', borderColor: '#7cdd77', color: 'darkgreen'});
                    this.$buttons.css({borderTop: '1px solid #50C24E'});
                    break;
                default:
                    this.$bar.css({backgroundColor: '#FFF', borderColor: '#CCC', color: '#444'});
                    break;
            }
        },
        callback: {
            onShow : function() {

            },
            onClose: function() {

            }
        }
    };


    return window.noty;

});
// Static global with various sub parts
var O3Global = new function(){}



// Static AjaxCodeConfig class
var AjaxCodeConfig = new function()
{

    this.STRUCTURAL_NO_XML = 1;
    this.STRUCTURAL_NO_JSON = 1;
    this.STRUCTURAL_NO_CODE = 2;
    this.EVERYTHING = 42;
    this.OK = 0;
    this.ERROR = 10;
    this.NO_LOGIN = 20;

}




// Static Ozone class
var Ozone = new function()
{
    var iTimeDiff = 0;

    this.BASE_LINK      = "/?module=";
    this.DEFAULT_MODULE = "Layout.Main";
    this.LOGIN_MODULE   = "Homepage";

    function getMyTime()
    {
        // Return in seconds
        return Math.round((new Date()).getTime() / 1000);
    }

    function setServerTime(iTime)
    {
        // Calculate the difference between server time and local time
        iTimeDiff = getMyTime() - iTime;
    }

    function getServerTime()
    {
        return getMyTime() - iTimeDiff;
    }

    // Initially set up server time
    setServerTime(1409069052);

    // Attach public functions
    this.setServerTime = setServerTime;
    this.getServerTime = getServerTime;
}

// O3Repository for JS objects
var O3Repository = new function()
{
    var iCounter    = -1;
    var aRepository = new Array();

    // Adds an item and returns id
    function add(oItem)
    {
        aRepository[++iCounter] = oItem;

        return iCounter;
    }

    // Put an item on a set id and return the old item
    function put(iIndex, oItem)
    {
        var oOld = aRepository[iIndex];
        aRepository[iIndex] = oItem;

        return oOld;
    }

    // Fetch the item by its id
    function get(iIndex)
    {
        return aRepository[iIndex];
    }

    // Remove and return item
    function remove(iIndex)
    {
        return put(iIndex, null);
    }

    // Reset repos
    function reset()
    {
        aRepository = new Array();
        iCounter    = -1;
    }

    // Attach public functions
    this.add    = add;
    this.put    = put;
    this.get    = get;
    this.remove = remove;
    this.reset  = reset;
}

/*
 http://www.JSON.org/json2.js
 2011-02-23

 Public Domain.

 NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

 See http://www.JSON.org/js.html


 This code should be minified before deployment.
 See http://javascript.crockford.com/jsmin.html

 USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
 NOT CONTROL.


 This file creates a global JSON object containing two methods: stringify
 and parse.

 JSON.stringify(value, replacer, space)
 value       any JavaScript value, usually an object or array.

 replacer    an optional parameter that determines how object
 values are stringified for objects. It can be a
 function or an array of strings.

 space       an optional parameter that specifies the indentation
 of nested structures. If it is omitted, the text will
 be packed without extra whitespace. If it is a number,
 it will specify the number of spaces to indent at each
 level. If it is a string (such as '\t' or '&nbsp;'),
 it contains the characters used to indent at each level.

 This method produces a JSON text from a JavaScript value.

 When an object value is found, if the object contains a toJSON
 method, its toJSON method will be called and the result will be
 stringified. A toJSON method does not serialize: it returns the
 value represented by the name/value pair that should be serialized,
 or undefined if nothing should be serialized. The toJSON method
 will be passed the key associated with the value, and this will be
 bound to the value

 For example, this would serialize Dates as ISO strings.

 Date.prototype.toJSON = function (key) {
 function f(n) {
 // Format integers to have at least two digits.
 return n < 10 ? '0' + n : n;
 }

 return this.getUTCFullYear()   + '-' +
 f(this.getUTCMonth() + 1) + '-' +
 f(this.getUTCDate())      + 'T' +
 f(this.getUTCHours())     + ':' +
 f(this.getUTCMinutes())   + ':' +
 f(this.getUTCSeconds())   + 'Z';
 };

 You can provide an optional replacer method. It will be passed the
 key and value of each member, with this bound to the containing
 object. The value that is returned from your method will be
 serialized. If your method returns undefined, then the member will
 be excluded from the serialization.

 If the replacer parameter is an array of strings, then it will be
 used to select the members to be serialized. It filters the results
 such that only members with keys listed in the replacer array are
 stringified.

 Values that do not have JSON representations, such as undefined or
 functions, will not be serialized. Such values in objects will be
 dropped; in arrays they will be replaced with null. You can use
 a replacer function to replace those with JSON values.
 JSON.stringify(undefined) returns undefined.

 The optional space parameter produces a stringification of the
 value that is filled with line breaks and indentation to make it
 easier to read.

 If the space parameter is a non-empty string, then that string will
 be used for indentation. If the space parameter is a number, then
 the indentation will be that many spaces.

 Example:

 text = JSON.stringify(['e', {pluribus: 'unum'}]);
 // text is '["e",{"pluribus":"unum"}]'


 text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
 // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

 text = JSON.stringify([new Date()], function (key, value) {
 return this[key] instanceof Date ?
 'Date(' + this[key] + ')' : value;
 });
 // text is '["Date(---current time---)"]'


 JSON.parse(text, reviver)
 This method parses a JSON text to produce an object or array.
 It can throw a SyntaxError exception.

 The optional reviver parameter is a function that can filter and
 transform the results. It receives each of the keys and values,
 and its return value is used instead of the original value.
 If it returns what it received, then the structure is not modified.
 If it returns undefined then the member is deleted.

 Example:

 // Parse the text. Values that look like ISO date strings will
 // be converted to Date objects.

 myData = JSON.parse(text, function (key, value) {
 var a;
 if (typeof value === 'string') {
 a =
 /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
 if (a) {
 return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
 +a[5], +a[6]));
 }
 }
 return value;
 });

 myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
 var d;
 if (typeof value === 'string' &&
 value.slice(0, 5) === 'Date(' &&
 value.slice(-1) === ')') {
 d = new Date(value.slice(5, -1));
 if (d) {
 return d;
 }
 }
 return value;
 });


 This is a reference implementation. You are free to copy, modify, or
 redistribute.
 */

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
 call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
 getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
 lastIndex, length, parse, prototype, push, replace, slice, stringify,
 test, toJSON, toString, valueOf
 */


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
                Boolean.prototype.toJSON = function (key) {
                    return this.valueOf();
                };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
            case 'string':
                return quote(value);

            case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

                return isFinite(value) ? String(value) : 'null';

            case 'boolean':
            case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

                return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

            case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

                if (!value) {
                    return 'null';
                }

// Make an array to hold the partial results of stringifying this object value.

                gap += indent;
                partial = [];

// Is the value an array?

                if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || 'null';
                    }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                    v = partial.length === 0 ? '[]' : gap ?
                        '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                        '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                }

// If the replacer is an array, use it to select the members to be stringified.

                if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                        if (typeof rep[i] === 'string') {
                            k = rep[i];
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                } else {

// Otherwise, iterate through all of the keys in the object.

                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

                v = partial.length === 0 ? '{}' : gap ?
                    '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                    '{' + partial.join(',') + '}';
                gap = mind;
                return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                    .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                    .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

// O3AjaxHandler static object
var O3AjaxHandler = new function()
{
    var aPreHandlers  = Array();
    var aHandlers     = Array();
    var fncIncPending = null;
    var fncDecPending = null;

    // Public functions
    function preHandle(iCode, oResponse)
    {
        if(typeof aPreHandlers[iCode] == 'function')
            aPreHandlers[iCode](oResponse);
    }

    function handle(iCode, oResponse)
    {
        if(typeof aHandlers[iCode] == 'function')
            aHandlers[iCode](oResponse);
    }

    function setGlobalPreHandler(iCode, fncHandler)
    {
        aPreHandlers[iCode] = fncHandler;
    }

    function setGlobalHandler(iCode, fncHandler)
    {
        aHandlers[iCode] = fncHandler;
    }

    function setIncPendingHandler(fncHandler)
    {
        fncIncPending = fncHandler;
    }

    function setDecPendingHandler(fncHandler)
    {
        fncDecPending = fncHandler;
    }

    function incrementPending()
    {
        if(typeof fncIncPending == 'function')
            fncIncPending();
    }

    function decrementPending()
    {
        if(typeof fncDecPending == 'function')
            fncDecPending();
    }

    // Bind public functions
    this.preHandle            = preHandle;
    this.handle               = handle;
    this.setGlobalPreHandler  = setGlobalPreHandler;
    this.setGlobalHandler     = setGlobalHandler;
    this.setIncPendingHandler = setIncPendingHandler;
    this.setDecPendingHandler = setDecPendingHandler;
    this.incrementPending     = incrementPending;
    this.decrementPending     = decrementPending;
}

// Create & add some generic handlers (if not overridden codes)
if(AjaxCodeConfig.STRUCTURAL_NO_XML)
    O3AjaxHandler.setGlobalHandler(AjaxCodeConfig.STRUCTURAL_NO_XML, function(oResponse) { alert('Structural error: no XML'); });

if(AjaxCodeConfig.STRUCTURAL_NO_CODE)
    O3AjaxHandler.setGlobalHandler(AjaxCodeConfig.STRUCTURAL_NO_CODE, function(oResponse) { alert('Structural error: no Code');});

if(AjaxCodeConfig.NO_LOGIN)
    O3AjaxHandler.setGlobalHandler(AjaxCodeConfig.NO_LOGIN, function(oResponse) { top.location = Ozone.BASE_LINK + Ozone.LOGIN_MODULE; });

if(AjaxCodeConfig.ERROR)
{
    var fncHandleError = function(oResponse)
    {
        // Fetch message
        var sMessage = oResponse.getElementsByTagName('message')[0].firstChild.data;

        // Show
        alert(sMessage);
    }

    O3AjaxHandler.setGlobalHandler(AjaxCodeConfig.ERROR, fncHandleError);
}

// O3JsonHandler static object
var O3JsonHandler = new function()
{
    var aPreHandlers  = Array();
    var aHandlers     = Array();

    // Public functions
    function preHandle(iCode, oResponse)
    {
        if(typeof aPreHandlers[iCode] == 'function')
            aPreHandlers[iCode](oResponse);
    }

    function handle(iCode, oResponse)
    {
        if(typeof aHandlers[iCode] == 'function')
            aHandlers[iCode](oResponse);
    }

    function setGlobalPreHandler(iCode, fncHandler)
    {
        aPreHandlers[iCode] = fncHandler;
    }

    function setGlobalHandler(iCode, fncHandler)
    {
        aHandlers[iCode] = fncHandler;
    }

    // Bind public functions
    this.preHandle            = preHandle;
    this.handle               = handle;
    this.setGlobalPreHandler  = setGlobalPreHandler;
    this.setGlobalHandler     = setGlobalHandler;
}

// Create & add some generic handlers (if not overridden codes)
if(AjaxCodeConfig.STRUCTURAL_NO_JSON)
    O3JsonHandler.setGlobalHandler(AjaxCodeConfig.STRUCTURAL_NO_JSON, function(oResponse) { alert('Structural error: no JSON'); });

if(AjaxCodeConfig.STRUCTURAL_NO_CODE)
    O3JsonHandler.setGlobalHandler(AjaxCodeConfig.STRUCTURAL_NO_CODE, function(oResponse) { alert('Structural error: no Code');});

if(AjaxCodeConfig.NO_LOGIN)
    O3JsonHandler.setGlobalHandler(AjaxCodeConfig.NO_LOGIN, function(oResponse) { top.location = Ozone.BASE_LINK + Ozone.LOGIN_MODULE; });

if(AjaxCodeConfig.ERROR)
{
    var fncHandleError = function(oResponse)
    {
        // Fetch message
        var sMessage = oResponse.message;

        // Show
        alert(sMessage);
    }

    O3JsonHandler.setGlobalHandler(AjaxCodeConfig.ERROR, fncHandleError);
}

// O3Ajax class
function O3Ajax()
{
    var oXML								= null;
    var fncInternalCallback = null;
    var fncCallback				 = null;
    var sContainer					= null;
    var aPostData					 = null;
    var sPostData					 = '';
    var aHandlers					 = Array();

    // Constructor
    function O3Ajax()
    {
        // Build the XML requester
        if(window.XMLHttpRequest) // Mozilla, Safari, etc.
            oXML = new XMLHttpRequest();
        else if(window.ActiveXObject) // IE
        {
            try
            {
                oXML = new ActiveXObject("Msxml2.XMLHTTP");
            }
            catch(e)
            {
                try
                {
                    oXML = new ActiveXObject("Microsoft.XMLHTTP");
                }
                catch(e)
                {
                }
            }
        }
        else
            return false;

        if(oXML == null)
            return false;

        // Attach callback
        oXML.onreadystatechange = callback;

        // Build post data array
        aPostData = new Array();

        // All ok
        return true;
    }

    function addPostData(aAdd)
    {
        // Port them over (concat doesn't work for associative)
        for(sKey in aAdd)
            aPostData[sKey] = aAdd[sKey];
    }

    function addRawPostData(sPost)
    {
        // Add it to the end of the existing post data
        sPostData += '&' + sPost;
    }

    function addPostValue(sKey, sValue)
    {
        // Add a single post value
        aPostData[sKey] = sValue;
    }

    function clearPostData()
    {
        // Clear post data
        aPostData = new Array();
    }

    function buildPostData()
    {
        // Loop post array & build string
        var sPost = '';
        for(var sKey in aPostData)
        {
            // Skip prototypes
            if(typeof aPostData[sKey] == 'function')
                continue;

            // Handle arrays
            if(O3Global.Types.isArray(aPostData[sKey]))
            {
                for(var sSubKey in aPostData[sKey])
                {
                    // Skip prototypes
                    if(typeof aPostData[sKey][sSubKey] == 'function')
                        continue;

                    sPost += O3Global.Types.encodeURL(sKey) + '[' + O3Global.Types.encodeURL(sSubKey) + ']=' + O3Global.Types.encodeURL(aPostData[sKey][sSubKey]) + '&';
                }
            }
            else
                sPost += O3Global.Types.encodeURL(sKey) + '=' + O3Global.Types.encodeURL(aPostData[sKey]) + '&';
        }

        // Add raw string
        sPost += sPostData;

        return sPost;
    }

    function setContainer(sId)
    {
        sContainer = sId;
    }

    function setCallback(fncFinalCallback)
    {
        fncCallback = fncFinalCallback;
    }

    // First callback
    function callback()
    {
        // Check status
        if(oXML.readyState == 4 && (oXML.status == 200 || window.location.href.indexOf("http") == -1))
        {
            // Decrement loading (if available)
            if(window.O3AjaxHandler)
                O3AjaxHandler.decrementPending();

            // Pass on to actual callback
            if(fncInternalCallback)
                fncInternalCallback();
        }
    }

    // Page loader callback
    function callbackPage()
    {
        // Check for XML (login timeout)
        if(oXML.responseXML && oXML.responseXML.documentElement && oXML.responseXML.documentElement.attributes.getNamedItem('code'))
        {
            callbackXML();
            return;
        }

        // Check for a container ID
        if(sContainer)
        {
            var hContainer = O3Global.DOM.getById(sContainer);
            if(hContainer)
            {
                hContainer.innerHTML = oXML.responseText;
                hContainer.disabled	= '';
            }
        }

        // Check for callback
        if(fncCallback)
            fncCallback(oXML.responseText);
    }

    // XML loader callback
    function callbackXML()
    {
        // Extract XML data
        var oResponse = oXML.responseXML;
        if(oResponse)
            oResponse = oResponse.documentElement;

        var iCode = AjaxCodeConfig.OK;
        if(!oResponse)
        {
            iCode = AjaxCodeConfig.STRUCTURAL_NO_XML; // Structural XML error: no XML data
            alert(oXML.responseText);
        }
        else
        {
            // Extract code
            var oCode = oResponse.attributes.getNamedItem('code');
            if(!oCode)
                iCode = AjaxCodeConfig.STRUCTURAL_NO_CODE; // Structural XML error: no code
            else
            {
                iCode = oCode.value;

                // Get and update time if possible
                var oTime = oResponse.attributes.getNamedItem('time');
                if(oTime)
                    Ozone.setServerTime(oTime.value);

                // Check for debug data
                var oDebug = oResponse.getElementsByTagName('debug');
                if(oDebug)
                {
                    oDebug = oDebug[0];
                    if(oDebug)
                    {
                        var aDebug = oDebug.childNodes;
                        for(var i = 0; i < aDebug.length; i++)
                        {
                            var oEntry = aDebug[i];
                            if(!oEntry.firstChild)
                                continue;

                            alert("Debug:\n\n" + oEntry.firstChild.data);
                        }
                    }
                }
            }
        }

        // Pre-process output for this code
        O3AjaxHandler.preHandle(iCode, oResponse);

        // Check for handler
        if(typeof aHandlers[iCode] == 'function')
        {
            if(!aHandlers[iCode](oResponse))
                O3AjaxHandler.handle(iCode, oResponse);
        }
        else
            O3AjaxHandler.handle(iCode, oResponse);
    }

    function callbackJSON()
    {
        // Extract XML data
        var oResponse = null;
        try
        {
            oResponse = JSON.parse(oXML.responseText);
        }
        catch(e)
        {
            // Do nothing - response will remain NULL, handling happens below
        }

        var iCode = AjaxCodeConfig.OK;
        if(!oResponse)
        {
            iCode = AjaxCodeConfig.STRUCTURAL_NO_JSON; // Structural JSON error: no JSON data
            alert(oXML.responseText);
        }
        else
        {
            // Extract code
            iCode = oResponse.code;
            if(typeof iCode === 'undefined')
                iCode = AjaxCodeConfig.STRUCTURAL_NO_CODE; // Structural JSON error: no code
            else
            {
                // Get and update time if possible
                if(typeof oResponse.time !== 'undefined')
                    Ozone.setServerTime(oResponse.time);

                // Check for debug data
                if(O3Global.Types.isArray(oResponse.debug))
                {
                    for(var i = 0; i < oResponse.debug.length; i++)
                        alert("Debug:\n\n" + oResponse.debug[i]);
                }
            }
        }

        // Pre-process output for this code
        O3JsonHandler.preHandle(iCode, oResponse ? oResponse.data : null);

        // Check for handler
        if(typeof aHandlers[iCode] == 'function')
        {
            if(!aHandlers[iCode](oResponse ? oResponse.data : null))
                O3JsonHandler.handle(iCode, oResponse ? oResponse.data : null);
        }
        else
            O3JsonHandler.handle(iCode, oResponse ? oResponse.data : null);
    }

    // Event loader callback
    function callbackEvent()
    {
        // Extract XML data
        var oResponse = oXML.responseXML;
        if(oResponse)
            oResponse = oResponse.documentElement;
        if(!oResponse)
        {
            alert(oXML.responseText);
            return;
        }

        // Check for occurrence
        var oOccurred = oResponse.attributes.getNamedItem('occurred');
        var bOccurred = false;
        if(!oOccurred || oOccurred.value == 'error')
        {
            alert('Error; could not start message pump. Live updates are disabled!');
            return;
        }

        bOccurred = oOccurred.value == 'yes';

        // Read command if an event occurred
        var sCommand = '';
        if(bOccurred)
        {
            bOccurred		= false;
            var oCommand = oResponse.getElementsByTagName('command');
            if(oCommand && oCommand[0] && oCommand[0].firstChild)
            {
                bOccurred = true;
                sCommand	= oCommand[0].firstChild.data;
            }
        }

        // Call callback with this info
        if(fncCallback)
            fncCallback(bOccurred, sCommand);
    }

    function processRequest(sModule, sAction)
    {
        // Build url with anti-cache
        var sUrl = Ozone.BASE_LINK + sModule + '&action=' + sAction + '&O3Request=' + (new Date).getTime();

        // Build post data
        var sPost = buildPostData();

        // Send request
        oXML.open("POST", sUrl, true);
        oXML.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        oXML.send(sPost);

        // Increment loading
        O3AjaxHandler.incrementPending();
    }

    function requestPage(sModule, sAction)
    {
        // Set the internal callback
        fncInternalCallback = callbackPage;

        // Process this request
        processRequest(sModule, sAction);
    }

    function requestXML(sModule, sAction)
    {
        // Set the internal callback
        fncInternalCallback = callbackXML;

        // Process this request
        processRequest(sModule, sAction);
    }

    function requestJSON(sModule, sAction)
    {
        // Set the internal callback
        fncInternalCallback = callbackJSON;

        // Process this request
        processRequest(sModule, sAction);
    }

    function requestEvent(sServer)
    {
        // Set the internal callback
        fncInternalCallback = callbackEvent;

        // Send raw request
        oXML.open("POST", "http://" + sServer + "/event", true);
        oXML.send(null);
    }

    function setHandler(iCode, fncHandler)
    {
        // Add or override handler
        aHandlers[iCode] = fncHandler;
    }

    // Call constructor
    if(!O3Ajax())
        alert("Could not create O3Ajax. Your browser does not support XMLHttpRequest.");

    // Bind public functions
    this.addPostData		 = addPostData;
    this.addRawPostData	= addRawPostData;
    this.addPostValue		= addPostValue;
    this.clearPostData	 = clearPostData;
    this.setContainer		= setContainer;
    this.setCallback		 = setCallback;
    this.requestPage		 = requestPage;
    this.requestXML			= requestXML;
    this.requestJSON        = requestJSON;
    this.requestEvent		= requestEvent;
    this.setHandler			= setHandler;
}

O3Global.DOM = new function()
{
    // Get something by its ID (cross browser compat)
    function getById(id)
    {
        // IE
        if (document.all)
        {
            return document.all[id];
        }
        // Netscape
        else if(document.layers)
        {
            return document.layers[id];
        }
        // DOM - eg Opera
        else if(document.getElementById)
        {
            var hElement = document.getElementById(id);

            // Firefox, check for elements by name (no merged name/id spaces)
            if(hElement == null)
            {
                if(document.getElementsByName && document.getElementsByName(id) && document.getElementsByName(id)[0])
                {
                    // Build array for more elements (radio boxes)
                    hElement = document.getElementsByName(id);
                    if(hElement.length == 1)
                        hElement = hElement[0];
                }
            }

            // Firefox, check subforms if needed
            if(hElement == null)
            {
                for(var sForm in document.forms)
                {
                    var hForm = document.forms[sForm];
                    if(hForm.elements && hForm.elements[id])
                    {
                        hElement = hForm.elements[id];
                        break;
                    }
                }
            }

            return hElement;
        }
        // Not supported
        else
        {
            return null;
        }
    }

    // Clear a div
    function clearDiv(sDiv)
    {
        var oPane = getById(sDiv);
        if(!oPane)
            return;

        // Clear load data if present
        if(O3Global.Ajax)
            O3Global.Ajax.clearEntry(sDiv);

        oPane.innerHTML = '';
    }

    function showDiv(sDiv)
    {
        var oDiv = getById(sDiv);
        if(oDiv && oDiv.style)
            oDiv.style.display = '';
    }

    function hideDiv(sDiv)
    {
        var oDiv = getById(sDiv);
        if(oDiv && oDiv.style)
            oDiv.style.display = 'none';
    }

    function removeDiv(sDiv)
    {
        var oDiv = getById(sDiv);
        if(oDiv && oDiv.parentElement)
            oDiv.parentElement.removeChild(oDiv);
    }

    function getAbsoluteLeft(oElement)
    {
        var iLeft = oElement.offsetLeft;
        while(oElement.offsetParent != null)
        {
            oElement = oElement.offsetParent;
            iLeft   += oElement.offsetLeft;
        }

        return iLeft;
    }

    function getAbsoluteTop(oElement)
    {
        var iTop = oElement.offsetTop;
        while(oElement.offsetParent != null)
        {
            oElement = oElement.offsetParent;
            iTop    += oElement.offsetTop;
        }

        return iTop;
    }

    function setImageOpacity(sId, fOpacity)
    {
        // Get image
        var hImage = getById(sId);
        if(!hImage)
            return;

        // Set opacity styles
        if(hImage.filters && hImage.filters.alpha)
            hImage.filters.alpha.opacity = fOpacity * 100;
        else
        {
            hImage.style.KHTMLOpacity = fOpacity;
            hImage.style.MozOpacity   = fOpacity;
            hImage.style.opacity      = fOpacity;
        }
    }

    function insertRow(sTable, aColumns, sBefore, sId)
    {
        // Fetch table body
        var oTable = getById(sTable);
        if(!oTable)
            return false;

        var oTBody = oTable.getElementsByTagName('tbody')[0];
        if(!oTBody)
        {
            // Create body (first time insert)
            oTBody = document.createElement('tbody');
            oTable.appendChild(oTBody);
        }

        // Create new row
        var oRow = document.createElement('tr');
        if(sId)
            oRow.id = sId;

        // Create columns & add them
        for(var i = 0; i < aColumns.length; i++)
        {
            var oColumn = document.createElement('td');
            oColumn.innerHTML = aColumns[i];
            oRow.appendChild(oColumn);
        }

        // Check for before row
        var oBefore = null;
        if(sBefore)
            oBefore = getById(sBefore);

        // Insert
        if(oBefore)
            oTBody.insertBefore(oRow, oBefore);
        else
            oTBody.appendChild(oRow);

        return true;
    }

    function removeRow(sTable, sRow)
    {
        // Fetch table body
        var oTable = getById(sTable);
        if(!oTable)
            return false;

        var oTBody = oTable.getElementsByTagName('tbody')[0];
        if(!oTBody)
            return false;

        // Find row
        var oRow = getById(sRow);
        if(!oRow)
            return false;

        // Remove row
        oTBody.removeChild(oRow);

        return true;
    }

    function getStyle(oElement, sProp)
    {
        if(oElement.currentStyle)
            return oElement.currentStyle[sProp];
        else if(window.getComputedStyle)
            return document.defaultView.getComputedStyle(oElement, null).getPropertyValue(sProp);

        return null;
    }

    function zoomImage(sImage, fZoom)
    {
        // Fetch image
        var img = getById(sImage);
        if(!img)
            return false;

        // Decide original size
        var imgSize = new Image();
        imgSize.src = img.src;

        // Apply new sizes
        img.width  = Math.round(imgSize.width  * fZoom);
        img.height = Math.round(imgSize.height * fZoom);

        return true;
    }

    function scrollHorizontal(oDiv, iScroll)
    {
        if(!oDiv)
            return;

        var iPosX = oDiv.scrollLeft - iScroll;
        if(iPosX < 0)
            iPosX = 0;
        else if(iPosX > oDiv.scrollWidth)
            iPosX = oDiv.scrollWidth;

        oDiv.scrollLeft = iPosX;
    }

    function scrollVertical(oDiv, iScroll)
    {
        if(!oDiv)
            return;

        var iPosY = oDiv.scrollTop - iScroll;
        if(iPosY < 0)
            iPosY = 0;
        if(iPosY > oDiv.scrollHeight)
            iPosY = oDiv.scrollHeight;

        oDiv.scrollTop = iPosY;
    }

    function setClass(sItem, sClass)
    {
        var oItem = getById(sItem);
        if(oItem)
            oItem.className = sClass;
    }

    // Bind public functions
    this.getById          = getById;
    this.clearDiv         = clearDiv;
    this.showDiv          = showDiv;
    this.hideDiv          = hideDiv;
    this.removeDiv        = removeDiv;
    this.getAbsoluteLeft  = getAbsoluteLeft;
    this.getAbsoluteTop   = getAbsoluteTop;
    this.insertRow        = insertRow;
    this.removeRow        = removeRow;
    this.getStyle         = getStyle;
    this.zoomImage        = zoomImage;
    this.scrollHorizontal = scrollHorizontal;
    this.scrollVertical   = scrollVertical;
    this.setClass         = setClass;
    this.setImageOpacity  = setImageOpacity;
}

O3Global.Types = new function()
{
    // Validate email
    function validateEmail(sEmail)
    {
        var filter = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
        return filter.test(sEmail);
    }

    // Check for array
    function isArray(a)
    {
        if(a && a.constructor && a.constructor.toString().indexOf("Array") != -1)
            return true;

        return false;
    }

    // Compare 2 associative arrays
    function arrayCompare(a1, a2, bOneSidedMatch)
    {
        // Check if both are arrays
        if(!isArray(a1) || !isArray(a2))
            return false;

        // Loop a1 and check a2
        for(var s in a1)
        {
            if(a1[s] != a2[s])
                return false;
        }

        // Loop reversed (a2 might have more params)
        if(!bOneSidedMatch)
        {
            for(var s in a2)
            {
                if(a1[s] != a2[s])
                    return false;
            }
        }

        // They are the same
        return true;
    }

    // Check numeric
    function isNumeric(sText)
    {
        if(sText == null)
            return false;

        // Ensure string
        sText = "" + sText;

        var sValidChars = "-0123456789";
        var cChar;

        for(var i = 0; i < sText.length; i++)
        {
            cChar = sText.charAt(i);
            if(sValidChars.indexOf(cChar) == -1)
                return false;
        }

        // All ok
        return true;
    }

    // Proper URL encoder
    function encodeURL(sURL)
    {
        // Make sure we have a string
        sURL = "" + sURL;

        // The Javascript escape and unescape functions do not correspond
        // with what browsers actually do...
        var SAFECHARS = "0123456789" +                 // Numeric
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + // Alphabetic
            "abcdefghijklmnopqrstuvwxyz" +
            "-_.!~*'()";                   // RFC2396 Mark characters
        var HEX = "0123456789ABCDEF";

        var sEncoded = "";
        for(var i = 0; i < sURL.length; i++ )
        {
            var c = sURL.charAt(i);
            if(c == " ")
                sEncoded += "+"; // x-www-urlencoded, rather than %20
            else if(SAFECHARS.indexOf(c) != -1)
                sEncoded += c;
            else
            {
                var charCode = c.charCodeAt(0);
                if(charCode > 255)
                {
                    alert("Unicode Character '" + c + "' cannot be encoded using standard URL encoding.\n" +
                        "(URL encoding only supports 8-bit characters.)\n" +
                        "A space (+) will be substituted." );
                    sEncoded += "+";
                }
                else
                {
                    sEncoded += "%";
                    sEncoded += HEX.charAt((charCode >> 4) & 0xF);
                    sEncoded += HEX.charAt(charCode & 0xF);
                }
            }
        } // for

        return sEncoded;
    }

    // Bind public functions
    this.validateEmail = validateEmail;
    this.isArray       = isArray;
    this.arrayCompare  = arrayCompare;
    this.isNumeric     = isNumeric;
    this.encodeURL     = encodeURL;
}
O3Global.Ajax = new function()
{
    // Page history
    var aPages = new Array();

    // Quick-swap a div
    function loadDiv(sModule, sAction, sDiv, vPostData, fncCallback, bForceReload)
    {
        // Uncollapse div
        if(sDiv == 'topbar')
            Collapse.show(Collapse.TOP);
        if(sDiv == 'menu')
            Collapse.show(Collapse.LEFT);
        if(sDiv == 'right')
            Collapse.show(Collapse.RIGHT);
        if(sDiv == 'bottom')
            Collapse.show(Collapse.BOTTOM);

        // Check if a reload must happen
        if(!bForceReload)
        {
            // Check this div
            var aDiv = aPages[sDiv];
            if(aDiv)
            {
                if(aDiv['module'] == sModule && aDiv['action'] == sAction && (aDiv['postdata'] == vPostData || O3Global.Types.arrayCompare(aDiv['postdata'], vPostData)))
                {
                    // Don't reload
                    if(fncCallback)
                        fncCallback();

                    return;
                }
            }
        }

        // Store this request
        aPages[sDiv] = new Array();
        aPages[sDiv]['module']	 = sModule;
        aPages[sDiv]['action']	 = sAction;
        aPages[sDiv]['postdata'] = vPostData;

        var oRequest = new O3Ajax();
        var oPane		= O3Global.DOM.getById(sDiv);

        if(vPostData)
        {
            if(O3Global.Types.isArray(vPostData))
                oRequest.addPostData(vPostData);
            else
                oRequest.addRawPostData(vPostData);
        }
        if(fncCallback)
            oRequest.setCallback(fncCallback);

        // trigger disabled
        announceLoading(sDiv);

        oRequest.setContainer(sDiv);
        oRequest.requestPage(sModule, sAction);
    }

    // Reload a div
    function reloadDiv(sDiv, sModule, sAction, vPostData, fncCallback, bOneSidedMatch, aExtraPost)
    {
        // Check if we have data on this div
        var aDiv = aPages[sDiv];
        if(!aDiv)
            return;

        // If no module is set, just push a reload
        if(!sModule)
            loadDiv(aDiv['module'], aDiv['action'], sDiv, aDiv['postdata'], fncCallback, true);
        else
        {
            // Only reload if all params are the same
            if(aDiv['module'] == sModule && aDiv['action'] == sAction && (aDiv['postdata'] == vPostData || O3Global.Types.arrayCompare(vPostData, aDiv['postdata'], bOneSidedMatch)))
            {
                // Add extra, if possible
                if(aExtraPost && O3Global.Types.isArray(vPostData) && O3Global.Types.isArray(aExtraPost))
                {
                    for(var s in aExtraPost)
                        vPostData[s] = aExtraPost[s];
                }

                loadDiv(sModule, sAction, sDiv, vPostData, fncCallback, true);
            }
        }
    }

    // Quick-load XML
    function loadXML(sModule, sAction, vPostData, fncCallback, fncErrorCallback)
    {
        var oRequest = new O3Ajax();

        if(vPostData)
        {
            if(O3Global.Types.isArray(vPostData))
                oRequest.addPostData(vPostData);
            else
                oRequest.addRawPostData(vPostData);
        }

        if(fncCallback)
            oRequest.setHandler(AjaxCodeConfig.OK, fncCallback);
        if(fncErrorCallback)
            oRequest.setHandler(AjaxCodeConfig.ERROR, fncErrorCallback);

        oRequest.requestXML(sModule, sAction);
    }

    // Quick-load JSON
    function loadJSON(sModule, sAction, vPostData, fncCallback, fncErrorCallback)
    {
        var oRequest = new O3Ajax();

        if(vPostData)
        {
            if(O3Global.Types.isArray(vPostData))
                oRequest.addPostData(vPostData);
            else
                oRequest.addRawPostData(vPostData);
        }

        if(fncCallback)
            oRequest.setHandler(AjaxCodeConfig.OK, fncCallback);
        if(fncErrorCallback)
            oRequest.setHandler(AjaxCodeConfig.ERROR, fncErrorCallback);

        oRequest.requestJSON(sModule, sAction);
    }

    function deserializeXML(oXML, oObject)
    {
        // Check for childnodes
        var aNodes = oXML.childNodes;
        if(!aNodes || aNodes.length == 0)
            return;

        // Loop the XMLs childnodes
        for(var i = 0; i < aNodes.length; i++)
        {
            // Fetch node & name
            var oNode = aNodes[i];
            if(!oNode.firstChild)
                continue;

            var sName = oNode.nodeName;
            if(!sName || sName.length == 0)
                continue;

            // Fetch the setter
            var fncSet = eval('oObject.set' + sName);
            if(typeof fncSet != 'function')
                continue;

            // Set the value
            fncSet(oNode.firstChild.data);
        }
    }

    function announceLoading(id)
    {
        var oPane = O3Global.DOM.getById(id);
        if(oPane)
        {
            var oWorkingData = O3Global.DOM.getById('workingdata');
            var newHtml			= oWorkingData ? oWorkingData.innerHTML : '';
            oPane.innerHTML	= newHtml;// + oPane.innerHTML;
            oPane.disabled	 = true;
        }
    }

    function clearEntry(sDiv)
    {
        if(aPages[sDiv])
            aPages[sDiv] = null;
    }

    // Bind public functions
    this.loadDiv				= loadDiv;
    this.reloadDiv			= reloadDiv;
    this.loadXML				= loadXML;
    this.loadJSON       = loadJSON;
    this.deserializeXML = deserializeXML;
    this.clearEntry		 = clearEntry;
}

O3Global.Forms = new function()
{
    // Constants
    var TYPE_UNKNOWN      = 0;
    var TYPE_TEXT         = 1;
    var TYPE_RADIO        = 2;
    var TYPE_CHECKBOX     = 3;
    var TYPE_SELECT       = 4;
    var TYPE_RADIO_CHECK  = 5;

    // Form serializer (form -> array)
    function serializeForm(frmSerialize)
    {
        // Check for form
        if(!frmSerialize)
            return null;

        // Generic & radio holder
        var aData  = new Array();
        var aRadio = new Array();

        // Loop elements
        for(var sElement in frmSerialize.elements)
        {
            // Fetch element
            var hElement = frmSerialize.elements[sElement];
            if(hElement == null)
                continue;

            // Define element type
            var iType = TYPE_UNKNOWN;
            if(hElement.type != null)
            {
                if(hElement.type == 'text' || hElement.type == 'textarea' || hElement.type == 'hidden' || hElement.type == 'password')
                    iType = TYPE_TEXT;
                else if(hElement.type == 'radio')
                    iType = TYPE_RADIO_CHECK;
                else if(hElement.type == 'checkbox')
                    iType = TYPE_CHECKBOX;
                else if(hElement.type == 'select-one' || hElement.type == 'select-multiple')
                    iType = TYPE_SELECT;
            }

            // Special radio handler
            if(hElement[0] != null && hElement[0].type == 'radio')
                iType = TYPE_RADIO;

            // Skip unknown
            if(iType == TYPE_UNKNOWN)
                continue;

            // Skip disabled
            if(hElement.disabled || (iType == TYPE_RADIO && hElement[0].disabled))
                continue;

            // Skip unchecked radio checks
            if(iType == TYPE_RADIO_CHECK && !hElement.checked)
                continue;

            // Set proper name
            if(hElement.name)
                sElement = hElement.name;
            else if(hElement[0].name)
                sElement = hElement[0].name;

            // Skip already processed radio
            if(iType == TYPE_RADIO)
            {
                if(aRadio[sElement])
                    continue;
                else
                    aRadio[sElement] = true;
            }

            // Handle types
            switch(iType)
            {
                case TYPE_RADIO:
                    for(var i = 0; i < hElement.length; i++)
                    {
                        if(hElement[i].checked)
                        {
                            aData[sElement] = hElement[i].value;
                            break;
                        }
                    }
                    break;
                case TYPE_CHECKBOX:
                    if(hElement.checked)
                        aData[sElement] = hElement.value;
                    break;
                default:
                    // Add value
                    aData[sElement] = hElement.value;
                    break;
            }
        }

        // Return data
        return aData;
    }

    // Toggle form
    function toggleForm(frmToggle, bDisable)
    {
        // Skip if no form
        if(!frmToggle)
            return;

        // Loop all elements
        for(var i = 0; i < frmToggle.elements.length; i++)
        {
            // Fetch element
            var hElement = frmToggle.elements[i];
            if(hElement == null)
                continue;

            // Toggle element
            if(hElement.disabled != null)
                hElement.disabled = bDisable;
        }
    }

    // Enable form
    function enableForm(frmEnable)
    {
        // Call toggle
        toggleForm(frmEnable, false);
    }

    // Disable form
    function disableForm(frmDisable)
    {
        // Call toggle
        toggleForm(frmDisable, true);
    }

    // Fetch value of a radio box
    function getRadioValue(oRadio)
    {
        // Check for array or singular
        if(oRadio[0])
        {
            for(var i = 0; i < oRadio.length; i++)
            {
                if(oRadio[i].checked)
                    return oRadio[i].value;
            }
        }
        else
            return oRadio.value;
    }

    // Bind public functions
    this.serializeForm = serializeForm;
    this.enableForm    = enableForm;
    this.disableForm   = disableForm;
    this.getRadioValue = getRadioValue;
}
// ProgBar class
function ProgBar(sPBId)
{
  // Vars to init
  var sId     = '';
  var iMax    = -1;

  // Defaults
  var iWidth    = 100;
  var iValue    = 0;
  var iHeight   = 15;
  var sCaption  = null;
  var iMinColor = 0x006400;
  var iMaxColor = 0x006400;
  var sBorder   = '1px solid black';
  var sDisplay  = 'inline';

  // Internal
  var bAttach = false;

  // Holders
  var oBarSub   = null;
  var oBarDiv   = null;
  var oBarColor = null;
  var oBarWDiv  = null;

  // Constructor
  function construct(sPBId)
  {
    sId = sPBId;
  }

  function calculateColor()
  {
    // Calculate multiplier
    var fMulti = 0.0;
    if(iMax != 0)
      fMulti = 1.0 / iMax * iValue;

    // Break down RGB
    var iB1 = (iMinColor & 0x0000FF);
    var iG1 = (iMinColor & 0x00FF00) >> 8;
    var iR1 = (iMinColor & 0xFF0000) >> 16;
    var iB2 = (iMaxColor & 0x0000FF);
    var iG2 = (iMaxColor & 0x00FF00) >> 8;
    var iR2 = (iMaxColor & 0xFF0000) >> 16;

    // Combine colours
    var iB3  = Math.round(iB1 + (iB2 - iB1) * fMulti);
    var iG3  = Math.round(iG1 + (iG2 - iG1) * fMulti);
    var iR3  = Math.round(iR1 + (iR2 - iR1) * fMulti);
    var iRGB = (iR3 << 16) | (iG3 << 8) | (iB3 << 0);

    // Create output
    var sReturn = iRGB.toString(16);
    while(sReturn.length < 6)
      sReturn = '0' + sReturn;

    return '#' + sReturn;
  }

  function create()
  {
    // Check for required values
    if(sId.length == 0)
    {
      alert('You need an ID to create a ProgBar');
      return;
    }

    if(iMax <= 0)
    {
      alert('Max has to be > 0 to create a ProgBar');
      return;
    }

    // Calculate width
    var iBarWidth = 0;
    if(iValue >= iMax)
      iBarWidth = iWidth;
    else
    {
      var iDivider  = iMax * iValue;
      var iBarWidth = 0;
      if(iDivider != 0)
        iBarWidth = Math.round(iWidth / iDivider);
    }

    // Calculate colour
    var sColor = calculateColor();

    // Fix caption
    if(sCaption == null)
      sCaption = iValue;

    // Create HTML
    var sHTML =
      "<div id=\"jsprogbar_" + sId + "\" style=\"display: " + sDisplay + ";\">\n" +
      "  <table cellpadding=\"0\" cellspacing=\"0\" style=\"border: " + sBorder + "; margin: 0px; padding: 0px; width: " + iWidth + "px;\">\n" +
      "    <tr>\n" +
      "      <td style=\"text-align: left;\">\n" +
      "        <div id=\"jsprogbar_div_" + sId + "\" style=\"font-size: smaller; height: 15px; overflow: hidden; text-align: center; position: absolute; width: " + iWidth + "px;\">" + sCaption + "</div>\n" +
      "        <table id=\"jsprogbar_sub_" + sId + "\" cellpadding=\"0\" cellspacing=\"0\" style=\"font-size: smaller; height: " + iHeight + "px; width: " + iBarWidth + "px;\">\n" +
      "          <tr>\n" +
      "            <td id=\"jsprogbar_color_" + sId + "\" nowrap style=\"background-color: " + sColor + ";\"><div id=\"jsprogbar_wdiv_" + sId + "\" style=\"width: " + iBarWidth + "px; overflow: hidden;\">&nbsp;</div></td>\n" +
      "          </tr>\n" +
      "        </table>\n" +
      "      </td>\n" +
      "    </tr>\n" +
      "  </table>\n" +
      "</div>\n";

    return sHTML;
  }

  function attach()
  {
    if(sId.length == 0)
    {
      alert('You need an ID to attach a ProgBar');
      return;
    }

    // Still need to attach
    bAttach = true;

    // Try to fetch values
    var oValues = O3Global.DOM.getById('jsprogbar_values_' + sId);
    if(!oValues)
      return false;

    // Process values
    eval(oValues.innerHTML);

    // Attachment complete
    bAttach = false;
    return true;
  }

  function init()
  {
    // Check if we still need to attach
    if(bAttach)
    {
      if(!attach())
        return false;
    }

    // Fetch items
    oBarSub   = O3Global.DOM.getById('jsprogbar_sub_'   + sId);
    oBarDiv   = O3Global.DOM.getById('jsprogbar_div_'   + sId);
    oBarColor = O3Global.DOM.getById('jsprogbar_color_' + sId);
    oBarWDiv  = O3Global.DOM.getById('jsprogbar_wdiv_'  + sId);

    // Check
    return (oBarSub && oBarDiv && oBarColor && oBarWDiv);
  }

  function update(i, s)
  {
    // Set new values
    iValue   = i * 1;
    sCaption = s;

    // Attempt init
    if(!init())
      return false;

    // Don't update if the value is too big or small
    if(iValue < 0 || iValue > iMax)
      return false;

    if(!sCaption)
      sCaption = iValue;

    // Calculate width
    var iBarWidth = Math.round(iWidth / iMax * iValue);

    // Set width
    oBarWDiv.style.width = iBarWidth + 'px';
    oBarSub.style.width  = iBarWidth + 'px';

    // Set caption
    oBarDiv.innerHTML = sCaption;

    // Set colour
    oBarColor.style.background = calculateColor();

    // All ok
    return true;
  }

  function hide()
  {
    sDisplay = 'none';
    O3Global.DOM.hideDiv('jsprogbar_' + sId);
  }

  function show()
  {
    sDisplay = 'inline';
    O3Global.DOM.showDiv('jsprogbar_' + sId);
  }

  // Setters
  function setMax(i)
  {
    iMax = i * 1;
  }

  function setWidth(i)
  {
    iWidth = i * 1;
  }

  function setValue(i)
  {
    iValue = i * 1;
  }

  function setHeight(i)
  {
    iHeight = i * 1;
  }

  function setCaption(s)
  {
    sCaption = s;
  }

  function setColor(i)
  {
    iMinColor = i * 1;
    iMaxColor = i * 1;
  }

  function setMinColor(i)
  {
    iMinColor = i * 1;
  }

  function setMaxColor(i)
  {
    iMaxColor = i * 1;
  }

  function setBorder(s)
  {
    sBorder = s;
  }

  // Call constructor
  construct(sPBId);

  // Attach public functions
  this.construct   = construct;
  this.create      = create;
  this.attach      = attach;
  this.update      = update;
  this.hide        = hide;
  this.show        = show;
  this.setMax      = setMax;
  this.setWidth    = setWidth;
  this.setValue    = setValue;
  this.setHeight   = setHeight;
  this.setCaption  = setCaption;
  this.setColor    = setColor;
  this.setMinColor = setMinColor;
  this.setMaxColor = setMaxColor;
  this.setBorder   = setBorder;
}
(function($) {
	var data =
	{
		initialized: false,
		element: null,
		open: false
	};

	var methods =
	{
		init: function()
		{
			// Only if not initialized
			if(data.initialized)
				return;

			// Create divs
			$("body").append('<div id="omertabox_overlay"></div>');
			data.initialized = true;
		},

		popup: function()
		{
			// Initialize if needed
			if(!data.initialized)
				methods.init();

			// If it is open, hide the previous element
			if(data.open)
				data.element.hide();

			var oBody = $("body");

			// Only use one element
			data.element = this.first();

			// Fix the element, if needed
			if(data.element.data('fixed') != 'y')
			{
				data.element.hide();
				data.element.css('position', 'absolute');
				data.element.css('z-index',  '1010');
				oBody.append(data.element);
				data.element.data('fixed', 'y');
			}

			// Calculate position
			var iLeft = Math.round(($(window).width() - data.element.width()) / 2)   + oBody.scrollLeft();
			var iTop  = Math.round(($(window).height() - data.element.height()) / 2) + oBody.scrollTop();

			data.element.css('top',  iTop  + 'px');
			data.element.css('left', iLeft + 'px');

			// Show it, slowly and pretty-ly, if not shown already
			if(!data.open)
			{
				// Make it full height
				$("#omertabox_overlay").height($(document).height());

				// Fade out (just in case)
				$("#omertabox_overlay").fadeTo(0, 0, function()
				{
					// Show it and fade in
					$("#omertabox_overlay").show();
					$("#omertabox_overlay").fadeTo(300, 0.65, function()
					{
						// Show element
						data.element.show();

						// It is now open
						data.open = true;
					});
				});
			}
			else
			{
				// Just show it
				data.element.show();
			}

			// Maintain chainability
			return this;
		},

		close: function()
		{
			// Hide content first
			data.element.hide();

			// It is no longer open
			data.open = false;

			// Fade out
			$("#omertabox_overlay").fadeTo(300, 0, function()
			{
				$("#omertabox_overlay").hide();
			});
		}
	};

	$.fn.omertabox = function(sMethod)
	{
		// Method calling logic
		if(methods[sMethod])
			return methods[sMethod].apply(this, Array.prototype.slice.call( arguments, 1 ));
		else if(!sMethod)
			return methods.popup.apply(this, arguments);
		else
			$.error( 'Method ' +  sMethod + ' does not exist on jQuery.omertabox' );
  	};
})(jQuery);

/**
 * source: https://github.com/Valve/fingerprintjs
 */

/*
* fingerprintJS 0.5.4 - Fast browser fingerprint library
* https://github.com/Valve/fingerprintjs
* Copyright (c) 2013 Valentin Vasilyev (valentin.vasilyev@outlook.com)
* Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

;(function (name, context, definition) {
  if (typeof module !== 'undefined' && module.exports) { module.exports = definition(); }
  else if (typeof define === 'function' && define.amd) { define(definition); }
  else { context[name] = definition(); }
})('Fingerprint', this, function () {
  'use strict';
  
  var Fingerprint = function (options) {
    var nativeForEach, nativeMap;
    nativeForEach = Array.prototype.forEach;
    nativeMap = Array.prototype.map;

    this.each = function (obj, iterator, context) {
      if (obj === null) {
        return;
      }
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, l = obj.length; i < l; i++) {
          if (iterator.call(context, obj[i], i, obj) === {}) return;
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (iterator.call(context, obj[key], key, obj) === {}) return;
          }
        }
      }
    };

    this.map = function(obj, iterator, context) {
      var results = [];
      // Not using strict equality so that this acts as a
      // shortcut to checking for `null` and `undefined`.
      if (obj == null) return results;
      if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
      this.each(obj, function(value, index, list) {
        results[results.length] = iterator.call(context, value, index, list);
      });
      return results;
    };

    if (typeof options == 'object'){
      this.hasher = options.hasher;
      this.screen_resolution = options.screen_resolution;
      this.canvas = options.canvas;
      this.ie_activex = options.ie_activex;
    } else if(typeof options == 'function'){
      this.hasher = options;
    }
  };

  Fingerprint.prototype = {
    get: function(){
      var keys = [];
      keys.push(navigator.userAgent);
      keys.push(navigator.language);
      keys.push(screen.colorDepth);
      if (this.screen_resolution) {
        var resolution = this.getScreenResolution();
        if (typeof resolution !== 'undefined'){ // headless browsers, such as phantomjs
          keys.push(this.getScreenResolution().join('x'));
        }
      }
      keys.push(new Date().getTimezoneOffset());
      keys.push(this.hasSessionStorage());
      keys.push(this.hasLocalStorage());
      keys.push(!!window.indexedDB);
      //body might not be defined at this point or removed programmatically
      if(document.body){
        keys.push(typeof(document.body.addBehavior));
      } else {
        keys.push(typeof undefined);
      }
      keys.push(typeof(window.openDatabase));
      keys.push(navigator.cpuClass);
      keys.push(navigator.platform);
      keys.push(navigator.doNotTrack);
      keys.push(this.getPluginsString());
      if(this.canvas && this.isCanvasSupported()){
        keys.push(this.getCanvasFingerprint());
      }
      if(this.hasher){
        return this.hasher(keys.join('###'), 31);
      } else {
        return this.murmurhash3_32_gc(keys.join('###'), 31);
      }
    },

    /**
     * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
     * 
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/murmurhash-js
     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
     * @see http://sites.google.com/site/murmurhash/
     * 
     * @param {string} key ASCII only
     * @param {number} seed Positive integer only
     * @return {number} 32-bit positive integer hash 
     */

    murmurhash3_32_gc: function(key, seed) {
      var remainder, bytes, h1, h1b, c1, c2, k1, i;
      
      remainder = key.length & 3; // key.length % 4
      bytes = key.length - remainder;
      h1 = seed;
      c1 = 0xcc9e2d51;
      c2 = 0x1b873593;
      i = 0;
      
      while (i < bytes) {
          k1 = 
            ((key.charCodeAt(i) & 0xff)) |
            ((key.charCodeAt(++i) & 0xff) << 8) |
            ((key.charCodeAt(++i) & 0xff) << 16) |
            ((key.charCodeAt(++i) & 0xff) << 24);
        ++i;
        
        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

        h1 ^= k1;
            h1 = (h1 << 13) | (h1 >>> 19);
        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
      }
      
      k1 = 0;
      
      switch (remainder) {
        case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
        case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
        case 1: k1 ^= (key.charCodeAt(i) & 0xff);
        
        k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
        h1 ^= k1;
      }
      
      h1 ^= key.length;

      h1 ^= h1 >>> 16;
      h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= h1 >>> 13;
      h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
      h1 ^= h1 >>> 16;

      return h1 >>> 0;
    },

    // https://bugzilla.mozilla.org/show_bug.cgi?id=781447
    hasLocalStorage: function () {
      try{
        return !!window.localStorage;
      } catch(e) {
        return true; // SecurityError when referencing it means it exists
      }
    },
    
    hasSessionStorage: function () {
      try{
        return !!window.sessionStorage;
      } catch(e) {
        return true; // SecurityError when referencing it means it exists
      }
    },

    isCanvasSupported: function () {
      var elem = document.createElement('canvas');
      return !!(elem.getContext && elem.getContext('2d'));
    },

    isIE: function () {
      if(navigator.appName === 'Microsoft Internet Explorer') {
        return true;
      } else if(navigator.appName === 'Netscape' && /Trident/.test(navigator.userAgent)){// IE 11
        return true;
      }
      return false;
    },

    getPluginsString: function () {
      if(this.isIE() && this.ie_activex){
        return this.getIEPluginsString();
      } else {
        return this.getRegularPluginsString();
      }
    },

    getRegularPluginsString: function () {
      return this.map(navigator.plugins, function (p) {
        var mimeTypes = this.map(p, function(mt){
          return [mt.type, mt.suffixes].join('~');
        }).join(',');
        return [p.name, p.description, mimeTypes].join('::');
      }, this).join(';');
    },

    getIEPluginsString: function () {
      if(window.ActiveXObject){
        var names = ['ShockwaveFlash.ShockwaveFlash',//flash plugin
          'AcroPDF.PDF', // Adobe PDF reader 7+
          'PDF.PdfCtrl', // Adobe PDF reader 6 and earlier, brrr
          'QuickTime.QuickTime', // QuickTime
          // 5 versions of real players
          'rmocx.RealPlayer G2 Control',
          'rmocx.RealPlayer G2 Control.1',
          'RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)',
          'RealVideo.RealVideo(tm) ActiveX Control (32-bit)',
          'RealPlayer',
          'SWCtl.SWCtl', // ShockWave player
          'WMPlayer.OCX', // Windows media player
          'AgControl.AgControl', // Silverlight
          'Skype.Detection'];
          
        // starting to detect plugins in IE
        return this.map(names, function(name){
          try{
            new ActiveXObject(name);
            return name;
          } catch(e){
            return null;
          }
        }).join(';');
      } else {
        return ""; // behavior prior version 0.5.0, not breaking backwards compat.
      }
    },

    getScreenResolution: function () {
      return [screen.height, screen.width];
    },
	
    getCanvasFingerprint: function () {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      // https://www.browserleaks.com/canvas#how-does-it-work
      var txt = 'http://valve.github.io';
      ctx.textBaseline = "top";
      ctx.font = "14px 'Arial'";
      ctx.textBaseline = "alphabetic";
      ctx.fillStyle = "#f60";
      ctx.fillRect(125,1,62,20);
      ctx.fillStyle = "#069";
      ctx.fillText(txt, 2, 15);
      ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
      ctx.fillText(txt, 4, 17);
      return canvas.toDataURL();
    }
  };


  return Fingerprint;

});
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.JSEncrypt={})}(this,function(t){"use strict";var e="0123456789abcdefghijklmnopqrstuvwxyz";function i(t){return e.charAt(t)}function r(t,e){return t&e}function n(t,e){return t|e}function s(t,e){return t^e}function o(t,e){return t&~e}function h(t){if(0==t)return-1;var e=0;return 0==(65535&t)&&(t>>=16,e+=16),0==(255&t)&&(t>>=8,e+=8),0==(15&t)&&(t>>=4,e+=4),0==(3&t)&&(t>>=2,e+=2),0==(1&t)&&++e,e}function a(t){for(var e=0;0!=t;)t&=t-1,++e;return e}var u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",c="=";function f(t){var e,i,r="";for(e=0;e+3<=t.length;e+=3)i=parseInt(t.substring(e,e+3),16),r+=u.charAt(i>>6)+u.charAt(63&i);for(e+1==t.length?(i=parseInt(t.substring(e,e+1),16),r+=u.charAt(i<<2)):e+2==t.length&&(i=parseInt(t.substring(e,e+2),16),r+=u.charAt(i>>2)+u.charAt((3&i)<<4));(3&r.length)>0;)r+=c;return r}var l,p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])};var g,d=function(t){var e;if(void 0===l){var i="0123456789ABCDEF",r=" \f\n\r\t \u2028\u2029";for(l={},e=0;e<16;++e)l[i.charAt(e)]=e;for(i=i.toLowerCase(),e=10;e<16;++e)l[i.charAt(e)]=e;for(e=0;e<r.length;++e)l[r.charAt(e)]=-1}var n=[],s=0,o=0;for(e=0;e<t.length;++e){var h=t.charAt(e);if("="==h)break;if(-1!=(h=l[h])){if(void 0===h)throw new Error("Illegal character at offset "+e);s|=h,++o>=2?(n[n.length]=s,s=0,o=0):s<<=4}}if(o)throw new Error("Hex encoding incomplete: 4 bits missing");return n},v={decode:function(t){var e;if(void 0===g){var i="= \f\n\r\t \u2028\u2029";for(g=Object.create(null),e=0;e<64;++e)g["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e)]=e;for(e=0;e<i.length;++e)g[i.charAt(e)]=-1}var r=[],n=0,s=0;for(e=0;e<t.length;++e){var o=t.charAt(e);if("="==o)break;if(-1!=(o=g[o])){if(void 0===o)throw new Error("Illegal character at offset "+e);n|=o,++s>=4?(r[r.length]=n>>16,r[r.length]=n>>8&255,r[r.length]=255&n,n=0,s=0):n<<=6}}switch(s){case 1:throw new Error("Base64 encoding incomplete: at least 2 bits missing");case 2:r[r.length]=n>>10;break;case 3:r[r.length]=n>>16,r[r.length]=n>>8&255}return r},re:/-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,unarmor:function(t){var e=v.re.exec(t);if(e)if(e[1])t=e[1];else{if(!e[2])throw new Error("RegExp out of sync");t=e[2]}return v.decode(t)}},m=1e13,y=function(){function t(t){this.buf=[+t||0]}return t.prototype.mulAdd=function(t,e){var i,r,n=this.buf,s=n.length;for(i=0;i<s;++i)(r=n[i]*t+e)<m?e=0:r-=(e=0|r/m)*m,n[i]=r;e>0&&(n[i]=e)},t.prototype.sub=function(t){var e,i,r=this.buf,n=r.length;for(e=0;e<n;++e)(i=r[e]-t)<0?(i+=m,t=1):t=0,r[e]=i;for(;0===r[r.length-1];)r.pop()},t.prototype.toString=function(t){if(10!=(t||10))throw new Error("only base 10 is supported");for(var e=this.buf,i=e[e.length-1].toString(),r=e.length-2;r>=0;--r)i+=(m+e[r]).toString().substring(1);return i},t.prototype.valueOf=function(){for(var t=this.buf,e=0,i=t.length-1;i>=0;--i)e=e*m+t[i];return e},t.prototype.simplify=function(){var t=this.buf;return 1==t.length?t[0]:this},t}(),b="…",T=/^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/,S=/^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;function E(t,e){return t.length>e&&(t=t.substring(0,e)+b),t}var w,D=function(){function t(e,i){this.hexDigits="0123456789ABCDEF",e instanceof t?(this.enc=e.enc,this.pos=e.pos):(this.enc=e,this.pos=i)}return t.prototype.get=function(t){if(void 0===t&&(t=this.pos++),t>=this.enc.length)throw new Error("Requesting byte offset "+t+" on a stream of length "+this.enc.length);return"string"==typeof this.enc?this.enc.charCodeAt(t):this.enc[t]},t.prototype.hexByte=function(t){return this.hexDigits.charAt(t>>4&15)+this.hexDigits.charAt(15&t)},t.prototype.hexDump=function(t,e,i){for(var r="",n=t;n<e;++n)if(r+=this.hexByte(this.get(n)),!0!==i)switch(15&n){case 7:r+="  ";break;case 15:r+="\n";break;default:r+=" "}return r},t.prototype.isASCII=function(t,e){for(var i=t;i<e;++i){var r=this.get(i);if(r<32||r>176)return!1}return!0},t.prototype.parseStringISO=function(t,e){for(var i="",r=t;r<e;++r)i+=String.fromCharCode(this.get(r));return i},t.prototype.parseStringUTF=function(t,e){for(var i="",r=t;r<e;){var n=this.get(r++);i+=n<128?String.fromCharCode(n):n>191&&n<224?String.fromCharCode((31&n)<<6|63&this.get(r++)):String.fromCharCode((15&n)<<12|(63&this.get(r++))<<6|63&this.get(r++))}return i},t.prototype.parseStringBMP=function(t,e){for(var i,r,n="",s=t;s<e;)i=this.get(s++),r=this.get(s++),n+=String.fromCharCode(i<<8|r);return n},t.prototype.parseTime=function(t,e,i){var r=this.parseStringISO(t,e),n=(i?T:S).exec(r);return n?(i&&(n[1]=+n[1],n[1]+=+n[1]<70?2e3:1900),r=n[1]+"-"+n[2]+"-"+n[3]+" "+n[4],n[5]&&(r+=":"+n[5],n[6]&&(r+=":"+n[6],n[7]&&(r+="."+n[7]))),n[8]&&(r+=" UTC","Z"!=n[8]&&(r+=n[8],n[9]&&(r+=":"+n[9]))),r):"Unrecognized time: "+r},t.prototype.parseInteger=function(t,e){for(var i,r=this.get(t),n=r>127,s=n?255:0,o="";r==s&&++t<e;)r=this.get(t);if(0===(i=e-t))return n?-1:0;if(i>4){for(o=r,i<<=3;0==(128&(+o^s));)o=+o<<1,--i;o="("+i+" bit)\n"}n&&(r-=256);for(var h=new y(r),a=t+1;a<e;++a)h.mulAdd(256,this.get(a));return o+h.toString()},t.prototype.parseBitString=function(t,e,i){for(var r=this.get(t),n="("+((e-t-1<<3)-r)+" bit)\n",s="",o=t+1;o<e;++o){for(var h=this.get(o),a=o==e-1?r:0,u=7;u>=a;--u)s+=h>>u&1?"1":"0";if(s.length>i)return n+E(s,i)}return n+s},t.prototype.parseOctetString=function(t,e,i){if(this.isASCII(t,e))return E(this.parseStringISO(t,e),i);var r=e-t,n="("+r+" byte)\n";r>(i/=2)&&(e=t+i);for(var s=t;s<e;++s)n+=this.hexByte(this.get(s));return r>i&&(n+=b),n},t.prototype.parseOID=function(t,e,i){for(var r="",n=new y,s=0,o=t;o<e;++o){var h=this.get(o);if(n.mulAdd(128,127&h),s+=7,!(128&h)){if(""===r)if((n=n.simplify())instanceof y)n.sub(80),r="2."+n.toString();else{var a=n<80?n<40?0:1:2;r=a+"."+(n-40*a)}else r+="."+n.toString();if(r.length>i)return E(r,i);n=new y,s=0}}return s>0&&(r+=".incomplete"),r},t}(),x=function(){function t(t,e,i,r,n){if(!(r instanceof R))throw new Error("Invalid tag value.");this.stream=t,this.header=e,this.length=i,this.tag=r,this.sub=n}return t.prototype.typeName=function(){switch(this.tag.tagClass){case 0:switch(this.tag.tagNumber){case 0:return"EOC";case 1:return"BOOLEAN";case 2:return"INTEGER";case 3:return"BIT_STRING";case 4:return"OCTET_STRING";case 5:return"NULL";case 6:return"OBJECT_IDENTIFIER";case 7:return"ObjectDescriptor";case 8:return"EXTERNAL";case 9:return"REAL";case 10:return"ENUMERATED";case 11:return"EMBEDDED_PDV";case 12:return"UTF8String";case 16:return"SEQUENCE";case 17:return"SET";case 18:return"NumericString";case 19:return"PrintableString";case 20:return"TeletexString";case 21:return"VideotexString";case 22:return"IA5String";case 23:return"UTCTime";case 24:return"GeneralizedTime";case 25:return"GraphicString";case 26:return"VisibleString";case 27:return"GeneralString";case 28:return"UniversalString";case 30:return"BMPString"}return"Universal_"+this.tag.tagNumber.toString();case 1:return"Application_"+this.tag.tagNumber.toString();case 2:return"["+this.tag.tagNumber.toString()+"]";case 3:return"Private_"+this.tag.tagNumber.toString()}},t.prototype.content=function(t){if(void 0===this.tag)return null;void 0===t&&(t=1/0);var e=this.posContent(),i=Math.abs(this.length);if(!this.tag.isUniversal())return null!==this.sub?"("+this.sub.length+" elem)":this.stream.parseOctetString(e,e+i,t);switch(this.tag.tagNumber){case 1:return 0===this.stream.get(e)?"false":"true";case 2:return this.stream.parseInteger(e,e+i);case 3:return this.sub?"("+this.sub.length+" elem)":this.stream.parseBitString(e,e+i,t);case 4:return this.sub?"("+this.sub.length+" elem)":this.stream.parseOctetString(e,e+i,t);case 6:return this.stream.parseOID(e,e+i,t);case 16:case 17:return null!==this.sub?"("+this.sub.length+" elem)":"(no elem)";case 12:return E(this.stream.parseStringUTF(e,e+i),t);case 18:case 19:case 20:case 21:case 22:case 26:return E(this.stream.parseStringISO(e,e+i),t);case 30:return E(this.stream.parseStringBMP(e,e+i),t);case 23:case 24:return this.stream.parseTime(e,e+i,23==this.tag.tagNumber)}return null},t.prototype.toString=function(){return this.typeName()+"@"+this.stream.pos+"[header:"+this.header+",length:"+this.length+",sub:"+(null===this.sub?"null":this.sub.length)+"]"},t.prototype.toPrettyString=function(t){void 0===t&&(t="");var e=t+this.typeName()+" @"+this.stream.pos;if(this.length>=0&&(e+="+"),e+=this.length,this.tag.tagConstructed?e+=" (constructed)":!this.tag.isUniversal()||3!=this.tag.tagNumber&&4!=this.tag.tagNumber||null===this.sub||(e+=" (encapsulates)"),e+="\n",null!==this.sub){t+="  ";for(var i=0,r=this.sub.length;i<r;++i)e+=this.sub[i].toPrettyString(t)}return e},t.prototype.posStart=function(){return this.stream.pos},t.prototype.posContent=function(){return this.stream.pos+this.header},t.prototype.posEnd=function(){return this.stream.pos+this.header+Math.abs(this.length)},t.prototype.toHexString=function(){return this.stream.hexDump(this.posStart(),this.posEnd(),!0)},t.decodeLength=function(t){var e=t.get(),i=127&e;if(i==e)return i;if(i>6)throw new Error("Length over 48 bits not supported at position "+(t.pos-1));if(0===i)return null;e=0;for(var r=0;r<i;++r)e=256*e+t.get();return e},t.prototype.getHexStringValue=function(){var t=this.toHexString(),e=2*this.header,i=2*this.length;return t.substr(e,i)},t.decode=function(e){var i;i=e instanceof D?e:new D(e,0);var r=new D(i),n=new R(i),s=t.decodeLength(i),o=i.pos,h=o-r.pos,a=null,u=function(){var e=[];if(null!==s){for(var r=o+s;i.pos<r;)e[e.length]=t.decode(i);if(i.pos!=r)throw new Error("Content size is not correct for container starting at offset "+o)}else try{for(;;){var n=t.decode(i);if(n.tag.isEOC())break;e[e.length]=n}s=o-i.pos}catch(t){throw new Error("Exception while decoding undefined length content: "+t)}return e};if(n.tagConstructed)a=u();else if(n.isUniversal()&&(3==n.tagNumber||4==n.tagNumber))try{if(3==n.tagNumber&&0!=i.get())throw new Error("BIT STRINGs with unused bits cannot encapsulate.");a=u();for(var c=0;c<a.length;++c)if(a[c].tag.isEOC())throw new Error("EOC is not supposed to be actual content.")}catch(t){a=null}if(null===a){if(null===s)throw new Error("We can't skip over an invalid tag with undefined length at offset "+o);i.pos=o+Math.abs(s)}return new t(r,h,s,n,a)},t}(),R=function(){function t(t){var e=t.get();if(this.tagClass=e>>6,this.tagConstructed=0!=(32&e),this.tagNumber=31&e,31==this.tagNumber){for(var i=new y;e=t.get(),i.mulAdd(128,127&e),128&e;);this.tagNumber=i.simplify()}}return t.prototype.isUniversal=function(){return 0===this.tagClass},t.prototype.isEOC=function(){return 0===this.tagClass&&0===this.tagNumber},t}(),B=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],A=(1<<26)/B[B.length-1],O=function(){function t(t,e,i){null!=t&&("number"==typeof t?this.fromNumber(t,e,i):null==e&&"string"!=typeof t?this.fromString(t,256):this.fromString(t,e))}return t.prototype.toString=function(t){if(this.s<0)return"-"+this.negate().toString(t);var e;if(16==t)e=4;else if(8==t)e=3;else if(2==t)e=1;else if(32==t)e=5;else{if(4!=t)return this.toRadix(t);e=2}var r,n=(1<<e)-1,s=!1,o="",h=this.t,a=this.DB-h*this.DB%e;if(h-- >0)for(a<this.DB&&(r=this[h]>>a)>0&&(s=!0,o=i(r));h>=0;)a<e?(r=(this[h]&(1<<a)-1)<<e-a,r|=this[--h]>>(a+=this.DB-e)):(r=this[h]>>(a-=e)&n,a<=0&&(a+=this.DB,--h)),r>0&&(s=!0),s&&(o+=i(r));return s?o:"0"},t.prototype.negate=function(){var e=M();return t.ZERO.subTo(this,e),e},t.prototype.abs=function(){return this.s<0?this.negate():this},t.prototype.compareTo=function(t){var e=this.s-t.s;if(0!=e)return e;var i=this.t;if(0!=(e=i-t.t))return this.s<0?-e:e;for(;--i>=0;)if(0!=(e=this[i]-t[i]))return e;return 0},t.prototype.bitLength=function(){return this.t<=0?0:this.DB*(this.t-1)+U(this[this.t-1]^this.s&this.DM)},t.prototype.mod=function(e){var i=M();return this.abs().divRemTo(e,null,i),this.s<0&&i.compareTo(t.ZERO)>0&&e.subTo(i,i),i},t.prototype.modPowInt=function(t,e){var i;return i=t<256||e.isEven()?new I(e):new N(e),this.exp(t,i)},t.prototype.clone=function(){var t=M();return this.copyTo(t),t},t.prototype.intValue=function(){if(this.s<0){if(1==this.t)return this[0]-this.DV;if(0==this.t)return-1}else{if(1==this.t)return this[0];if(0==this.t)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]},t.prototype.byteValue=function(){return 0==this.t?this.s:this[0]<<24>>24},t.prototype.shortValue=function(){return 0==this.t?this.s:this[0]<<16>>16},t.prototype.signum=function(){return this.s<0?-1:this.t<=0||1==this.t&&this[0]<=0?0:1},t.prototype.toByteArray=function(){var t=this.t,e=[];e[0]=this.s;var i,r=this.DB-t*this.DB%8,n=0;if(t-- >0)for(r<this.DB&&(i=this[t]>>r)!=(this.s&this.DM)>>r&&(e[n++]=i|this.s<<this.DB-r);t>=0;)r<8?(i=(this[t]&(1<<r)-1)<<8-r,i|=this[--t]>>(r+=this.DB-8)):(i=this[t]>>(r-=8)&255,r<=0&&(r+=this.DB,--t)),0!=(128&i)&&(i|=-256),0==n&&(128&this.s)!=(128&i)&&++n,(n>0||i!=this.s)&&(e[n++]=i);return e},t.prototype.equals=function(t){return 0==this.compareTo(t)},t.prototype.min=function(t){return this.compareTo(t)<0?this:t},t.prototype.max=function(t){return this.compareTo(t)>0?this:t},t.prototype.and=function(t){var e=M();return this.bitwiseTo(t,r,e),e},t.prototype.or=function(t){var e=M();return this.bitwiseTo(t,n,e),e},t.prototype.xor=function(t){var e=M();return this.bitwiseTo(t,s,e),e},t.prototype.andNot=function(t){var e=M();return this.bitwiseTo(t,o,e),e},t.prototype.not=function(){for(var t=M(),e=0;e<this.t;++e)t[e]=this.DM&~this[e];return t.t=this.t,t.s=~this.s,t},t.prototype.shiftLeft=function(t){var e=M();return t<0?this.rShiftTo(-t,e):this.lShiftTo(t,e),e},t.prototype.shiftRight=function(t){var e=M();return t<0?this.lShiftTo(-t,e):this.rShiftTo(t,e),e},t.prototype.getLowestSetBit=function(){for(var t=0;t<this.t;++t)if(0!=this[t])return t*this.DB+h(this[t]);return this.s<0?this.t*this.DB:-1},t.prototype.bitCount=function(){for(var t=0,e=this.s&this.DM,i=0;i<this.t;++i)t+=a(this[i]^e);return t},t.prototype.testBit=function(t){var e=Math.floor(t/this.DB);return e>=this.t?0!=this.s:0!=(this[e]&1<<t%this.DB)},t.prototype.setBit=function(t){return this.changeBit(t,n)},t.prototype.clearBit=function(t){return this.changeBit(t,o)},t.prototype.flipBit=function(t){return this.changeBit(t,s)},t.prototype.add=function(t){var e=M();return this.addTo(t,e),e},t.prototype.subtract=function(t){var e=M();return this.subTo(t,e),e},t.prototype.multiply=function(t){var e=M();return this.multiplyTo(t,e),e},t.prototype.divide=function(t){var e=M();return this.divRemTo(t,e,null),e},t.prototype.remainder=function(t){var e=M();return this.divRemTo(t,null,e),e},t.prototype.divideAndRemainder=function(t){var e=M(),i=M();return this.divRemTo(t,e,i),[e,i]},t.prototype.modPow=function(t,e){var i,r,n=t.bitLength(),s=F(1);if(n<=0)return s;i=n<18?1:n<48?3:n<144?4:n<768?5:6,r=n<8?new I(e):e.isEven()?new P(e):new N(e);var o=[],h=3,a=i-1,u=(1<<i)-1;if(o[1]=r.convert(this),i>1){var c=M();for(r.sqrTo(o[1],c);h<=u;)o[h]=M(),r.mulTo(c,o[h-2],o[h]),h+=2}var f,l,p=t.t-1,g=!0,d=M();for(n=U(t[p])-1;p>=0;){for(n>=a?f=t[p]>>n-a&u:(f=(t[p]&(1<<n+1)-1)<<a-n,p>0&&(f|=t[p-1]>>this.DB+n-a)),h=i;0==(1&f);)f>>=1,--h;if((n-=h)<0&&(n+=this.DB,--p),g)o[f].copyTo(s),g=!1;else{for(;h>1;)r.sqrTo(s,d),r.sqrTo(d,s),h-=2;h>0?r.sqrTo(s,d):(l=s,s=d,d=l),r.mulTo(d,o[f],s)}for(;p>=0&&0==(t[p]&1<<n);)r.sqrTo(s,d),l=s,s=d,d=l,--n<0&&(n=this.DB-1,--p)}return r.revert(s)},t.prototype.modInverse=function(e){var i=e.isEven();if(this.isEven()&&i||0==e.signum())return t.ZERO;for(var r=e.clone(),n=this.clone(),s=F(1),o=F(0),h=F(0),a=F(1);0!=r.signum();){for(;r.isEven();)r.rShiftTo(1,r),i?(s.isEven()&&o.isEven()||(s.addTo(this,s),o.subTo(e,o)),s.rShiftTo(1,s)):o.isEven()||o.subTo(e,o),o.rShiftTo(1,o);for(;n.isEven();)n.rShiftTo(1,n),i?(h.isEven()&&a.isEven()||(h.addTo(this,h),a.subTo(e,a)),h.rShiftTo(1,h)):a.isEven()||a.subTo(e,a),a.rShiftTo(1,a);r.compareTo(n)>=0?(r.subTo(n,r),i&&s.subTo(h,s),o.subTo(a,o)):(n.subTo(r,n),i&&h.subTo(s,h),a.subTo(o,a))}return 0!=n.compareTo(t.ONE)?t.ZERO:a.compareTo(e)>=0?a.subtract(e):a.signum()<0?(a.addTo(e,a),a.signum()<0?a.add(e):a):a},t.prototype.pow=function(t){return this.exp(t,new V)},t.prototype.gcd=function(t){var e=this.s<0?this.negate():this.clone(),i=t.s<0?t.negate():t.clone();if(e.compareTo(i)<0){var r=e;e=i,i=r}var n=e.getLowestSetBit(),s=i.getLowestSetBit();if(s<0)return e;for(n<s&&(s=n),s>0&&(e.rShiftTo(s,e),i.rShiftTo(s,i));e.signum()>0;)(n=e.getLowestSetBit())>0&&e.rShiftTo(n,e),(n=i.getLowestSetBit())>0&&i.rShiftTo(n,i),e.compareTo(i)>=0?(e.subTo(i,e),e.rShiftTo(1,e)):(i.subTo(e,i),i.rShiftTo(1,i));return s>0&&i.lShiftTo(s,i),i},t.prototype.isProbablePrime=function(t){var e,i=this.abs();if(1==i.t&&i[0]<=B[B.length-1]){for(e=0;e<B.length;++e)if(i[0]==B[e])return!0;return!1}if(i.isEven())return!1;for(e=1;e<B.length;){for(var r=B[e],n=e+1;n<B.length&&r<A;)r*=B[n++];for(r=i.modInt(r);e<n;)if(r%B[e++]==0)return!1}return i.millerRabin(t)},t.prototype.copyTo=function(t){for(var e=this.t-1;e>=0;--e)t[e]=this[e];t.t=this.t,t.s=this.s},t.prototype.fromInt=function(t){this.t=1,this.s=t<0?-1:0,t>0?this[0]=t:t<-1?this[0]=t+this.DV:this.t=0},t.prototype.fromString=function(e,i){var r;if(16==i)r=4;else if(8==i)r=3;else if(256==i)r=8;else if(2==i)r=1;else if(32==i)r=5;else{if(4!=i)return void this.fromRadix(e,i);r=2}this.t=0,this.s=0;for(var n=e.length,s=!1,o=0;--n>=0;){var h=8==r?255&+e[n]:C(e,n);h<0?"-"==e.charAt(n)&&(s=!0):(s=!1,0==o?this[this.t++]=h:o+r>this.DB?(this[this.t-1]|=(h&(1<<this.DB-o)-1)<<o,this[this.t++]=h>>this.DB-o):this[this.t-1]|=h<<o,(o+=r)>=this.DB&&(o-=this.DB))}8==r&&0!=(128&+e[0])&&(this.s=-1,o>0&&(this[this.t-1]|=(1<<this.DB-o)-1<<o)),this.clamp(),s&&t.ZERO.subTo(this,this)},t.prototype.clamp=function(){for(var t=this.s&this.DM;this.t>0&&this[this.t-1]==t;)--this.t},t.prototype.dlShiftTo=function(t,e){var i;for(i=this.t-1;i>=0;--i)e[i+t]=this[i];for(i=t-1;i>=0;--i)e[i]=0;e.t=this.t+t,e.s=this.s},t.prototype.drShiftTo=function(t,e){for(var i=t;i<this.t;++i)e[i-t]=this[i];e.t=Math.max(this.t-t,0),e.s=this.s},t.prototype.lShiftTo=function(t,e){for(var i=t%this.DB,r=this.DB-i,n=(1<<r)-1,s=Math.floor(t/this.DB),o=this.s<<i&this.DM,h=this.t-1;h>=0;--h)e[h+s+1]=this[h]>>r|o,o=(this[h]&n)<<i;for(h=s-1;h>=0;--h)e[h]=0;e[s]=o,e.t=this.t+s+1,e.s=this.s,e.clamp()},t.prototype.rShiftTo=function(t,e){e.s=this.s;var i=Math.floor(t/this.DB);if(i>=this.t)e.t=0;else{var r=t%this.DB,n=this.DB-r,s=(1<<r)-1;e[0]=this[i]>>r;for(var o=i+1;o<this.t;++o)e[o-i-1]|=(this[o]&s)<<n,e[o-i]=this[o]>>r;r>0&&(e[this.t-i-1]|=(this.s&s)<<n),e.t=this.t-i,e.clamp()}},t.prototype.subTo=function(t,e){for(var i=0,r=0,n=Math.min(t.t,this.t);i<n;)r+=this[i]-t[i],e[i++]=r&this.DM,r>>=this.DB;if(t.t<this.t){for(r-=t.s;i<this.t;)r+=this[i],e[i++]=r&this.DM,r>>=this.DB;r+=this.s}else{for(r+=this.s;i<t.t;)r-=t[i],e[i++]=r&this.DM,r>>=this.DB;r-=t.s}e.s=r<0?-1:0,r<-1?e[i++]=this.DV+r:r>0&&(e[i++]=r),e.t=i,e.clamp()},t.prototype.multiplyTo=function(e,i){var r=this.abs(),n=e.abs(),s=r.t;for(i.t=s+n.t;--s>=0;)i[s]=0;for(s=0;s<n.t;++s)i[s+r.t]=r.am(0,n[s],i,s,0,r.t);i.s=0,i.clamp(),this.s!=e.s&&t.ZERO.subTo(i,i)},t.prototype.squareTo=function(t){for(var e=this.abs(),i=t.t=2*e.t;--i>=0;)t[i]=0;for(i=0;i<e.t-1;++i){var r=e.am(i,e[i],t,2*i,0,1);(t[i+e.t]+=e.am(i+1,2*e[i],t,2*i+1,r,e.t-i-1))>=e.DV&&(t[i+e.t]-=e.DV,t[i+e.t+1]=1)}t.t>0&&(t[t.t-1]+=e.am(i,e[i],t,2*i,0,1)),t.s=0,t.clamp()},t.prototype.divRemTo=function(e,i,r){var n=e.abs();if(!(n.t<=0)){var s=this.abs();if(s.t<n.t)return null!=i&&i.fromInt(0),void(null!=r&&this.copyTo(r));null==r&&(r=M());var o=M(),h=this.s,a=e.s,u=this.DB-U(n[n.t-1]);u>0?(n.lShiftTo(u,o),s.lShiftTo(u,r)):(n.copyTo(o),s.copyTo(r));var c=o.t,f=o[c-1];if(0!=f){var l=f*(1<<this.F1)+(c>1?o[c-2]>>this.F2:0),p=this.FV/l,g=(1<<this.F1)/l,d=1<<this.F2,v=r.t,m=v-c,y=null==i?M():i;for(o.dlShiftTo(m,y),r.compareTo(y)>=0&&(r[r.t++]=1,r.subTo(y,r)),t.ONE.dlShiftTo(c,y),y.subTo(o,o);o.t<c;)o[o.t++]=0;for(;--m>=0;){var b=r[--v]==f?this.DM:Math.floor(r[v]*p+(r[v-1]+d)*g);if((r[v]+=o.am(0,b,r,m,0,c))<b)for(o.dlShiftTo(m,y),r.subTo(y,r);r[v]<--b;)r.subTo(y,r)}null!=i&&(r.drShiftTo(c,i),h!=a&&t.ZERO.subTo(i,i)),r.t=c,r.clamp(),u>0&&r.rShiftTo(u,r),h<0&&t.ZERO.subTo(r,r)}}},t.prototype.invDigit=function(){if(this.t<1)return 0;var t=this[0];if(0==(1&t))return 0;var e=3&t;return(e=(e=(e=(e=e*(2-(15&t)*e)&15)*(2-(255&t)*e)&255)*(2-((65535&t)*e&65535))&65535)*(2-t*e%this.DV)%this.DV)>0?this.DV-e:-e},t.prototype.isEven=function(){return 0==(this.t>0?1&this[0]:this.s)},t.prototype.exp=function(e,i){if(e>4294967295||e<1)return t.ONE;var r=M(),n=M(),s=i.convert(this),o=U(e)-1;for(s.copyTo(r);--o>=0;)if(i.sqrTo(r,n),(e&1<<o)>0)i.mulTo(n,s,r);else{var h=r;r=n,n=h}return i.revert(r)},t.prototype.chunkSize=function(t){return Math.floor(Math.LN2*this.DB/Math.log(t))},t.prototype.toRadix=function(t){if(null==t&&(t=10),0==this.signum()||t<2||t>36)return"0";var e=this.chunkSize(t),i=Math.pow(t,e),r=F(i),n=M(),s=M(),o="";for(this.divRemTo(r,n,s);n.signum()>0;)o=(i+s.intValue()).toString(t).substr(1)+o,n.divRemTo(r,n,s);return s.intValue().toString(t)+o},t.prototype.fromRadix=function(e,i){this.fromInt(0),null==i&&(i=10);for(var r=this.chunkSize(i),n=Math.pow(i,r),s=!1,o=0,h=0,a=0;a<e.length;++a){var u=C(e,a);u<0?"-"==e.charAt(a)&&0==this.signum()&&(s=!0):(h=i*h+u,++o>=r&&(this.dMultiply(n),this.dAddOffset(h,0),o=0,h=0))}o>0&&(this.dMultiply(Math.pow(i,o)),this.dAddOffset(h,0)),s&&t.ZERO.subTo(this,this)},t.prototype.fromNumber=function(e,i,r){if("number"==typeof i)if(e<2)this.fromInt(1);else for(this.fromNumber(e,r),this.testBit(e-1)||this.bitwiseTo(t.ONE.shiftLeft(e-1),n,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(i);)this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(t.ONE.shiftLeft(e-1),this);else{var s=[],o=7&e;s.length=1+(e>>3),i.nextBytes(s),o>0?s[0]&=(1<<o)-1:s[0]=0,this.fromString(s,256)}},t.prototype.bitwiseTo=function(t,e,i){var r,n,s=Math.min(t.t,this.t);for(r=0;r<s;++r)i[r]=e(this[r],t[r]);if(t.t<this.t){for(n=t.s&this.DM,r=s;r<this.t;++r)i[r]=e(this[r],n);i.t=this.t}else{for(n=this.s&this.DM,r=s;r<t.t;++r)i[r]=e(n,t[r]);i.t=t.t}i.s=e(this.s,t.s),i.clamp()},t.prototype.changeBit=function(e,i){var r=t.ONE.shiftLeft(e);return this.bitwiseTo(r,i,r),r},t.prototype.addTo=function(t,e){for(var i=0,r=0,n=Math.min(t.t,this.t);i<n;)r+=this[i]+t[i],e[i++]=r&this.DM,r>>=this.DB;if(t.t<this.t){for(r+=t.s;i<this.t;)r+=this[i],e[i++]=r&this.DM,r>>=this.DB;r+=this.s}else{for(r+=this.s;i<t.t;)r+=t[i],e[i++]=r&this.DM,r>>=this.DB;r+=t.s}e.s=r<0?-1:0,r>0?e[i++]=r:r<-1&&(e[i++]=this.DV+r),e.t=i,e.clamp()},t.prototype.dMultiply=function(t){this[this.t]=this.am(0,t-1,this,0,0,this.t),++this.t,this.clamp()},t.prototype.dAddOffset=function(t,e){if(0!=t){for(;this.t<=e;)this[this.t++]=0;for(this[e]+=t;this[e]>=this.DV;)this[e]-=this.DV,++e>=this.t&&(this[this.t++]=0),++this[e]}},t.prototype.multiplyLowerTo=function(t,e,i){var r=Math.min(this.t+t.t,e);for(i.s=0,i.t=r;r>0;)i[--r]=0;for(var n=i.t-this.t;r<n;++r)i[r+this.t]=this.am(0,t[r],i,r,0,this.t);for(n=Math.min(t.t,e);r<n;++r)this.am(0,t[r],i,r,0,e-r);i.clamp()},t.prototype.multiplyUpperTo=function(t,e,i){--e;var r=i.t=this.t+t.t-e;for(i.s=0;--r>=0;)i[r]=0;for(r=Math.max(e-this.t,0);r<t.t;++r)i[this.t+r-e]=this.am(e-r,t[r],i,0,0,this.t+r-e);i.clamp(),i.drShiftTo(1,i)},t.prototype.modInt=function(t){if(t<=0)return 0;var e=this.DV%t,i=this.s<0?t-1:0;if(this.t>0)if(0==e)i=this[0]%t;else for(var r=this.t-1;r>=0;--r)i=(e*i+this[r])%t;return i},t.prototype.millerRabin=function(e){var i=this.subtract(t.ONE),r=i.getLowestSetBit();if(r<=0)return!1;var n=i.shiftRight(r);(e=e+1>>1)>B.length&&(e=B.length);for(var s=M(),o=0;o<e;++o){s.fromInt(B[Math.floor(Math.random()*B.length)]);var h=s.modPow(n,this);if(0!=h.compareTo(t.ONE)&&0!=h.compareTo(i)){for(var a=1;a++<r&&0!=h.compareTo(i);)if(0==(h=h.modPowInt(2,this)).compareTo(t.ONE))return!1;if(0!=h.compareTo(i))return!1}}return!0},t.prototype.square=function(){var t=M();return this.squareTo(t),t},t.prototype.gcda=function(t,e){var i=this.s<0?this.negate():this.clone(),r=t.s<0?t.negate():t.clone();if(i.compareTo(r)<0){var n=i;i=r,r=n}var s=i.getLowestSetBit(),o=r.getLowestSetBit();if(o<0)e(i);else{s<o&&(o=s),o>0&&(i.rShiftTo(o,i),r.rShiftTo(o,r));var h=function(){(s=i.getLowestSetBit())>0&&i.rShiftTo(s,i),(s=r.getLowestSetBit())>0&&r.rShiftTo(s,r),i.compareTo(r)>=0?(i.subTo(r,i),i.rShiftTo(1,i)):(r.subTo(i,r),r.rShiftTo(1,r)),i.signum()>0?setTimeout(h,0):(o>0&&r.lShiftTo(o,r),setTimeout(function(){e(r)},0))};setTimeout(h,10)}},t.prototype.fromNumberAsync=function(e,i,r,s){if("number"==typeof i)if(e<2)this.fromInt(1);else{this.fromNumber(e,r),this.testBit(e-1)||this.bitwiseTo(t.ONE.shiftLeft(e-1),n,this),this.isEven()&&this.dAddOffset(1,0);var o=this,h=function(){o.dAddOffset(2,0),o.bitLength()>e&&o.subTo(t.ONE.shiftLeft(e-1),o),o.isProbablePrime(i)?setTimeout(function(){s()},0):setTimeout(h,0)};setTimeout(h,0)}else{var a=[],u=7&e;a.length=1+(e>>3),i.nextBytes(a),u>0?a[0]&=(1<<u)-1:a[0]=0,this.fromString(a,256)}},t}(),V=function(){function t(){}return t.prototype.convert=function(t){return t},t.prototype.revert=function(t){return t},t.prototype.mulTo=function(t,e,i){t.multiplyTo(e,i)},t.prototype.sqrTo=function(t,e){t.squareTo(e)},t}(),I=function(){function t(t){this.m=t}return t.prototype.convert=function(t){return t.s<0||t.compareTo(this.m)>=0?t.mod(this.m):t},t.prototype.revert=function(t){return t},t.prototype.reduce=function(t){t.divRemTo(this.m,null,t)},t.prototype.mulTo=function(t,e,i){t.multiplyTo(e,i),this.reduce(i)},t.prototype.sqrTo=function(t,e){t.squareTo(e),this.reduce(e)},t}(),N=function(){function t(t){this.m=t,this.mp=t.invDigit(),this.mpl=32767&this.mp,this.mph=this.mp>>15,this.um=(1<<t.DB-15)-1,this.mt2=2*t.t}return t.prototype.convert=function(t){var e=M();return t.abs().dlShiftTo(this.m.t,e),e.divRemTo(this.m,null,e),t.s<0&&e.compareTo(O.ZERO)>0&&this.m.subTo(e,e),e},t.prototype.revert=function(t){var e=M();return t.copyTo(e),this.reduce(e),e},t.prototype.reduce=function(t){for(;t.t<=this.mt2;)t[t.t++]=0;for(var e=0;e<this.m.t;++e){var i=32767&t[e],r=i*this.mpl+((i*this.mph+(t[e]>>15)*this.mpl&this.um)<<15)&t.DM;for(t[i=e+this.m.t]+=this.m.am(0,r,t,e,0,this.m.t);t[i]>=t.DV;)t[i]-=t.DV,t[++i]++}t.clamp(),t.drShiftTo(this.m.t,t),t.compareTo(this.m)>=0&&t.subTo(this.m,t)},t.prototype.mulTo=function(t,e,i){t.multiplyTo(e,i),this.reduce(i)},t.prototype.sqrTo=function(t,e){t.squareTo(e),this.reduce(e)},t}(),P=function(){function t(t){this.m=t,this.r2=M(),this.q3=M(),O.ONE.dlShiftTo(2*t.t,this.r2),this.mu=this.r2.divide(t)}return t.prototype.convert=function(t){if(t.s<0||t.t>2*this.m.t)return t.mod(this.m);if(t.compareTo(this.m)<0)return t;var e=M();return t.copyTo(e),this.reduce(e),e},t.prototype.revert=function(t){return t},t.prototype.reduce=function(t){for(t.drShiftTo(this.m.t-1,this.r2),t.t>this.m.t+1&&(t.t=this.m.t+1,t.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);t.compareTo(this.r2)<0;)t.dAddOffset(1,this.m.t+1);for(t.subTo(this.r2,t);t.compareTo(this.m)>=0;)t.subTo(this.m,t)},t.prototype.mulTo=function(t,e,i){t.multiplyTo(e,i),this.reduce(i)},t.prototype.sqrTo=function(t,e){t.squareTo(e),this.reduce(e)},t}();function M(){return new O(null)}function q(t,e){return new O(t,e)}"Microsoft Internet Explorer"==navigator.appName?(O.prototype.am=function(t,e,i,r,n,s){for(var o=32767&e,h=e>>15;--s>=0;){var a=32767&this[t],u=this[t++]>>15,c=h*a+u*o;n=((a=o*a+((32767&c)<<15)+i[r]+(1073741823&n))>>>30)+(c>>>15)+h*u+(n>>>30),i[r++]=1073741823&a}return n},w=30):"Netscape"!=navigator.appName?(O.prototype.am=function(t,e,i,r,n,s){for(;--s>=0;){var o=e*this[t++]+i[r]+n;n=Math.floor(o/67108864),i[r++]=67108863&o}return n},w=26):(O.prototype.am=function(t,e,i,r,n,s){for(var o=16383&e,h=e>>14;--s>=0;){var a=16383&this[t],u=this[t++]>>14,c=h*a+u*o;n=((a=o*a+((16383&c)<<14)+i[r]+n)>>28)+(c>>14)+h*u,i[r++]=268435455&a}return n},w=28),O.prototype.DB=w,O.prototype.DM=(1<<w)-1,O.prototype.DV=1<<w;O.prototype.FV=Math.pow(2,52),O.prototype.F1=52-w,O.prototype.F2=2*w-52;var j,L,H=[];for(j="0".charCodeAt(0),L=0;L<=9;++L)H[j++]=L;for(j="a".charCodeAt(0),L=10;L<36;++L)H[j++]=L;for(j="A".charCodeAt(0),L=10;L<36;++L)H[j++]=L;function C(t,e){var i=H[t.charCodeAt(e)];return null==i?-1:i}function F(t){var e=M();return e.fromInt(t),e}function U(t){var e,i=1;return 0!=(e=t>>>16)&&(t=e,i+=16),0!=(e=t>>8)&&(t=e,i+=8),0!=(e=t>>4)&&(t=e,i+=4),0!=(e=t>>2)&&(t=e,i+=2),0!=(e=t>>1)&&(t=e,i+=1),i}O.ZERO=F(0),O.ONE=F(1);var K=function(){function t(){this.i=0,this.j=0,this.S=[]}return t.prototype.init=function(t){var e,i,r;for(e=0;e<256;++e)this.S[e]=e;for(i=0,e=0;e<256;++e)i=i+this.S[e]+t[e%t.length]&255,r=this.S[e],this.S[e]=this.S[i],this.S[i]=r;this.i=0,this.j=0},t.prototype.next=function(){var t;return this.i=this.i+1&255,this.j=this.j+this.S[this.i]&255,t=this.S[this.i],this.S[this.i]=this.S[this.j],this.S[this.j]=t,this.S[t+this.S[this.i]&255]},t}();var k,_,z=256,Z=null;if(null==Z){Z=[],_=0;var G=void 0;if(window.crypto&&window.crypto.getRandomValues){var $=new Uint32Array(256);for(window.crypto.getRandomValues($),G=0;G<$.length;++G)Z[_++]=255&$[G]}var Y=function(t){if(this.count=this.count||0,this.count>=256||_>=z)window.removeEventListener?window.removeEventListener("mousemove",Y,!1):window.detachEvent&&window.detachEvent("onmousemove",Y);else try{var e=t.x+t.y;Z[_++]=255&e,this.count+=1}catch(t){}};window.addEventListener?window.addEventListener("mousemove",Y,!1):window.attachEvent&&window.attachEvent("onmousemove",Y)}function J(){if(null==k){for(k=new K;_<z;){var t=Math.floor(65536*Math.random());Z[_++]=255&t}for(k.init(Z),_=0;_<Z.length;++_)Z[_]=0;_=0}return k.next()}var X=function(){function t(){}return t.prototype.nextBytes=function(t){for(var e=0;e<t.length;++e)t[e]=J()},t}();var Q=function(){function t(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null}return t.prototype.doPublic=function(t){return t.modPowInt(this.e,this.n)},t.prototype.doPrivate=function(t){if(null==this.p||null==this.q)return t.modPow(this.d,this.n);for(var e=t.mod(this.p).modPow(this.dmp1,this.p),i=t.mod(this.q).modPow(this.dmq1,this.q);e.compareTo(i)<0;)e=e.add(this.p);return e.subtract(i).multiply(this.coeff).mod(this.p).multiply(this.q).add(i)},t.prototype.setPublic=function(t,e){null!=t&&null!=e&&t.length>0&&e.length>0?(this.n=q(t,16),this.e=parseInt(e,16)):console.error("Invalid RSA public key")},t.prototype.encrypt=function(t){var e=function(t,e){if(e<t.length+11)return console.error("Message too long for RSA"),null;for(var i=[],r=t.length-1;r>=0&&e>0;){var n=t.charCodeAt(r--);n<128?i[--e]=n:n>127&&n<2048?(i[--e]=63&n|128,i[--e]=n>>6|192):(i[--e]=63&n|128,i[--e]=n>>6&63|128,i[--e]=n>>12|224)}i[--e]=0;for(var s=new X,o=[];e>2;){for(o[0]=0;0==o[0];)s.nextBytes(o);i[--e]=o[0]}return i[--e]=2,i[--e]=0,new O(i)}(t,this.n.bitLength()+7>>3);if(null==e)return null;var i=this.doPublic(e);if(null==i)return null;var r=i.toString(16);return 0==(1&r.length)?r:"0"+r},t.prototype.setPrivate=function(t,e,i){null!=t&&null!=e&&t.length>0&&e.length>0?(this.n=q(t,16),this.e=parseInt(e,16),this.d=q(i,16)):console.error("Invalid RSA private key")},t.prototype.setPrivateEx=function(t,e,i,r,n,s,o,h){null!=t&&null!=e&&t.length>0&&e.length>0?(this.n=q(t,16),this.e=parseInt(e,16),this.d=q(i,16),this.p=q(r,16),this.q=q(n,16),this.dmp1=q(s,16),this.dmq1=q(o,16),this.coeff=q(h,16)):console.error("Invalid RSA private key")},t.prototype.generate=function(t,e){var i=new X,r=t>>1;this.e=parseInt(e,16);for(var n=new O(e,16);;){for(;this.p=new O(t-r,1,i),0!=this.p.subtract(O.ONE).gcd(n).compareTo(O.ONE)||!this.p.isProbablePrime(10););for(;this.q=new O(r,1,i),0!=this.q.subtract(O.ONE).gcd(n).compareTo(O.ONE)||!this.q.isProbablePrime(10););if(this.p.compareTo(this.q)<=0){var s=this.p;this.p=this.q,this.q=s}var o=this.p.subtract(O.ONE),h=this.q.subtract(O.ONE),a=o.multiply(h);if(0==a.gcd(n).compareTo(O.ONE)){this.n=this.p.multiply(this.q),this.d=n.modInverse(a),this.dmp1=this.d.mod(o),this.dmq1=this.d.mod(h),this.coeff=this.q.modInverse(this.p);break}}},t.prototype.decrypt=function(t){var e=q(t,16),i=this.doPrivate(e);return null==i?null:function(t,e){var i=t.toByteArray(),r=0;for(;r<i.length&&0==i[r];)++r;if(i.length-r!=e-1||2!=i[r])return null;++r;for(;0!=i[r];)if(++r>=i.length)return null;var n="";for(;++r<i.length;){var s=255&i[r];s<128?n+=String.fromCharCode(s):s>191&&s<224?(n+=String.fromCharCode((31&s)<<6|63&i[r+1]),++r):(n+=String.fromCharCode((15&s)<<12|(63&i[r+1])<<6|63&i[r+2]),r+=2)}return n}(i,this.n.bitLength()+7>>3)},t.prototype.generateAsync=function(t,e,i){var r=new X,n=t>>1;this.e=parseInt(e,16);var s=new O(e,16),o=this,h=function(){var e=function(){if(o.p.compareTo(o.q)<=0){var t=o.p;o.p=o.q,o.q=t}var e=o.p.subtract(O.ONE),r=o.q.subtract(O.ONE),n=e.multiply(r);0==n.gcd(s).compareTo(O.ONE)?(o.n=o.p.multiply(o.q),o.d=s.modInverse(n),o.dmp1=o.d.mod(e),o.dmq1=o.d.mod(r),o.coeff=o.q.modInverse(o.p),setTimeout(function(){i()},0)):setTimeout(h,0)},a=function(){o.q=M(),o.q.fromNumberAsync(n,1,r,function(){o.q.subtract(O.ONE).gcda(s,function(t){0==t.compareTo(O.ONE)&&o.q.isProbablePrime(10)?setTimeout(e,0):setTimeout(a,0)})})},u=function(){o.p=M(),o.p.fromNumberAsync(t-n,1,r,function(){o.p.subtract(O.ONE).gcda(s,function(t){0==t.compareTo(O.ONE)&&o.p.isProbablePrime(10)?setTimeout(a,0):setTimeout(u,0)})})};setTimeout(u,0)};setTimeout(h,0)},t}();var W={};W.lang={extend:function(t,e,i){if(!e||!t)throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included.");var r=function(){};if(r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t,t.superclass=e.prototype,e.prototype.constructor==Object.prototype.constructor&&(e.prototype.constructor=e),i){var n;for(n in i)t.prototype[n]=i[n];var s=function(){},o=["toString","valueOf"];try{/MSIE/.test(navigator.userAgent)&&(s=function(t,e){for(n=0;n<o.length;n+=1){var i=o[n],r=e[i];"function"==typeof r&&r!=Object.prototype[i]&&(t[i]=r)}})}catch(t){}s(t.prototype,i)}}};var tt={};void 0!==tt.asn1&&tt.asn1||(tt.asn1={}),tt.asn1.ASN1Util=new function(){this.integerToByteHex=function(t){var e=t.toString(16);return e.length%2==1&&(e="0"+e),e},this.bigIntToMinTwosComplementsHex=function(t){var e=t.toString(16);if("-"!=e.substr(0,1))e.length%2==1?e="0"+e:e.match(/^[0-7]/)||(e="00"+e);else{var i=e.substr(1).length;i%2==1?i+=1:e.match(/^[0-7]/)||(i+=2);for(var r="",n=0;n<i;n++)r+="f";e=new O(r,16).xor(t).add(O.ONE).toString(16).replace(/^-/,"")}return e},this.getPEMStringFromHex=function(t,e){return hextopem(t,e)},this.newObject=function(t){var e=tt.asn1,i=e.DERBoolean,r=e.DERInteger,n=e.DERBitString,s=e.DEROctetString,o=e.DERNull,h=e.DERObjectIdentifier,a=e.DEREnumerated,u=e.DERUTF8String,c=e.DERNumericString,f=e.DERPrintableString,l=e.DERTeletexString,p=e.DERIA5String,g=e.DERUTCTime,d=e.DERGeneralizedTime,v=e.DERSequence,m=e.DERSet,y=e.DERTaggedObject,b=e.ASN1Util.newObject,T=Object.keys(t);if(1!=T.length)throw"key of param shall be only one.";var S=T[0];if(-1==":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":"+S+":"))throw"undefined key: "+S;if("bool"==S)return new i(t[S]);if("int"==S)return new r(t[S]);if("bitstr"==S)return new n(t[S]);if("octstr"==S)return new s(t[S]);if("null"==S)return new o(t[S]);if("oid"==S)return new h(t[S]);if("enum"==S)return new a(t[S]);if("utf8str"==S)return new u(t[S]);if("numstr"==S)return new c(t[S]);if("prnstr"==S)return new f(t[S]);if("telstr"==S)return new l(t[S]);if("ia5str"==S)return new p(t[S]);if("utctime"==S)return new g(t[S]);if("gentime"==S)return new d(t[S]);if("seq"==S){for(var E=t[S],w=[],D=0;D<E.length;D++){var x=b(E[D]);w.push(x)}return new v({array:w})}if("set"==S){for(E=t[S],w=[],D=0;D<E.length;D++){x=b(E[D]);w.push(x)}return new m({array:w})}if("tag"==S){var R=t[S];if("[object Array]"===Object.prototype.toString.call(R)&&3==R.length){var B=b(R[2]);return new y({tag:R[0],explicit:R[1],obj:B})}var A={};if(void 0!==R.explicit&&(A.explicit=R.explicit),void 0!==R.tag&&(A.tag=R.tag),void 0===R.obj)throw"obj shall be specified for 'tag'.";return A.obj=b(R.obj),new y(A)}},this.jsonToASN1HEX=function(t){return this.newObject(t).getEncodedHex()}},tt.asn1.ASN1Util.oidHexToInt=function(t){for(var e="",i=parseInt(t.substr(0,2),16),r=(e=Math.floor(i/40)+"."+i%40,""),n=2;n<t.length;n+=2){var s=("00000000"+parseInt(t.substr(n,2),16).toString(2)).slice(-8);if(r+=s.substr(1,7),"0"==s.substr(0,1))e=e+"."+new O(r,2).toString(10),r=""}return e},tt.asn1.ASN1Util.oidIntToHex=function(t){var e=function(t){var e=t.toString(16);return 1==e.length&&(e="0"+e),e},i=function(t){var i="",r=new O(t,10).toString(2),n=7-r.length%7;7==n&&(n=0);for(var s="",o=0;o<n;o++)s+="0";r=s+r;for(o=0;o<r.length-1;o+=7){var h=r.substr(o,7);o!=r.length-7&&(h="1"+h),i+=e(parseInt(h,2))}return i};if(!t.match(/^[0-9.]+$/))throw"malformed oid string: "+t;var r="",n=t.split("."),s=40*parseInt(n[0])+parseInt(n[1]);r+=e(s),n.splice(0,2);for(var o=0;o<n.length;o++)r+=i(n[o]);return r},tt.asn1.ASN1Object=function(){this.getLengthHexFromValue=function(){if(void 0===this.hV||null==this.hV)throw"this.hV is null or undefined.";if(this.hV.length%2==1)throw"value hex must be even length: n="+"".length+",v="+this.hV;var t=this.hV.length/2,e=t.toString(16);if(e.length%2==1&&(e="0"+e),t<128)return e;var i=e.length/2;if(i>15)throw"ASN.1 length too long to represent by 8x: n = "+t.toString(16);return(128+i).toString(16)+e},this.getEncodedHex=function(){return(null==this.hTLV||this.isModified)&&(this.hV=this.getFreshValueHex(),this.hL=this.getLengthHexFromValue(),this.hTLV=this.hT+this.hL+this.hV,this.isModified=!1),this.hTLV},this.getValueHex=function(){return this.getEncodedHex(),this.hV},this.getFreshValueHex=function(){return""}},tt.asn1.DERAbstractString=function(t){tt.asn1.DERAbstractString.superclass.constructor.call(this),this.getString=function(){return this.s},this.setString=function(t){this.hTLV=null,this.isModified=!0,this.s=t,this.hV=stohex(this.s)},this.setStringHex=function(t){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=t},this.getFreshValueHex=function(){return this.hV},void 0!==t&&("string"==typeof t?this.setString(t):void 0!==t.str?this.setString(t.str):void 0!==t.hex&&this.setStringHex(t.hex))},W.lang.extend(tt.asn1.DERAbstractString,tt.asn1.ASN1Object),tt.asn1.DERAbstractTime=function(t){tt.asn1.DERAbstractTime.superclass.constructor.call(this),this.localDateToUTC=function(t){return utc=t.getTime()+6e4*t.getTimezoneOffset(),new Date(utc)},this.formatDate=function(t,e,i){var r=this.zeroPadding,n=this.localDateToUTC(t),s=String(n.getFullYear());"utc"==e&&(s=s.substr(2,2));var o=s+r(String(n.getMonth()+1),2)+r(String(n.getDate()),2)+r(String(n.getHours()),2)+r(String(n.getMinutes()),2)+r(String(n.getSeconds()),2);if(!0===i){var h=n.getMilliseconds();if(0!=h){var a=r(String(h),3);o=o+"."+(a=a.replace(/[0]+$/,""))}}return o+"Z"},this.zeroPadding=function(t,e){return t.length>=e?t:new Array(e-t.length+1).join("0")+t},this.getString=function(){return this.s},this.setString=function(t){this.hTLV=null,this.isModified=!0,this.s=t,this.hV=stohex(t)},this.setByDateValue=function(t,e,i,r,n,s){var o=new Date(Date.UTC(t,e-1,i,r,n,s,0));this.setByDate(o)},this.getFreshValueHex=function(){return this.hV}},W.lang.extend(tt.asn1.DERAbstractTime,tt.asn1.ASN1Object),tt.asn1.DERAbstractStructured=function(t){tt.asn1.DERAbstractString.superclass.constructor.call(this),this.setByASN1ObjectArray=function(t){this.hTLV=null,this.isModified=!0,this.asn1Array=t},this.appendASN1Object=function(t){this.hTLV=null,this.isModified=!0,this.asn1Array.push(t)},this.asn1Array=new Array,void 0!==t&&void 0!==t.array&&(this.asn1Array=t.array)},W.lang.extend(tt.asn1.DERAbstractStructured,tt.asn1.ASN1Object),tt.asn1.DERBoolean=function(){tt.asn1.DERBoolean.superclass.constructor.call(this),this.hT="01",this.hTLV="0101ff"},W.lang.extend(tt.asn1.DERBoolean,tt.asn1.ASN1Object),tt.asn1.DERInteger=function(t){tt.asn1.DERInteger.superclass.constructor.call(this),this.hT="02",this.setByBigInteger=function(t){this.hTLV=null,this.isModified=!0,this.hV=tt.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t)},this.setByInteger=function(t){var e=new O(String(t),10);this.setByBigInteger(e)},this.setValueHex=function(t){this.hV=t},this.getFreshValueHex=function(){return this.hV},void 0!==t&&(void 0!==t.bigint?this.setByBigInteger(t.bigint):void 0!==t.int?this.setByInteger(t.int):"number"==typeof t?this.setByInteger(t):void 0!==t.hex&&this.setValueHex(t.hex))},W.lang.extend(tt.asn1.DERInteger,tt.asn1.ASN1Object),tt.asn1.DERBitString=function(t){if(void 0!==t&&void 0!==t.obj){var e=tt.asn1.ASN1Util.newObject(t.obj);t.hex="00"+e.getEncodedHex()}tt.asn1.DERBitString.superclass.constructor.call(this),this.hT="03",this.setHexValueIncludingUnusedBits=function(t){this.hTLV=null,this.isModified=!0,this.hV=t},this.setUnusedBitsAndHexValue=function(t,e){if(t<0||7<t)throw"unused bits shall be from 0 to 7: u = "+t;var i="0"+t;this.hTLV=null,this.isModified=!0,this.hV=i+e},this.setByBinaryString=function(t){var e=8-(t=t.replace(/0+$/,"")).length%8;8==e&&(e=0);for(var i=0;i<=e;i++)t+="0";var r="";for(i=0;i<t.length-1;i+=8){var n=t.substr(i,8),s=parseInt(n,2).toString(16);1==s.length&&(s="0"+s),r+=s}this.hTLV=null,this.isModified=!0,this.hV="0"+e+r},this.setByBooleanArray=function(t){for(var e="",i=0;i<t.length;i++)1==t[i]?e+="1":e+="0";this.setByBinaryString(e)},this.newFalseArray=function(t){for(var e=new Array(t),i=0;i<t;i++)e[i]=!1;return e},this.getFreshValueHex=function(){return this.hV},void 0!==t&&("string"==typeof t&&t.toLowerCase().match(/^[0-9a-f]+$/)?this.setHexValueIncludingUnusedBits(t):void 0!==t.hex?this.setHexValueIncludingUnusedBits(t.hex):void 0!==t.bin?this.setByBinaryString(t.bin):void 0!==t.array&&this.setByBooleanArray(t.array))},W.lang.extend(tt.asn1.DERBitString,tt.asn1.ASN1Object),tt.asn1.DEROctetString=function(t){if(void 0!==t&&void 0!==t.obj){var e=tt.asn1.ASN1Util.newObject(t.obj);t.hex=e.getEncodedHex()}tt.asn1.DEROctetString.superclass.constructor.call(this,t),this.hT="04"},W.lang.extend(tt.asn1.DEROctetString,tt.asn1.DERAbstractString),tt.asn1.DERNull=function(){tt.asn1.DERNull.superclass.constructor.call(this),this.hT="05",this.hTLV="0500"},W.lang.extend(tt.asn1.DERNull,tt.asn1.ASN1Object),tt.asn1.DERObjectIdentifier=function(t){var e=function(t){var e=t.toString(16);return 1==e.length&&(e="0"+e),e},i=function(t){var i="",r=new O(t,10).toString(2),n=7-r.length%7;7==n&&(n=0);for(var s="",o=0;o<n;o++)s+="0";r=s+r;for(o=0;o<r.length-1;o+=7){var h=r.substr(o,7);o!=r.length-7&&(h="1"+h),i+=e(parseInt(h,2))}return i};tt.asn1.DERObjectIdentifier.superclass.constructor.call(this),this.hT="06",this.setValueHex=function(t){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=t},this.setValueOidString=function(t){if(!t.match(/^[0-9.]+$/))throw"malformed oid string: "+t;var r="",n=t.split("."),s=40*parseInt(n[0])+parseInt(n[1]);r+=e(s),n.splice(0,2);for(var o=0;o<n.length;o++)r+=i(n[o]);this.hTLV=null,this.isModified=!0,this.s=null,this.hV=r},this.setValueName=function(t){var e=tt.asn1.x509.OID.name2oid(t);if(""===e)throw"DERObjectIdentifier oidName undefined: "+t;this.setValueOidString(e)},this.getFreshValueHex=function(){return this.hV},void 0!==t&&("string"==typeof t?t.match(/^[0-2].[0-9.]+$/)?this.setValueOidString(t):this.setValueName(t):void 0!==t.oid?this.setValueOidString(t.oid):void 0!==t.hex?this.setValueHex(t.hex):void 0!==t.name&&this.setValueName(t.name))},W.lang.extend(tt.asn1.DERObjectIdentifier,tt.asn1.ASN1Object),tt.asn1.DEREnumerated=function(t){tt.asn1.DEREnumerated.superclass.constructor.call(this),this.hT="0a",this.setByBigInteger=function(t){this.hTLV=null,this.isModified=!0,this.hV=tt.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t)},this.setByInteger=function(t){var e=new O(String(t),10);this.setByBigInteger(e)},this.setValueHex=function(t){this.hV=t},this.getFreshValueHex=function(){return this.hV},void 0!==t&&(void 0!==t.int?this.setByInteger(t.int):"number"==typeof t?this.setByInteger(t):void 0!==t.hex&&this.setValueHex(t.hex))},W.lang.extend(tt.asn1.DEREnumerated,tt.asn1.ASN1Object),tt.asn1.DERUTF8String=function(t){tt.asn1.DERUTF8String.superclass.constructor.call(this,t),this.hT="0c"},W.lang.extend(tt.asn1.DERUTF8String,tt.asn1.DERAbstractString),tt.asn1.DERNumericString=function(t){tt.asn1.DERNumericString.superclass.constructor.call(this,t),this.hT="12"},W.lang.extend(tt.asn1.DERNumericString,tt.asn1.DERAbstractString),tt.asn1.DERPrintableString=function(t){tt.asn1.DERPrintableString.superclass.constructor.call(this,t),this.hT="13"},W.lang.extend(tt.asn1.DERPrintableString,tt.asn1.DERAbstractString),tt.asn1.DERTeletexString=function(t){tt.asn1.DERTeletexString.superclass.constructor.call(this,t),this.hT="14"},W.lang.extend(tt.asn1.DERTeletexString,tt.asn1.DERAbstractString),tt.asn1.DERIA5String=function(t){tt.asn1.DERIA5String.superclass.constructor.call(this,t),this.hT="16"},W.lang.extend(tt.asn1.DERIA5String,tt.asn1.DERAbstractString),tt.asn1.DERUTCTime=function(t){tt.asn1.DERUTCTime.superclass.constructor.call(this,t),this.hT="17",this.setByDate=function(t){this.hTLV=null,this.isModified=!0,this.date=t,this.s=this.formatDate(this.date,"utc"),this.hV=stohex(this.s)},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,"utc"),this.hV=stohex(this.s)),this.hV},void 0!==t&&(void 0!==t.str?this.setString(t.str):"string"==typeof t&&t.match(/^[0-9]{12}Z$/)?this.setString(t):void 0!==t.hex?this.setStringHex(t.hex):void 0!==t.date&&this.setByDate(t.date))},W.lang.extend(tt.asn1.DERUTCTime,tt.asn1.DERAbstractTime),tt.asn1.DERGeneralizedTime=function(t){tt.asn1.DERGeneralizedTime.superclass.constructor.call(this,t),this.hT="18",this.withMillis=!1,this.setByDate=function(t){this.hTLV=null,this.isModified=!0,this.date=t,this.s=this.formatDate(this.date,"gen",this.withMillis),this.hV=stohex(this.s)},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,"gen",this.withMillis),this.hV=stohex(this.s)),this.hV},void 0!==t&&(void 0!==t.str?this.setString(t.str):"string"==typeof t&&t.match(/^[0-9]{14}Z$/)?this.setString(t):void 0!==t.hex?this.setStringHex(t.hex):void 0!==t.date&&this.setByDate(t.date),!0===t.millis&&(this.withMillis=!0))},W.lang.extend(tt.asn1.DERGeneralizedTime,tt.asn1.DERAbstractTime),tt.asn1.DERSequence=function(t){tt.asn1.DERSequence.superclass.constructor.call(this,t),this.hT="30",this.getFreshValueHex=function(){for(var t="",e=0;e<this.asn1Array.length;e++){t+=this.asn1Array[e].getEncodedHex()}return this.hV=t,this.hV}},W.lang.extend(tt.asn1.DERSequence,tt.asn1.DERAbstractStructured),tt.asn1.DERSet=function(t){tt.asn1.DERSet.superclass.constructor.call(this,t),this.hT="31",this.sortFlag=!0,this.getFreshValueHex=function(){for(var t=new Array,e=0;e<this.asn1Array.length;e++){var i=this.asn1Array[e];t.push(i.getEncodedHex())}return 1==this.sortFlag&&t.sort(),this.hV=t.join(""),this.hV},void 0!==t&&void 0!==t.sortflag&&0==t.sortflag&&(this.sortFlag=!1)},W.lang.extend(tt.asn1.DERSet,tt.asn1.DERAbstractStructured),tt.asn1.DERTaggedObject=function(t){tt.asn1.DERTaggedObject.superclass.constructor.call(this),this.hT="a0",this.hV="",this.isExplicit=!0,this.asn1Object=null,this.setASN1Object=function(t,e,i){this.hT=e,this.isExplicit=t,this.asn1Object=i,this.isExplicit?(this.hV=this.asn1Object.getEncodedHex(),this.hTLV=null,this.isModified=!0):(this.hV=null,this.hTLV=i.getEncodedHex(),this.hTLV=this.hTLV.replace(/^../,e),this.isModified=!1)},this.getFreshValueHex=function(){return this.hV},void 0!==t&&(void 0!==t.tag&&(this.hT=t.tag),void 0!==t.explicit&&(this.isExplicit=t.explicit),void 0!==t.obj&&(this.asn1Object=t.obj,this.setASN1Object(this.isExplicit,this.hT,this.asn1Object)))},W.lang.extend(tt.asn1.DERTaggedObject,tt.asn1.ASN1Object);var et=function(t){function e(i){var r=t.call(this)||this;return i&&("string"==typeof i?r.parseKey(i):(e.hasPrivateKeyProperty(i)||e.hasPublicKeyProperty(i))&&r.parsePropertiesFrom(i)),r}return function(t,e){function i(){this.constructor=t}p(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),e.prototype.parseKey=function(t){try{var e=0,i=0,r=/^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/.test(t)?d(t):v.unarmor(t),n=x.decode(r);if(3===n.sub.length&&(n=n.sub[2].sub[0]),9===n.sub.length){e=n.sub[1].getHexStringValue(),this.n=q(e,16),i=n.sub[2].getHexStringValue(),this.e=parseInt(i,16);var s=n.sub[3].getHexStringValue();this.d=q(s,16);var o=n.sub[4].getHexStringValue();this.p=q(o,16);var h=n.sub[5].getHexStringValue();this.q=q(h,16);var a=n.sub[6].getHexStringValue();this.dmp1=q(a,16);var u=n.sub[7].getHexStringValue();this.dmq1=q(u,16);var c=n.sub[8].getHexStringValue();this.coeff=q(c,16)}else{if(2!==n.sub.length)return!1;var f=n.sub[1].sub[0];e=f.sub[0].getHexStringValue(),this.n=q(e,16),i=f.sub[1].getHexStringValue(),this.e=parseInt(i,16)}return!0}catch(t){return!1}},e.prototype.getPrivateBaseKey=function(){var t={array:[new tt.asn1.DERInteger({int:0}),new tt.asn1.DERInteger({bigint:this.n}),new tt.asn1.DERInteger({int:this.e}),new tt.asn1.DERInteger({bigint:this.d}),new tt.asn1.DERInteger({bigint:this.p}),new tt.asn1.DERInteger({bigint:this.q}),new tt.asn1.DERInteger({bigint:this.dmp1}),new tt.asn1.DERInteger({bigint:this.dmq1}),new tt.asn1.DERInteger({bigint:this.coeff})]};return new tt.asn1.DERSequence(t).getEncodedHex()},e.prototype.getPrivateBaseKeyB64=function(){return f(this.getPrivateBaseKey())},e.prototype.getPublicBaseKey=function(){var t=new tt.asn1.DERSequence({array:[new tt.asn1.DERObjectIdentifier({oid:"1.2.840.113549.1.1.1"}),new tt.asn1.DERNull]}),e=new tt.asn1.DERSequence({array:[new tt.asn1.DERInteger({bigint:this.n}),new tt.asn1.DERInteger({int:this.e})]}),i=new tt.asn1.DERBitString({hex:"00"+e.getEncodedHex()});return new tt.asn1.DERSequence({array:[t,i]}).getEncodedHex()},e.prototype.getPublicBaseKeyB64=function(){return f(this.getPublicBaseKey())},e.wordwrap=function(t,e){if(!t)return t;var i="(.{1,"+(e=e||64)+"})( +|$\n?)|(.{1,"+e+"})";return t.match(RegExp(i,"g")).join("\n")},e.prototype.getPrivateKey=function(){var t="-----BEGIN RSA PRIVATE KEY-----\n";return t+=e.wordwrap(this.getPrivateBaseKeyB64())+"\n",t+="-----END RSA PRIVATE KEY-----"},e.prototype.getPublicKey=function(){var t="-----BEGIN PUBLIC KEY-----\n";return t+=e.wordwrap(this.getPublicBaseKeyB64())+"\n",t+="-----END PUBLIC KEY-----"},e.hasPublicKeyProperty=function(t){return(t=t||{}).hasOwnProperty("n")&&t.hasOwnProperty("e")},e.hasPrivateKeyProperty=function(t){return(t=t||{}).hasOwnProperty("n")&&t.hasOwnProperty("e")&&t.hasOwnProperty("d")&&t.hasOwnProperty("p")&&t.hasOwnProperty("q")&&t.hasOwnProperty("dmp1")&&t.hasOwnProperty("dmq1")&&t.hasOwnProperty("coeff")},e.prototype.parsePropertiesFrom=function(t){this.n=t.n,this.e=t.e,t.hasOwnProperty("d")&&(this.d=t.d,this.p=t.p,this.q=t.q,this.dmp1=t.dmp1,this.dmq1=t.dmq1,this.coeff=t.coeff)},e}(Q),it=function(){function t(t){t=t||{},this.default_key_size=parseInt(t.default_key_size,10)||1024,this.default_public_exponent=t.default_public_exponent||"010001",this.log=t.log||!1,this.key=null}return t.prototype.setKey=function(t){this.log&&this.key&&console.warn("A key was already set, overriding existing."),this.key=new et(t)},t.prototype.setPrivateKey=function(t){this.setKey(t)},t.prototype.setPublicKey=function(t){this.setKey(t)},t.prototype.decrypt=function(t){try{return this.getKey().decrypt(function(t){var e,r="",n=0,s=0;for(e=0;e<t.length&&t.charAt(e)!=c;++e){var o=u.indexOf(t.charAt(e));o<0||(0==n?(r+=i(o>>2),s=3&o,n=1):1==n?(r+=i(s<<2|o>>4),s=15&o,n=2):2==n?(r+=i(s),r+=i(o>>2),s=3&o,n=3):(r+=i(s<<2|o>>4),r+=i(15&o),n=0))}return 1==n&&(r+=i(s<<2)),r}(t))}catch(t){return!1}},t.prototype.encrypt=function(t){try{return f(this.getKey().encrypt(t))}catch(t){return!1}},t.prototype.getKey=function(t){if(!this.key){if(this.key=new et,t&&"[object Function]"==={}.toString.call(t))return void this.key.generateAsync(this.default_key_size,this.default_public_exponent,t);this.key.generate(this.default_key_size,this.default_public_exponent)}return this.key},t.prototype.getPrivateKey=function(){return this.getKey().getPrivateKey()},t.prototype.getPrivateKeyB64=function(){return this.getKey().getPrivateBaseKeyB64()},t.prototype.getPublicKey=function(){return this.getKey().getPublicKey()},t.prototype.getPublicKeyB64=function(){return this.getKey().getPublicBaseKeyB64()},t.version="3.0.0-beta.1",t}();window.JSEncrypt=it,t.JSEncrypt=it,t.default=it,Object.defineProperty(t,"__esModule",{value:!0})});
(function(w,p){"object"===typeof exports?p(exports):"function"===typeof define&&define.amd?define(["exports"],p):p(w)})(this,function(w){function p(a){this._targetElement=a;this._options={nextLabel:"Next &rarr;",prevLabel:"&larr; Back",skipLabel:"Skip",doneLabel:"Done",tooltipPosition:"bottom",tooltipClass:"",highlightClass:"",exitOnEsc:!0,exitOnOverlayClick:!0,showStepNumbers:!0,keyboardNavigation:!0,showButtons:!0,showBullets:!0,showProgress:!1,scrollToElement:!0,overlayOpacity:0.8,positionPrecedence:["bottom",
"top","right","left"],disableInteraction:!1}}function J(a){var b=[],c=this;if(this._options.steps)for(var d=[],e=0,d=this._options.steps.length;e<d;e++){var f=A(this._options.steps[e]);f.step=b.length+1;"string"===typeof f.element&&(f.element=document.querySelector(f.element));if("undefined"===typeof f.element||null==f.element){var h=document.querySelector(".introjsFloatingElement");null==h&&(h=document.createElement("div"),h.className="introjsFloatingElement",document.body.appendChild(h));f.element=
h;f.position="floating"}null!=f.element&&b.push(f)}else{d=a.querySelectorAll("*[data-intro]");if(1>d.length)return!1;e=0;for(f=d.length;e<f;e++){var h=d[e],k=parseInt(h.getAttribute("data-step"),10);0<k&&(b[k-1]={element:h,intro:h.getAttribute("data-intro"),step:parseInt(h.getAttribute("data-step"),10),tooltipClass:h.getAttribute("data-tooltipClass"),highlightClass:h.getAttribute("data-highlightClass"),position:h.getAttribute("data-position")||this._options.tooltipPosition})}e=k=0;for(f=d.length;e<
f;e++)if(h=d[e],null==h.getAttribute("data-step")){for(;"undefined"!=typeof b[k];)k++;b[k]={element:h,intro:h.getAttribute("data-intro"),step:k+1,tooltipClass:h.getAttribute("data-tooltipClass"),highlightClass:h.getAttribute("data-highlightClass"),position:h.getAttribute("data-position")||this._options.tooltipPosition}}}e=[];for(d=0;d<b.length;d++)b[d]&&e.push(b[d]);b=e;b.sort(function(a,b){return a.step-b.step});c._introItems=b;K.call(c,a)&&(x.call(c),a.querySelector(".introjs-skipbutton"),a.querySelector(".introjs-nextbutton"),
c._onKeyDown=function(b){if(27===b.keyCode&&!0==c._options.exitOnEsc)y.call(c,a),void 0!=c._introExitCallback&&c._introExitCallback.call(c);else if(37===b.keyCode)C.call(c);else if(39===b.keyCode)x.call(c);else if(13===b.keyCode){var d=b.target||b.srcElement;d&&0<d.className.indexOf("introjs-prevbutton")?C.call(c):d&&0<d.className.indexOf("introjs-skipbutton")?y.call(c,a):x.call(c);b.preventDefault?b.preventDefault():b.returnValue=!1}},c._onResize=function(a){t.call(c,document.querySelector(".introjs-helperLayer"));
t.call(c,document.querySelector(".introjs-tooltipReferenceLayer"))},window.addEventListener?(this._options.keyboardNavigation&&window.addEventListener("keydown",c._onKeyDown,!0),window.addEventListener("resize",c._onResize,!0)):document.attachEvent&&(this._options.keyboardNavigation&&document.attachEvent("onkeydown",c._onKeyDown),document.attachEvent("onresize",c._onResize)));return!1}function A(a){if(null==a||"object"!=typeof a||"undefined"!=typeof a.nodeType)return a;var b={},c;for(c in a)b[c]=
A(a[c]);return b}function x(){this._direction="forward";"undefined"===typeof this._currentStep?this._currentStep=0:++this._currentStep;if(this._introItems.length<=this._currentStep)"function"===typeof this._introCompleteCallback&&this._introCompleteCallback.call(this),y.call(this,this._targetElement);else{var a=this._introItems[this._currentStep];"undefined"!==typeof this._introBeforeChangeCallback&&this._introBeforeChangeCallback.call(this,a.element);G.call(this,a)}}function C(){this._direction=
"backward";if(0===this._currentStep)return!1;var a=this._introItems[--this._currentStep];"undefined"!==typeof this._introBeforeChangeCallback&&this._introBeforeChangeCallback.call(this,a.element);G.call(this,a)}function y(a){var b=a.querySelector(".introjs-overlay");if(null!=b){b.style.opacity=0;setTimeout(function(){b.parentNode&&b.parentNode.removeChild(b)},500);var c=a.querySelector(".introjs-helperLayer");c&&c.parentNode.removeChild(c);(c=a.querySelector(".introjs-tooltipReferenceLayer"))&&c.parentNode.removeChild(c);
(a=a.querySelector(".introjs-disableInteraction"))&&a.parentNode.removeChild(a);(a=document.querySelector(".introjsFloatingElement"))&&a.parentNode.removeChild(a);if(a=document.querySelector(".introjs-showElement"))a.className=a.className.replace(/introjs-[a-zA-Z]+/g,"").replace(/^\s+|\s+$/g,"");if((a=document.querySelectorAll(".introjs-fixParent"))&&0<a.length)for(c=a.length-1;0<=c;c--)a[c].className=a[c].className.replace(/introjs-fixParent/g,"").replace(/^\s+|\s+$/g,"");window.removeEventListener?
window.removeEventListener("keydown",this._onKeyDown,!0):document.detachEvent&&document.detachEvent("onkeydown",this._onKeyDown);this._currentStep=void 0}}function H(a,b,c,d){var e="";b.style.top=null;b.style.right=null;b.style.bottom=null;b.style.left=null;b.style.marginLeft=null;b.style.marginTop=null;c.style.display="inherit";"undefined"!=typeof d&&null!=d&&(d.style.top=null,d.style.left=null);if(this._introItems[this._currentStep]){e=this._introItems[this._currentStep];e="string"===typeof e.tooltipClass?
e.tooltipClass:this._options.tooltipClass;b.className=("introjs-tooltip "+e).replace(/^\s+|\s+$/g,"");currentTooltipPosition=this._introItems[this._currentStep].position;if(("auto"==currentTooltipPosition||"auto"==this._options.tooltipPosition)&&"floating"!=currentTooltipPosition){var e=currentTooltipPosition,f=this._options.positionPrecedence.slice(),h=F(),p=k(b).height+10,s=k(b).width+20,l=k(a),m="floating";l.left+s>h.width||0>l.left+l.width/2-s?(q(f,"bottom"),q(f,"top")):(l.height+l.top+p>h.height&&
q(f,"bottom"),0>l.top-p&&q(f,"top"));l.width+l.left+s>h.width&&q(f,"right");0>l.left-s&&q(f,"left");0<f.length&&(m=f[0]);e&&"auto"!=e&&-1<f.indexOf(e)&&(m=e);currentTooltipPosition=m}e=k(a);f=k(b).height;h=F();switch(currentTooltipPosition){case "top":b.style.left="15px";b.style.top="-"+(f+10)+"px";c.className="introjs-arrow bottom";break;case "right":b.style.left=k(a).width+20+"px";e.top+f>h.height&&(c.className="introjs-arrow left-bottom",b.style.top="-"+(f-e.height-20)+"px");c.className="introjs-arrow left";
break;case "left":!0==this._options.showStepNumbers&&(b.style.top="15px");e.top+f>h.height?(b.style.top="-"+(f-e.height-20)+"px",c.className="introjs-arrow right-bottom"):c.className="introjs-arrow right";b.style.right=e.width+20+"px";break;case "floating":c.style.display="none";a=k(b);b.style.left="50%";b.style.top="50%";b.style.marginLeft="-"+a.width/2+"px";b.style.marginTop="-"+a.height/2+"px";"undefined"!=typeof d&&null!=d&&(d.style.left="-"+(a.width/2+18)+"px",d.style.top="-"+(a.height/2+18)+
"px");break;case "bottom-right-aligned":c.className="introjs-arrow top-right";b.style.right="0px";b.style.bottom="-"+(k(b).height+10)+"px";break;case "bottom-middle-aligned":d=k(a);a=k(b);c.className="introjs-arrow top-middle";b.style.left=d.width/2-a.width/2+"px";b.style.bottom="-"+(a.height+10)+"px";break;default:b.style.bottom="-"+(k(b).height+10)+"px",b.style.left=k(a).width/2-k(b).width/2+"px",c.className="introjs-arrow top"}}}function q(a,b){-1<a.indexOf(b)&&a.splice(a.indexOf(b),1)}function t(a){if(a&&
this._introItems[this._currentStep]){var b=this._introItems[this._currentStep],c=k(b.element),d=10;"floating"==b.position&&(d=0);a.setAttribute("style","width: "+(c.width+d)+"px; height:"+(c.height+d)+"px; top:"+(c.top-5)+"px;left: "+(c.left-5)+"px;")}}function L(){var a=document.querySelector(".introjs-disableInteraction");null===a&&(a=document.createElement("div"),a.className="introjs-disableInteraction",this._targetElement.appendChild(a));t.call(this,a)}function G(a){"undefined"!==typeof this._introChangeCallback&&
this._introChangeCallback.call(this,a.element);var b=this,c=document.querySelector(".introjs-helperLayer"),d=document.querySelector(".introjs-tooltipReferenceLayer"),e="introjs-helperLayer";k(a.element);"string"===typeof a.highlightClass&&(e+=" "+a.highlightClass);"string"===typeof this._options.highlightClass&&(e+=" "+this._options.highlightClass);if(null!=c){var f=d.querySelector(".introjs-helperNumberLayer"),h=d.querySelector(".introjs-tooltiptext"),p=d.querySelector(".introjs-arrow"),s=d.querySelector(".introjs-tooltip"),
l=d.querySelector(".introjs-skipbutton"),m=d.querySelector(".introjs-prevbutton"),r=d.querySelector(".introjs-nextbutton");c.className=e;s.style.opacity=0;s.style.display="none";if(null!=f){var g=this._introItems[0<=a.step-2?a.step-2:0];if(null!=g&&"forward"==this._direction&&"floating"==g.position||"backward"==this._direction&&"floating"==a.position)f.style.opacity=0}t.call(b,c);t.call(b,d);if((g=document.querySelectorAll(".introjs-fixParent"))&&0<g.length)for(e=g.length-1;0<=e;e--)g[e].className=
g[e].className.replace(/introjs-fixParent/g,"").replace(/^\s+|\s+$/g,"");g=document.querySelector(".introjs-showElement");g.className=g.className.replace(/introjs-[a-zA-Z]+/g,"").replace(/^\s+|\s+$/g,"");b._lastShowElementTimer&&clearTimeout(b._lastShowElementTimer);b._lastShowElementTimer=setTimeout(function(){null!=f&&(f.innerHTML=a.step);h.innerHTML=a.intro;s.style.display="block";H.call(b,a.element,s,p,f);d.querySelector(".introjs-bullets li > a.active").className="";d.querySelector('.introjs-bullets li > a[data-stepnumber="'+
a.step+'"]').className="active";d.querySelector(".introjs-progress .introjs-progressbar").setAttribute("style","width:"+I.call(b)+"%;");s.style.opacity=1;f&&(f.style.opacity=1);-1===r.tabIndex?l.focus():r.focus()},350)}else{var q=document.createElement("div"),m=document.createElement("div"),c=document.createElement("div"),n=document.createElement("div"),w=document.createElement("div"),D=document.createElement("div"),E=document.createElement("div"),u=document.createElement("div");q.className=e;m.className=
"introjs-tooltipReferenceLayer";t.call(b,q);t.call(b,m);this._targetElement.appendChild(q);this._targetElement.appendChild(m);c.className="introjs-arrow";w.className="introjs-tooltiptext";w.innerHTML=a.intro;D.className="introjs-bullets";!1===this._options.showBullets&&(D.style.display="none");for(var q=document.createElement("ul"),e=0,B=this._introItems.length;e<B;e++){var A=document.createElement("li"),z=document.createElement("a");z.onclick=function(){b.goToStep(this.getAttribute("data-stepnumber"))};
e===a.step-1&&(z.className="active");z.href="javascript:void(0);";z.innerHTML="&nbsp;";z.setAttribute("data-stepnumber",this._introItems[e].step);A.appendChild(z);q.appendChild(A)}D.appendChild(q);E.className="introjs-progress";!1===this._options.showProgress&&(E.style.display="none");e=document.createElement("div");e.className="introjs-progressbar";e.setAttribute("style","width:"+I.call(this)+"%;");E.appendChild(e);u.className="introjs-tooltipbuttons";!1===this._options.showButtons&&(u.style.display=
"none");n.className="introjs-tooltip";n.appendChild(w);n.appendChild(D);n.appendChild(E);!0==this._options.showStepNumbers&&(g=document.createElement("span"),g.className="introjs-helperNumberLayer",g.innerHTML=a.step,m.appendChild(g));n.appendChild(c);m.appendChild(n);r=document.createElement("a");r.onclick=function(){b._introItems.length-1!=b._currentStep&&x.call(b)};r.href="javascript:void(0);";r.innerHTML=this._options.nextLabel;m=document.createElement("a");m.onclick=function(){0!=b._currentStep&&
C.call(b)};m.href="javascript:void(0);";m.innerHTML=this._options.prevLabel;l=document.createElement("a");l.className="introjs-button introjs-skipbutton";l.href="javascript:void(0);";l.innerHTML=this._options.skipLabel;l.onclick=function(){b._introItems.length-1==b._currentStep&&"function"===typeof b._introCompleteCallback&&b._introCompleteCallback.call(b);b._introItems.length-1!=b._currentStep&&"function"===typeof b._introExitCallback&&b._introExitCallback.call(b);y.call(b,b._targetElement)};u.appendChild(l);
1<this._introItems.length&&(u.appendChild(m),u.appendChild(r));n.appendChild(u);H.call(b,a.element,n,c,g)}!0===this._options.disableInteraction&&L.call(b);m.removeAttribute("tabIndex");r.removeAttribute("tabIndex");0==this._currentStep&&1<this._introItems.length?(m.className="introjs-button introjs-prevbutton introjs-disabled",m.tabIndex="-1",r.className="introjs-button introjs-nextbutton",l.innerHTML=this._options.skipLabel):this._introItems.length-1==this._currentStep||1==this._introItems.length?
(l.innerHTML=this._options.doneLabel,m.className="introjs-button introjs-prevbutton",r.className="introjs-button introjs-nextbutton introjs-disabled",r.tabIndex="-1"):(m.className="introjs-button introjs-prevbutton",r.className="introjs-button introjs-nextbutton",l.innerHTML=this._options.skipLabel);r.focus();a.element.className+=" introjs-showElement";g=v(a.element,"position");"absolute"!==g&&"relative"!==g&&(a.element.className+=" introjs-relativePosition");for(g=a.element.parentNode;null!=g&&"body"!==
g.tagName.toLowerCase();){c=v(g,"z-index");n=parseFloat(v(g,"opacity"));u=v(g,"transform")||v(g,"-webkit-transform")||v(g,"-moz-transform")||v(g,"-ms-transform")||v(g,"-o-transform");if(/[0-9]+/.test(c)||1>n||"none"!==u)g.className+=" introjs-fixParent";g=g.parentNode}M(a.element)||!0!==this._options.scrollToElement||(n=a.element.getBoundingClientRect(),g=F().height,c=n.bottom-(n.bottom-n.top),n=n.bottom-g,0>c||a.element.clientHeight>g?window.scrollBy(0,c-30):window.scrollBy(0,n+100));"undefined"!==
typeof this._introAfterChangeCallback&&this._introAfterChangeCallback.call(this,a.element)}function v(a,b){var c="";a.currentStyle?c=a.currentStyle[b]:document.defaultView&&document.defaultView.getComputedStyle&&(c=document.defaultView.getComputedStyle(a,null).getPropertyValue(b));return c&&c.toLowerCase?c.toLowerCase():c}function F(){if(void 0!=window.innerWidth)return{width:window.innerWidth,height:window.innerHeight};var a=document.documentElement;return{width:a.clientWidth,height:a.clientHeight}}
function M(a){a=a.getBoundingClientRect();return 0<=a.top&&0<=a.left&&a.bottom+80<=window.innerHeight&&a.right<=window.innerWidth}function K(a){var b=document.createElement("div"),c="",d=this;b.className="introjs-overlay";if("body"===a.tagName.toLowerCase())c+="top: 0;bottom: 0; left: 0;right: 0;position: fixed;",b.setAttribute("style",c);else{var e=k(a);e&&(c+="width: "+e.width+"px; height:"+e.height+"px; top:"+e.top+"px;left: "+e.left+"px;",b.setAttribute("style",c))}a.appendChild(b);b.onclick=
function(){!0==d._options.exitOnOverlayClick&&(y.call(d,a),void 0!=d._introExitCallback&&d._introExitCallback.call(d))};setTimeout(function(){c+="opacity: "+d._options.overlayOpacity.toString()+";";b.setAttribute("style",c)},10);return!0}function k(a){var b={};b.width=a.offsetWidth;b.height=a.offsetHeight;for(var c=0,d=0;a&&!isNaN(a.offsetLeft)&&!isNaN(a.offsetTop);)c+=a.offsetLeft,d+=a.offsetTop,a=a.offsetParent;b.top=d;b.left=c;return b}function I(){return 100*(parseInt(this._currentStep+1,10)/
this._introItems.length)}var B=function(a){if("object"===typeof a)return new p(a);if("string"===typeof a){if(a=document.querySelector(a))return new p(a);throw Error("There is no element with given selector.");}return new p(document.body)};B.version="1.0.0";B.fn=p.prototype={clone:function(){return new p(this)},setOption:function(a,b){this._options[a]=b;return this},setOptions:function(a){var b=this._options,c={},d;for(d in b)c[d]=b[d];for(d in a)c[d]=a[d];this._options=c;return this},start:function(){J.call(this,
this._targetElement);return this},goToStep:function(a){this._currentStep=a-2;"undefined"!==typeof this._introItems&&x.call(this);return this},nextStep:function(){x.call(this);return this},previousStep:function(){C.call(this);return this},exit:function(){y.call(this,this._targetElement);return this},refresh:function(){t.call(this,document.querySelector(".introjs-helperLayer"));t.call(this,document.querySelector(".introjs-tooltipReferenceLayer"));return this},onbeforechange:function(a){if("function"===
typeof a)this._introBeforeChangeCallback=a;else throw Error("Provided callback for onbeforechange was not a function");return this},onchange:function(a){if("function"===typeof a)this._introChangeCallback=a;else throw Error("Provided callback for onchange was not a function.");return this},onafterchange:function(a){if("function"===typeof a)this._introAfterChangeCallback=a;else throw Error("Provided callback for onafterchange was not a function");return this},oncomplete:function(a){if("function"===
typeof a)this._introCompleteCallback=a;else throw Error("Provided callback for oncomplete was not a function.");return this},onexit:function(a){if("function"===typeof a)this._introExitCallback=a;else throw Error("Provided callback for onexit was not a function.");return this}};return w.introJs=B});

/**
 * BxSlider v4.1.2 - Fully loaded, responsive content slider
 * http://bxslider.com
 *
 * Copyright 2014, Steven Wanderski - http://stevenwanderski.com - http://bxcreative.com
 * Written while drinking Belgian ales and listening to jazz
 *
 * Released under the MIT license - http://opensource.org/licenses/MIT
 */

;(function($){

	var plugin = {};

	var defaults = {

		// GENERAL
		mode: 'horizontal',
		slideSelector: '',
		infiniteLoop: true,
		hideControlOnEnd: false,
		speed: 500,
		easing: null,
		slideMargin: 0,
		startSlide: 0,
		randomStart: false,
		captions: false,
		ticker: false,
		tickerHover: false,
		adaptiveHeight: false,
		adaptiveHeightSpeed: 500,
		video: false,
		useCSS: true,
		preloadImages: 'visible',
		responsive: true,
		slideZIndex: 50,
		wrapperClass: 'bx-wrapper',

		// TOUCH
		touchEnabled: true,
		swipeThreshold: 50,
		oneToOneTouch: true,
		preventDefaultSwipeX: true,
		preventDefaultSwipeY: false,

		// PAGER
		pager: true,
		pagerType: 'full',
		pagerShortSeparator: ' / ',
		pagerSelector: null,
		buildPager: null,
		pagerCustom: null,

		// CONTROLS
		controls: true,
		nextText: 'Next',
		prevText: 'Prev',
		nextSelector: null,
		prevSelector: null,
		autoControls: false,
		startText: 'Start',
		stopText: 'Stop',
		autoControlsCombine: false,
		autoControlsSelector: null,

		// AUTO
		auto: false,
		pause: 4000,
		autoStart: true,
		autoDirection: 'next',
		autoHover: false,
		autoDelay: 0,
		autoSlideForOnePage: false,

		// CAROUSEL
		minSlides: 1,
		maxSlides: 1,
		moveSlides: 0,
		slideWidth: 0,

		// CALLBACKS
		onSliderLoad: function() {},
		onSlideBefore: function() {},
		onSlideAfter: function() {},
		onSlideNext: function() {},
		onSlidePrev: function() {},
		onSliderResize: function() {}
	}

	$.fn.bxSlider = function(options){

		if(this.length == 0) return this;

		// support mutltiple elements
		if(this.length > 1){
			this.each(function(){$(this).bxSlider(options)});
			return this;
		}

		// create a namespace to be used throughout the plugin
		var slider = {};
		// set a reference to our slider element
		var el = this;
		plugin.el = this;

		/**
		 * Makes slideshow responsive
		 */
		// first get the original window dimens (thanks alot IE)
		var windowWidth = $(window).width();
		var windowHeight = $(window).height();



		/**
		 * ===================================================================================
		 * = PRIVATE FUNCTIONS
		 * ===================================================================================
		 */

		/**
		 * Initializes namespace settings to be used throughout plugin
		 */
		var init = function(){
			// merge user-supplied options with the defaults
			slider.settings = $.extend({}, defaults, options);
			// parse slideWidth setting
			slider.settings.slideWidth = parseInt(slider.settings.slideWidth);
			// store the original children
			slider.children = el.children(slider.settings.slideSelector);
			// check if actual number of slides is less than minSlides / maxSlides
			if(slider.children.length < slider.settings.minSlides) slider.settings.minSlides = slider.children.length;
			if(slider.children.length < slider.settings.maxSlides) slider.settings.maxSlides = slider.children.length;
			// if random start, set the startSlide setting to random number
			if(slider.settings.randomStart) slider.settings.startSlide = Math.floor(Math.random() * slider.children.length);
			// store active slide information
			slider.active = { index: slider.settings.startSlide }
			// store if the slider is in carousel mode (displaying / moving multiple slides)
			slider.carousel = slider.settings.minSlides > 1 || slider.settings.maxSlides > 1;
			// if carousel, force preloadImages = 'all'
			if(slider.carousel) slider.settings.preloadImages = 'all';
			// calculate the min / max width thresholds based on min / max number of slides
			// used to setup and update carousel slides dimensions
			slider.minThreshold = (slider.settings.minSlides * slider.settings.slideWidth) + ((slider.settings.minSlides - 1) * slider.settings.slideMargin);
			slider.maxThreshold = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);
			// store the current state of the slider (if currently animating, working is true)
			slider.working = false;
			// initialize the controls object
			slider.controls = {};
			// initialize an auto interval
			slider.interval = null;
			// determine which property to use for transitions
			slider.animProp = slider.settings.mode == 'vertical' ? 'top' : 'left';
			// determine if hardware acceleration can be used
			slider.usingCSS = slider.settings.useCSS && slider.settings.mode != 'fade' && (function(){
				// create our test div element
				var div = document.createElement('div');
				// css transition properties
				var props = ['WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
				// test for each property
				for(var i in props){
					if(div.style[props[i]] !== undefined){
						slider.cssPrefix = props[i].replace('Perspective', '').toLowerCase();
						slider.animProp = '-' + slider.cssPrefix + '-transform';
						return true;
					}
				}
				return false;
			}());
			// if vertical mode always make maxSlides and minSlides equal
			if(slider.settings.mode == 'vertical') slider.settings.maxSlides = slider.settings.minSlides;
			// save original style data
			el.data("origStyle", el.attr("style"));
			el.children(slider.settings.slideSelector).each(function() {
			  $(this).data("origStyle", $(this).attr("style"));
			});
			// perform all DOM / CSS modifications
			setup();
		}

		/**
		 * Performs all DOM and CSS modifications
		 */
		var setup = function(){
			// wrap el in a wrapper
			el.wrap('<div class="' + slider.settings.wrapperClass + '"><div class="bx-viewport"></div></div>');
			// store a namspace reference to .bx-viewport
			slider.viewport = el.parent();
			// add a loading div to display while images are loading
			slider.loader = $('<div class="bx-loading" />');
			slider.viewport.prepend(slider.loader);
			// set el to a massive width, to hold any needed slides
			// also strip any margin and padding from el
			el.css({
				width: slider.settings.mode == 'horizontal' ? (slider.children.length * 100 + 215) + '%' : 'auto',
				position: 'relative'
			});
			// if using CSS, add the easing property
			if(slider.usingCSS && slider.settings.easing){
				el.css('-' + slider.cssPrefix + '-transition-timing-function', slider.settings.easing);
			// if not using CSS and no easing value was supplied, use the default JS animation easing (swing)
			}else if(!slider.settings.easing){
				slider.settings.easing = 'swing';
			}
			var slidesShowing = getNumberSlidesShowing();
			// make modifications to the viewport (.bx-viewport)
			slider.viewport.css({
				width: '100%',
				overflow: 'hidden',
				position: 'relative'
			});
			slider.viewport.parent().css({
				maxWidth: getViewportMaxWidth()
			});
			// make modification to the wrapper (.bx-wrapper)
			if(!slider.settings.pager) {
				slider.viewport.parent().css({
				margin: '0 auto 0px'
				});
			}
			// apply css to all slider children
			slider.children.css({
				'float': slider.settings.mode == 'horizontal' ? 'left' : 'none',
				listStyle: 'none',
				position: 'relative'
			});
			// apply the calculated width after the float is applied to prevent scrollbar interference
			slider.children.css('width', getSlideWidth());
			// if slideMargin is supplied, add the css
			if(slider.settings.mode == 'horizontal' && slider.settings.slideMargin > 0) slider.children.css('marginRight', slider.settings.slideMargin);
			if(slider.settings.mode == 'vertical' && slider.settings.slideMargin > 0) slider.children.css('marginBottom', slider.settings.slideMargin);
			// if "fade" mode, add positioning and z-index CSS
			if(slider.settings.mode == 'fade'){
				slider.children.css({
					position: 'absolute',
					zIndex: 0,
					display: 'none'
				});
				// prepare the z-index on the showing element
				slider.children.eq(slider.settings.startSlide).css({zIndex: slider.settings.slideZIndex, display: 'block'});
			}
			// create an element to contain all slider controls (pager, start / stop, etc)
			slider.controls.el = $('<div class="bx-controls" />');
			// if captions are requested, add them
			if(slider.settings.captions) appendCaptions();
			// check if startSlide is last slide
			slider.active.last = slider.settings.startSlide == getPagerQty() - 1;
			// if video is true, set up the fitVids plugin
			if(slider.settings.video) el.fitVids();
			// set the default preload selector (visible)
			var preloadSelector = slider.children.eq(slider.settings.startSlide);
			if (slider.settings.preloadImages == "all") preloadSelector = slider.children;
			// only check for control addition if not in "ticker" mode
			if(!slider.settings.ticker){
				// if pager is requested, add it
				if(slider.settings.pager) appendPager();
				// if controls are requested, add them
				if(slider.settings.controls) appendControls();
				// if auto is true, and auto controls are requested, add them
				if(slider.settings.auto && slider.settings.autoControls) appendControlsAuto();
				// if any control option is requested, add the controls wrapper
				if(slider.settings.controls || slider.settings.autoControls || slider.settings.pager) slider.viewport.after(slider.controls.el);
			// if ticker mode, do not allow a pager
			}else{
				slider.settings.pager = false;
			}
			// preload all images, then perform final DOM / CSS modifications that depend on images being loaded
			loadElements(preloadSelector, start);
		}

		var loadElements = function(selector, callback){
			var total = selector.find('img, iframe').length;
			if (total == 0){
				callback();
				return;
			}
			var count = 0;
			selector.find('img, iframe').each(function(){
				$(this).one('load', function() {
				  if(++count == total) callback();
				}).each(function() {
				  if(this.complete) $(this).load();
				});
			});
		}

		/**
		 * Start the slider
		 */
		var start = function(){
			// if infinite loop, prepare additional slides
			if(slider.settings.infiniteLoop && slider.settings.mode != 'fade' && !slider.settings.ticker){
				var slice = slider.settings.mode == 'vertical' ? slider.settings.minSlides : slider.settings.maxSlides;
				var sliceAppend = slider.children.slice(0, slice).clone().addClass('bx-clone');
				var slicePrepend = slider.children.slice(-slice).clone().addClass('bx-clone');
				el.append(sliceAppend).prepend(slicePrepend);
			}
			// remove the loading DOM element
			slider.loader.remove();
			// set the left / top position of "el"
			setSlidePosition();
			// if "vertical" mode, always use adaptiveHeight to prevent odd behavior
			if (slider.settings.mode == 'vertical') slider.settings.adaptiveHeight = true;
			// set the viewport height
			slider.viewport.height(getViewportHeight());
			// make sure everything is positioned just right (same as a window resize)
			el.redrawSlider();
			// onSliderLoad callback
			slider.settings.onSliderLoad(slider.active.index);
			// slider has been fully initialized
			slider.initialized = true;
			// bind the resize call to the window
			if (slider.settings.responsive) $(window).bind('resize', resizeWindow);
			// if auto is true and has more than 1 page, start the show
			if (slider.settings.auto && slider.settings.autoStart && (getPagerQty() > 1 || slider.settings.autoSlideForOnePage)) initAuto();
			// if ticker is true, start the ticker
			if (slider.settings.ticker) initTicker();
			// if pager is requested, make the appropriate pager link active
			if (slider.settings.pager) updatePagerActive(slider.settings.startSlide);
			// check for any updates to the controls (like hideControlOnEnd updates)
			if (slider.settings.controls) updateDirectionControls();
			// if touchEnabled is true, setup the touch events
			if (slider.settings.touchEnabled && !slider.settings.ticker) initTouch();
		}

		/**
		 * Returns the calculated height of the viewport, used to determine either adaptiveHeight or the maxHeight value
		 */
		var getViewportHeight = function(){
			var height = 0;
			// first determine which children (slides) should be used in our height calculation
			var children = $();
			// if mode is not "vertical" and adaptiveHeight is false, include all children
			if(slider.settings.mode != 'vertical' && !slider.settings.adaptiveHeight){
				children = slider.children;
			}else{
				// if not carousel, return the single active child
				if(!slider.carousel){
					children = slider.children.eq(slider.active.index);
				// if carousel, return a slice of children
				}else{
					// get the individual slide index
					var currentIndex = slider.settings.moveSlides == 1 ? slider.active.index : slider.active.index * getMoveBy();
					// add the current slide to the children
					children = slider.children.eq(currentIndex);
					// cycle through the remaining "showing" slides
					for (i = 1; i <= slider.settings.maxSlides - 1; i++){
						// if looped back to the start
						if(currentIndex + i >= slider.children.length){
							children = children.add(slider.children.eq(i - 1));
						}else{
							children = children.add(slider.children.eq(currentIndex + i));
						}
					}
				}
			}
			// if "vertical" mode, calculate the sum of the heights of the children
			if(slider.settings.mode == 'vertical'){
				children.each(function(index) {
				  height += $(this).outerHeight();
				});
				// add user-supplied margins
				if(slider.settings.slideMargin > 0){
					height += slider.settings.slideMargin * (slider.settings.minSlides - 1);
				}
			// if not "vertical" mode, calculate the max height of the children
			}else{
				height = Math.max.apply(Math, children.map(function(){
					return $(this).outerHeight(false);
				}).get());
			}

			if(slider.viewport.css('box-sizing') == 'border-box'){
				height +=	parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom')) +
							parseFloat(slider.viewport.css('border-top-width')) + parseFloat(slider.viewport.css('border-bottom-width'));
			}else if(slider.viewport.css('box-sizing') == 'padding-box'){
				height +=	parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom'));
			}

			return height;
		}

		/**
		 * Returns the calculated width to be used for the outer wrapper / viewport
		 */
		var getViewportMaxWidth = function(){
			var width = '100%';
			if(slider.settings.slideWidth > 0){
				if(slider.settings.mode == 'horizontal'){
					width = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);
				}else{
					width = slider.settings.slideWidth;
				}
			}
			return width;
		}

		/**
		 * Returns the calculated width to be applied to each slide
		 */
		var getSlideWidth = function(){
			// start with any user-supplied slide width
			var newElWidth = slider.settings.slideWidth;
			// get the current viewport width
			var wrapWidth = slider.viewport.width();
			// if slide width was not supplied, or is larger than the viewport use the viewport width
			if(slider.settings.slideWidth == 0 ||
				(slider.settings.slideWidth > wrapWidth && !slider.carousel) ||
				slider.settings.mode == 'vertical'){
				newElWidth = wrapWidth;
			// if carousel, use the thresholds to determine the width
			}else if(slider.settings.maxSlides > 1 && slider.settings.mode == 'horizontal'){
				if(wrapWidth > slider.maxThreshold){
					// newElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.maxSlides - 1))) / slider.settings.maxSlides;
				}else if(wrapWidth < slider.minThreshold){
					newElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.minSlides - 1))) / slider.settings.minSlides;
				}
			}
			return newElWidth;
		}

		/**
		 * Returns the number of slides currently visible in the viewport (includes partially visible slides)
		 */
		var getNumberSlidesShowing = function(){
			var slidesShowing = 1;
			if(slider.settings.mode == 'horizontal' && slider.settings.slideWidth > 0){
				// if viewport is smaller than minThreshold, return minSlides
				if(slider.viewport.width() < slider.minThreshold){
					slidesShowing = slider.settings.minSlides;
				// if viewport is larger than minThreshold, return maxSlides
				}else if(slider.viewport.width() > slider.maxThreshold){
					slidesShowing = slider.settings.maxSlides;
				// if viewport is between min / max thresholds, divide viewport width by first child width
				}else{
					var childWidth = slider.children.first().width() + slider.settings.slideMargin;
					slidesShowing = Math.floor((slider.viewport.width() +
						slider.settings.slideMargin) / childWidth);
				}
			// if "vertical" mode, slides showing will always be minSlides
			}else if(slider.settings.mode == 'vertical'){
				slidesShowing = slider.settings.minSlides;
			}
			return slidesShowing;
		}

		/**
		 * Returns the number of pages (one full viewport of slides is one "page")
		 */
		var getPagerQty = function(){
			var pagerQty = 0;
			// if moveSlides is specified by the user
			if(slider.settings.moveSlides > 0){
				if(slider.settings.infiniteLoop){
					pagerQty = Math.ceil(slider.children.length / getMoveBy());
				}else{
					// use a while loop to determine pages
					var breakPoint = 0;
					var counter = 0
					// when breakpoint goes above children length, counter is the number of pages
					while (breakPoint < slider.children.length){
						++pagerQty;
						breakPoint = counter + getNumberSlidesShowing();
						counter += slider.settings.moveSlides <= getNumberSlidesShowing() ? slider.settings.moveSlides : getNumberSlidesShowing();
					}
				}
			// if moveSlides is 0 (auto) divide children length by sides showing, then round up
			}else{
				pagerQty = Math.ceil(slider.children.length / getNumberSlidesShowing());
			}
			return pagerQty;
		}

		/**
		 * Returns the number of indivual slides by which to shift the slider
		 */
		var getMoveBy = function(){
			// if moveSlides was set by the user and moveSlides is less than number of slides showing
			if(slider.settings.moveSlides > 0 && slider.settings.moveSlides <= getNumberSlidesShowing()){
				return slider.settings.moveSlides;
			}
			// if moveSlides is 0 (auto)
			return getNumberSlidesShowing();
		}

		/**
		 * Sets the slider's (el) left or top position
		 */
		var setSlidePosition = function(){
			// if last slide, not infinite loop, and number of children is larger than specified maxSlides
			if(slider.children.length > slider.settings.maxSlides && slider.active.last && !slider.settings.infiniteLoop){
				if (slider.settings.mode == 'horizontal'){
					// get the last child's position
					var lastChild = slider.children.last();
					var position = lastChild.position();
					// set the left position
					setPositionProperty(-(position.left - (slider.viewport.width() - lastChild.outerWidth())), 'reset', 0);
				}else if(slider.settings.mode == 'vertical'){
					// get the last showing index's position
					var lastShowingIndex = slider.children.length - slider.settings.minSlides;
					var position = slider.children.eq(lastShowingIndex).position();
					// set the top position
					setPositionProperty(-position.top, 'reset', 0);
				}
			// if not last slide
			}else{
				// get the position of the first showing slide
				var position = slider.children.eq(slider.active.index * getMoveBy()).position();
				// check for last slide
				if (slider.active.index == getPagerQty() - 1) slider.active.last = true;
				// set the repective position
				if (position != undefined){
					if (slider.settings.mode == 'horizontal') setPositionProperty(-position.left, 'reset', 0);
					else if (slider.settings.mode == 'vertical') setPositionProperty(-position.top, 'reset', 0);
				}
			}
		}

		/**
		 * Sets the el's animating property position (which in turn will sometimes animate el).
		 * If using CSS, sets the transform property. If not using CSS, sets the top / left property.
		 *
		 * @param value (int)
		 *  - the animating property's value
		 *
		 * @param type (string) 'slider', 'reset', 'ticker'
		 *  - the type of instance for which the function is being
		 *
		 * @param duration (int)
		 *  - the amount of time (in ms) the transition should occupy
		 *
		 * @param params (array) optional
		 *  - an optional parameter containing any variables that need to be passed in
		 */
		var setPositionProperty = function(value, type, duration, params){
			// use CSS transform
			if(slider.usingCSS){
				// determine the translate3d value
				var propValue = slider.settings.mode == 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)';
				// add the CSS transition-duration
				el.css('-' + slider.cssPrefix + '-transition-duration', duration / 1000 + 's');
				if(type == 'slide'){
					// set the property value
					el.css(slider.animProp, propValue);
					// bind a callback method - executes when CSS transition completes
					el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(){
						// unbind the callback
						el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
						updateAfterSlideTransition();
					});
				}else if(type == 'reset'){
					el.css(slider.animProp, propValue);
				}else if(type == 'ticker'){
					// make the transition use 'linear'
					el.css('-' + slider.cssPrefix + '-transition-timing-function', 'linear');
					el.css(slider.animProp, propValue);
					// bind a callback method - executes when CSS transition completes
					el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(){
						// unbind the callback
						el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
						// reset the position
						setPositionProperty(params['resetValue'], 'reset', 0);
						// start the loop again
						tickerLoop();
					});
				}
			// use JS animate
			}else{
				var animateObj = {};
				animateObj[slider.animProp] = value;
				if(type == 'slide'){
					el.animate(animateObj, duration, slider.settings.easing, function(){
						updateAfterSlideTransition();
					});
				}else if(type == 'reset'){
					el.css(slider.animProp, value)
				}else if(type == 'ticker'){
					el.animate(animateObj, speed, 'linear', function(){
						setPositionProperty(params['resetValue'], 'reset', 0);
						// run the recursive loop after animation
						tickerLoop();
					});
				}
			}
		}

		/**
		 * Populates the pager with proper amount of pages
		 */
		var populatePager = function(){
			var pagerHtml = '';
			var pagerQty = getPagerQty();
			// loop through each pager item
			for(var i=0; i < pagerQty; i++){
				var linkContent = '';
				// if a buildPager function is supplied, use it to get pager link value, else use index + 1
				if(slider.settings.buildPager && $.isFunction(slider.settings.buildPager)){
					linkContent = slider.settings.buildPager(i);
					slider.pagerEl.addClass('bx-custom-pager');
				}else{
					linkContent = i + 1;
					slider.pagerEl.addClass('bx-default-pager');
				}
				// var linkContent = slider.settings.buildPager && $.isFunction(slider.settings.buildPager) ? slider.settings.buildPager(i) : i + 1;
				// add the markup to the string
				pagerHtml += '<div class="bx-pager-item"><a href="javascript:void(0)" data-slide-index="' + i + '" class="bx-pager-link">' + linkContent + '</a></div>';
			};
			// populate the pager element with pager links
			slider.pagerEl.html(pagerHtml);
		}

		/**
		 * Appends the pager to the controls element
		 */
		var appendPager = function(){
			if(!slider.settings.pagerCustom){
				// create the pager DOM element
				slider.pagerEl = $('<div class="bx-pager" />');
				// if a pager selector was supplied, populate it with the pager
				if(slider.settings.pagerSelector){
					$(slider.settings.pagerSelector).html(slider.pagerEl);
				// if no pager selector was supplied, add it after the wrapper
				}else{
					slider.controls.el.addClass('bx-has-pager').append(slider.pagerEl);
				}
				// populate the pager
				populatePager();
			}else{
				slider.pagerEl = $(slider.settings.pagerCustom);
			}
			// assign the pager click binding
			slider.pagerEl.on('click', 'a', clickPagerBind);
		}

		/**
		 * Appends prev / next controls to the controls element
		 */
		var appendControls = function(){
			slider.controls.next = $('<a class="bx-next" href="javascript:void(0)">' + slider.settings.nextText + '</a>');
			slider.controls.prev = $('<a class="bx-prev" href="javascript:void(0)">' + slider.settings.prevText + '</a>');
			// bind click actions to the controls
			slider.controls.next.bind('click', clickNextBind);
			slider.controls.prev.bind('click', clickPrevBind);
			// if nextSlector was supplied, populate it
			if(slider.settings.nextSelector){
				$(slider.settings.nextSelector).append(slider.controls.next);
			}
			// if prevSlector was supplied, populate it
			if(slider.settings.prevSelector){
				$(slider.settings.prevSelector).append(slider.controls.prev);
			}
			// if no custom selectors were supplied
			if(!slider.settings.nextSelector && !slider.settings.prevSelector){
				// add the controls to the DOM
				slider.controls.directionEl = $('<div class="bx-controls-direction" />');
				// add the control elements to the directionEl
				slider.controls.directionEl.append(slider.controls.prev).append(slider.controls.next);
				// slider.viewport.append(slider.controls.directionEl);
				slider.controls.el.addClass('bx-has-controls-direction').append(slider.controls.directionEl);
			}
		}

		/**
		 * Appends start / stop auto controls to the controls element
		 */
		var appendControlsAuto = function(){
			slider.controls.start = $('<div class="bx-controls-auto-item"><a class="bx-start" href="">' + slider.settings.startText + '</a></div>');
			slider.controls.stop = $('<div class="bx-controls-auto-item"><a class="bx-stop" href="">' + slider.settings.stopText + '</a></div>');
			// add the controls to the DOM
			slider.controls.autoEl = $('<div class="bx-controls-auto" />');
			// bind click actions to the controls
			slider.controls.autoEl.on('click', '.bx-start', clickStartBind);
			slider.controls.autoEl.on('click', '.bx-stop', clickStopBind);
			// if autoControlsCombine, insert only the "start" control
			if(slider.settings.autoControlsCombine){
				slider.controls.autoEl.append(slider.controls.start);
			// if autoControlsCombine is false, insert both controls
			}else{
				slider.controls.autoEl.append(slider.controls.start).append(slider.controls.stop);
			}
			// if auto controls selector was supplied, populate it with the controls
			if(slider.settings.autoControlsSelector){
				$(slider.settings.autoControlsSelector).html(slider.controls.autoEl);
			// if auto controls selector was not supplied, add it after the wrapper
			}else{
				slider.controls.el.addClass('bx-has-controls-auto').append(slider.controls.autoEl);
			}
			// update the auto controls
			updateAutoControls(slider.settings.autoStart ? 'stop' : 'start');
		}

		/**
		 * Appends image captions to the DOM
		 */
		var appendCaptions = function(){
			// cycle through each child
			slider.children.each(function(index){
				// get the image title attribute
				var title = $(this).find('img:first').attr('title');
				// append the caption
				if (title != undefined && ('' + title).length) {
                    $(this).append('<div class="bx-caption"><span>' + title + '</span></div>');
                }
			});
		}

		/**
		 * Click next binding
		 *
		 * @param e (event)
		 *  - DOM event object
		 */
		var clickNextBind = function(e){
			// if auto show is running, stop it
			if (slider.settings.auto) el.stopAuto();
			el.goToNextSlide();
			e.preventDefault();
		}

		/**
		 * Click prev binding
		 *
		 * @param e (event)
		 *  - DOM event object
		 */
		var clickPrevBind = function(e){
			// if auto show is running, stop it
			if (slider.settings.auto) el.stopAuto();
			el.goToPrevSlide();
			e.preventDefault();
		}

		/**
		 * Click start binding
		 *
		 * @param e (event)
		 *  - DOM event object
		 */
		var clickStartBind = function(e){
			el.startAuto();
			e.preventDefault();
		}

		/**
		 * Click stop binding
		 *
		 * @param e (event)
		 *  - DOM event object
		 */
		var clickStopBind = function(e){
			el.stopAuto();
			e.preventDefault();
		}

		/**
		 * Click pager binding
		 *
		 * @param e (event)
		 *  - DOM event object
		 */
		var clickPagerBind = function(e){
			// if auto show is running, stop it
			if (slider.settings.auto) el.stopAuto();
			var pagerLink = $(e.currentTarget);
			if(pagerLink.attr('data-slide-index') !== undefined){
				var pagerIndex = parseInt(pagerLink.attr('data-slide-index'));
				// if clicked pager link is not active, continue with the goToSlide call
				if(pagerIndex != slider.active.index) el.goToSlide(pagerIndex);
				e.preventDefault();
			}
		}

		/**
		 * Updates the pager links with an active class
		 *
		 * @param slideIndex (int)
		 *  - index of slide to make active
		 */
		var updatePagerActive = function(slideIndex){
			// if "short" pager type
			var len = slider.children.length; // nb of children
			if(slider.settings.pagerType == 'short'){
				if(slider.settings.maxSlides > 1) {
					len = Math.ceil(slider.children.length/slider.settings.maxSlides);
				}
				slider.pagerEl.html( (slideIndex + 1) + slider.settings.pagerShortSeparator + len);
				return;
			}
			// remove all pager active classes
			slider.pagerEl.find('a').removeClass('active');
			// apply the active class for all pagers
			slider.pagerEl.each(function(i, el) { $(el).find('a').eq(slideIndex).addClass('active'); });
		}

		/**
		 * Performs needed actions after a slide transition
		 */
		var updateAfterSlideTransition = function(){
			// if infinte loop is true
			if(slider.settings.infiniteLoop){
				var position = '';
				// first slide
				if(slider.active.index == 0){
					// set the new position
					position = slider.children.eq(0).position();
				// carousel, last slide
				}else if(slider.active.index == getPagerQty() - 1 && slider.carousel){
					position = slider.children.eq((getPagerQty() - 1) * getMoveBy()).position();
				// last slide
				}else if(slider.active.index == slider.children.length - 1){
					position = slider.children.eq(slider.children.length - 1).position();
				}
				if(position){
					if (slider.settings.mode == 'horizontal') { setPositionProperty(-position.left, 'reset', 0); }
					else if (slider.settings.mode == 'vertical') { setPositionProperty(-position.top, 'reset', 0); }
				}
			}
			// declare that the transition is complete
			slider.working = false;
			// onSlideAfter callback
			slider.settings.onSlideAfter(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
		}

		/**
		 * Updates the auto controls state (either active, or combined switch)
		 *
		 * @param state (string) "start", "stop"
		 *  - the new state of the auto show
		 */
		var updateAutoControls = function(state){
			// if autoControlsCombine is true, replace the current control with the new state
			if(slider.settings.autoControlsCombine){
				slider.controls.autoEl.html(slider.controls[state]);
			// if autoControlsCombine is false, apply the "active" class to the appropriate control
			}else{
				slider.controls.autoEl.find('a').removeClass('active');
				slider.controls.autoEl.find('a:not(.bx-' + state + ')').addClass('active');
			}
		}

		/**
		 * Updates the direction controls (checks if either should be hidden)
		 */
		var updateDirectionControls = function(){
			if(getPagerQty() == 1){
				slider.controls.prev.addClass('disabled');
				slider.controls.next.addClass('disabled');
			}else if(!slider.settings.infiniteLoop && slider.settings.hideControlOnEnd){
				// if first slide
				if (slider.active.index == 0){
					slider.controls.prev.addClass('disabled');
					slider.controls.next.removeClass('disabled');
				// if last slide
				}else if(slider.active.index == getPagerQty() - 1){
					slider.controls.next.addClass('disabled');
					slider.controls.prev.removeClass('disabled');
				// if any slide in the middle
				}else{
					slider.controls.prev.removeClass('disabled');
					slider.controls.next.removeClass('disabled');
				}
			}
		}

		/**
		 * Initialzes the auto process
		 */
		var initAuto = function(){
			// if autoDelay was supplied, launch the auto show using a setTimeout() call
			if(slider.settings.autoDelay > 0){
				var timeout = setTimeout(el.startAuto, slider.settings.autoDelay);
			// if autoDelay was not supplied, start the auto show normally
			}else{
				el.startAuto();
			}
			// if autoHover is requested
			if(slider.settings.autoHover){
				// on el hover
				el.hover(function(){
					// if the auto show is currently playing (has an active interval)
					if(slider.interval){
						// stop the auto show and pass true agument which will prevent control update
						el.stopAuto(true);
						// create a new autoPaused value which will be used by the relative "mouseout" event
						slider.autoPaused = true;
					}
				}, function(){
					// if the autoPaused value was created be the prior "mouseover" event
					if(slider.autoPaused){
						// start the auto show and pass true agument which will prevent control update
						el.startAuto(true);
						// reset the autoPaused value
						slider.autoPaused = null;
					}
				});
			}
		}

		/**
		 * Initialzes the ticker process
		 */
		var initTicker = function(){
			var startPosition = 0;
			// if autoDirection is "next", append a clone of the entire slider
			if(slider.settings.autoDirection == 'next'){
				el.append(slider.children.clone().addClass('bx-clone'));
			// if autoDirection is "prev", prepend a clone of the entire slider, and set the left position
			}else{
				el.prepend(slider.children.clone().addClass('bx-clone'));
				var position = slider.children.first().position();
				startPosition = slider.settings.mode == 'horizontal' ? -position.left : -position.top;
			}
			setPositionProperty(startPosition, 'reset', 0);
			// do not allow controls in ticker mode
			slider.settings.pager = false;
			slider.settings.controls = false;
			slider.settings.autoControls = false;
			// if autoHover is requested
			if(slider.settings.tickerHover && !slider.usingCSS){
				// on el hover
				slider.viewport.hover(function(){
					el.stop();
				}, function(){
					// calculate the total width of children (used to calculate the speed ratio)
					var totalDimens = 0;
					slider.children.each(function(index){
					  totalDimens += slider.settings.mode == 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);
					});
					// calculate the speed ratio (used to determine the new speed to finish the paused animation)
					var ratio = slider.settings.speed / totalDimens;
					// determine which property to use
					var property = slider.settings.mode == 'horizontal' ? 'left' : 'top';
					// calculate the new speed
					var newSpeed = ratio * (totalDimens - (Math.abs(parseInt(el.css(property)))));
					tickerLoop(newSpeed);
				});
			}
			// start the ticker loop
			tickerLoop();
		}

		/**
		 * Runs a continuous loop, news ticker-style
		 */
		var tickerLoop = function(resumeSpeed){
			speed = resumeSpeed ? resumeSpeed : slider.settings.speed;
			var position = {left: 0, top: 0};
			var reset = {left: 0, top: 0};
			// if "next" animate left position to last child, then reset left to 0
			if(slider.settings.autoDirection == 'next'){
				position = el.find('.bx-clone').first().position();
			// if "prev" animate left position to 0, then reset left to first non-clone child
			}else{
				reset = slider.children.first().position();
			}
			var animateProperty = slider.settings.mode == 'horizontal' ? -position.left : -position.top;
			var resetValue = slider.settings.mode == 'horizontal' ? -reset.left : -reset.top;
			var params = {resetValue: resetValue};
			setPositionProperty(animateProperty, 'ticker', speed, params);
		}

		/**
		 * Initializes touch events
		 */
		var initTouch = function(){
			// initialize object to contain all touch values
			slider.touch = {
				start: {x: 0, y: 0},
				end: {x: 0, y: 0}
			}
			slider.viewport.bind('touchstart', onTouchStart);
		}

		/**
		 * Event handler for "touchstart"
		 *
		 * @param e (event)
		 *  - DOM event object
		 */
		var onTouchStart = function(e){
			if(slider.working){
				e.preventDefault();
			}else{
				// record the original position when touch starts
				slider.touch.originalPos = el.position();
				var orig = e.originalEvent;
				// record the starting touch x, y coordinates
				slider.touch.start.x = orig.changedTouches[0].pageX;
				slider.touch.start.y = orig.changedTouches[0].pageY;
				// bind a "touchmove" event to the viewport
				slider.viewport.bind('touchmove', onTouchMove);
				// bind a "touchend" event to the viewport
				slider.viewport.bind('touchend', onTouchEnd);
			}
		}

		/**
		 * Event handler for "touchmove"
		 *
		 * @param e (event)
		 *  - DOM event object
		 */
		var onTouchMove = function(e){
			var orig = e.originalEvent;
			// if scrolling on y axis, do not prevent default
			var xMovement = Math.abs(orig.changedTouches[0].pageX - slider.touch.start.x);
			var yMovement = Math.abs(orig.changedTouches[0].pageY - slider.touch.start.y);
			// x axis swipe
			if((xMovement * 3) > yMovement && slider.settings.preventDefaultSwipeX){
				e.preventDefault();
			// y axis swipe
			}else if((yMovement * 3) > xMovement && slider.settings.preventDefaultSwipeY){
				e.preventDefault();
			}
			if(slider.settings.mode != 'fade' && slider.settings.oneToOneTouch){
				var value = 0;
				// if horizontal, drag along x axis
				if(slider.settings.mode == 'horizontal'){
					var change = orig.changedTouches[0].pageX - slider.touch.start.x;
					value = slider.touch.originalPos.left + change;
				// if vertical, drag along y axis
				}else{
					var change = orig.changedTouches[0].pageY - slider.touch.start.y;
					value = slider.touch.originalPos.top + change;
				}
				setPositionProperty(value, 'reset', 0);
			}
		}

		/**
		 * Event handler for "touchend"
		 *
		 * @param e (event)
		 *  - DOM event object
		 */
		var onTouchEnd = function(e){
			slider.viewport.unbind('touchmove', onTouchMove);
			var orig = e.originalEvent;
			var value = 0;
			// record end x, y positions
			slider.touch.end.x = orig.changedTouches[0].pageX;
			slider.touch.end.y = orig.changedTouches[0].pageY;
			// if fade mode, check if absolute x distance clears the threshold
			if(slider.settings.mode == 'fade'){
				var distance = Math.abs(slider.touch.start.x - slider.touch.end.x);
				if(distance >= slider.settings.swipeThreshold){
					slider.touch.start.x > slider.touch.end.x ? el.goToNextSlide() : el.goToPrevSlide();
					el.stopAuto();
				}
			// not fade mode
			}else{
				var distance = 0;
				// calculate distance and el's animate property
				if(slider.settings.mode == 'horizontal'){
					distance = slider.touch.end.x - slider.touch.start.x;
					value = slider.touch.originalPos.left;
				}else{
					distance = slider.touch.end.y - slider.touch.start.y;
					value = slider.touch.originalPos.top;
				}
				// if not infinite loop and first / last slide, do not attempt a slide transition
				if(!slider.settings.infiniteLoop && ((slider.active.index == 0 && distance > 0) || (slider.active.last && distance < 0))){
					setPositionProperty(value, 'reset', 200);
				}else{
					// check if distance clears threshold
					if(Math.abs(distance) >= slider.settings.swipeThreshold){
						distance < 0 ? el.goToNextSlide() : el.goToPrevSlide();
						el.stopAuto();
					}else{
						// el.animate(property, 200);
						setPositionProperty(value, 'reset', 200);
					}
				}
			}
			slider.viewport.unbind('touchend', onTouchEnd);
		}

		/**
		 * Window resize event callback
		 */
		var resizeWindow = function(e){
			// don't do anything if slider isn't initialized.
			if(!slider.initialized) return;
			// get the new window dimens (again, thank you IE)
			var windowWidthNew = $(window).width();
			var windowHeightNew = $(window).height();
			// make sure that it is a true window resize
			// *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements
			// are resized. Can you just die already?*
			if(windowWidth != windowWidthNew || windowHeight != windowHeightNew){
				// set the new window dimens
				windowWidth = windowWidthNew;
				windowHeight = windowHeightNew;
				// update all dynamic elements
				el.redrawSlider();
				// Call user resize handler
				slider.settings.onSliderResize.call(el, slider.active.index);
			}
		}

		/**
		 * ===================================================================================
		 * = PUBLIC FUNCTIONS
		 * ===================================================================================
		 */

		/**
		 * Performs slide transition to the specified slide
		 *
		 * @param slideIndex (int)
		 *  - the destination slide's index (zero-based)
		 *
		 * @param direction (string)
		 *  - INTERNAL USE ONLY - the direction of travel ("prev" / "next")
		 */
		el.goToSlide = function(slideIndex, direction){
			// if plugin is currently in motion, ignore request
			if(slider.working || slider.active.index == slideIndex) return;
			// declare that plugin is in motion
			slider.working = true;
			// store the old index
			slider.oldIndex = slider.active.index;
			// if slideIndex is less than zero, set active index to last child (this happens during infinite loop)
			if(slideIndex < 0){
				slider.active.index = getPagerQty() - 1;
			// if slideIndex is greater than children length, set active index to 0 (this happens during infinite loop)
			}else if(slideIndex >= getPagerQty()){
				slider.active.index = 0;
			// set active index to requested slide
			}else{
				slider.active.index = slideIndex;
			}
			// onSlideBefore, onSlideNext, onSlidePrev callbacks
			slider.settings.onSlideBefore(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
			if(direction == 'next'){
				slider.settings.onSlideNext(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
			}else if(direction == 'prev'){
				slider.settings.onSlidePrev(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
			}
			// check if last slide
			slider.active.last = slider.active.index >= getPagerQty() - 1;
			// update the pager with active class
			if(slider.settings.pager) updatePagerActive(slider.active.index);
			// // check for direction control update
			if(slider.settings.controls) updateDirectionControls();
			// if slider is set to mode: "fade"
			if(slider.settings.mode == 'fade'){
				// if adaptiveHeight is true and next height is different from current height, animate to the new height
				if(slider.settings.adaptiveHeight && slider.viewport.height() != getViewportHeight()){
					slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);
				}
				// fade out the visible child and reset its z-index value
				slider.children.filter(':visible').fadeOut(slider.settings.speed).css({zIndex: 0});
				// fade in the newly requested slide
				slider.children.eq(slider.active.index).css('zIndex', slider.settings.slideZIndex+1).fadeIn(slider.settings.speed, function(){
					$(this).css('zIndex', slider.settings.slideZIndex);
					updateAfterSlideTransition();
				});
			// slider mode is not "fade"
			}else{
				// if adaptiveHeight is true and next height is different from current height, animate to the new height
				if(slider.settings.adaptiveHeight && slider.viewport.height() != getViewportHeight()){
					slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);
				}
				var moveBy = 0;
				var position = {left: 0, top: 0};
				// if carousel and not infinite loop
				if(!slider.settings.infiniteLoop && slider.carousel && slider.active.last){
					if(slider.settings.mode == 'horizontal'){
						// get the last child position
						var lastChild = slider.children.eq(slider.children.length - 1);
						position = lastChild.position();
						// calculate the position of the last slide
						moveBy = slider.viewport.width() - lastChild.outerWidth();
					}else{
						// get last showing index position
						var lastShowingIndex = slider.children.length - slider.settings.minSlides;
						position = slider.children.eq(lastShowingIndex).position();
					}
					// horizontal carousel, going previous while on first slide (infiniteLoop mode)
				}else if(slider.carousel && slider.active.last && direction == 'prev'){
					// get the last child position
					var eq = slider.settings.moveSlides == 1 ? slider.settings.maxSlides - getMoveBy() : ((getPagerQty() - 1) * getMoveBy()) - (slider.children.length - slider.settings.maxSlides);
					var lastChild = el.children('.bx-clone').eq(eq);
					position = lastChild.position();
				// if infinite loop and "Next" is clicked on the last slide
				}else if(direction == 'next' && slider.active.index == 0){
					// get the last clone position
					position = el.find('> .bx-clone').eq(slider.settings.maxSlides).position();
					slider.active.last = false;
				// normal non-zero requests
				}else if(slideIndex >= 0){
					var requestEl = slideIndex * getMoveBy();
					position = slider.children.eq(requestEl).position();
				}

				/* If the position doesn't exist
				 * (e.g. if you destroy the slider on a next click),
				 * it doesn't throw an error.
				 */
				if ("undefined" !== typeof(position)) {
					var value = slider.settings.mode == 'horizontal' ? -(position.left - moveBy) : -position.top;
					// plugin values to be animated
					setPositionProperty(value, 'slide', slider.settings.speed);
				}
			}
		}

		/**
		 * Transitions to the next slide in the show
		 */
		el.goToNextSlide = function(){
			// if infiniteLoop is false and last page is showing, disregard call
			if (!slider.settings.infiniteLoop && slider.active.last) return;
			var pagerIndex = parseInt(slider.active.index) + 1;
			el.goToSlide(pagerIndex, 'next');
		}

		/**
		 * Transitions to the prev slide in the show
		 */
		el.goToPrevSlide = function(){
			// if infiniteLoop is false and last page is showing, disregard call
			if (!slider.settings.infiniteLoop && slider.active.index == 0) return;
			var pagerIndex = parseInt(slider.active.index) - 1;
			el.goToSlide(pagerIndex, 'prev');
		}

		/**
		 * Starts the auto show
		 *
		 * @param preventControlUpdate (boolean)
		 *  - if true, auto controls state will not be updated
		 */
		el.startAuto = function(preventControlUpdate){
			// if an interval already exists, disregard call
			if(slider.interval) return;
			// create an interval
			slider.interval = setInterval(function(){
				slider.settings.autoDirection == 'next' ? el.goToNextSlide() : el.goToPrevSlide();
			}, slider.settings.pause);
			// if auto controls are displayed and preventControlUpdate is not true
			if (slider.settings.autoControls && preventControlUpdate != true) updateAutoControls('stop');
		}

		/**
		 * Stops the auto show
		 *
		 * @param preventControlUpdate (boolean)
		 *  - if true, auto controls state will not be updated
		 */
		el.stopAuto = function(preventControlUpdate){
			// if no interval exists, disregard call
			if(!slider.interval) return;
			// clear the interval
			clearInterval(slider.interval);
			slider.interval = null;
			// if auto controls are displayed and preventControlUpdate is not true
			if (slider.settings.autoControls && preventControlUpdate != true) updateAutoControls('start');
		}

		/**
		 * Returns current slide index (zero-based)
		 */
		el.getCurrentSlide = function(){
			return slider.active.index;
		}

		/**
		 * Returns current slide element
		 */
		el.getCurrentSlideElement = function(){
			return slider.children.eq(slider.active.index);
		}

		/**
		 * Returns number of slides in show
		 */
		el.getSlideCount = function(){
			return slider.children.length;
		}

		/**
		 * Update all dynamic slider elements
		 */
		el.redrawSlider = function(){
			// resize all children in ratio to new screen size
			slider.children.add(el.find('.bx-clone')).width(getSlideWidth());
			// adjust the height
			slider.viewport.css('height', getViewportHeight());
			// update the slide position
			if(!slider.settings.ticker) setSlidePosition();
			// if active.last was true before the screen resize, we want
			// to keep it last no matter what screen size we end on
			if (slider.active.last) slider.active.index = getPagerQty() - 1;
			// if the active index (page) no longer exists due to the resize, simply set the index as last
			if (slider.active.index >= getPagerQty()) slider.active.last = true;
			// if a pager is being displayed and a custom pager is not being used, update it
			if(slider.settings.pager && !slider.settings.pagerCustom){
				populatePager();
				updatePagerActive(slider.active.index);
			}
		}

		/**
		 * Destroy the current instance of the slider (revert everything back to original state)
		 */
		el.destroySlider = function(){
			// don't do anything if slider has already been destroyed
			if(!slider.initialized) return;
			slider.initialized = false;
			$('.bx-clone', this).remove();
			slider.children.each(function() {
				$(this).data("origStyle") != undefined ? $(this).attr("style", $(this).data("origStyle")) : $(this).removeAttr('style');
			});
			$(this).data("origStyle") != undefined ? this.attr("style", $(this).data("origStyle")) : $(this).removeAttr('style');
			$(this).unwrap().unwrap();
			if(slider.controls.el) slider.controls.el.remove();
			if(slider.controls.next) slider.controls.next.remove();
			if(slider.controls.prev) slider.controls.prev.remove();
			if(slider.pagerEl && slider.settings.controls) slider.pagerEl.remove();
			$('.bx-caption', this).remove();
			if(slider.controls.autoEl) slider.controls.autoEl.remove();
			clearInterval(slider.interval);
			if(slider.settings.responsive) $(window).unbind('resize', resizeWindow);
		}

		/**
		 * Reload the slider (revert all DOM changes, and re-initialize)
		 */
		el.reloadSlider = function(settings){
			if (settings != undefined) options = settings;
			el.destroySlider();
			init();
		}

		init();

		// returns the current jQuery object
		return this;
	}

})(jQuery);

/*
Copyright 2012 Igor Vaynberg

Version: @@ver@@ Timestamp: @@timestamp@@

This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
General Public License version 2 (the "GPL License"). You may choose either license to govern your
use of this software only upon the condition that you accept all of the terms of either the Apache
License or the GPL License.

You may obtain a copy of the Apache License and the GPL License at:

    http://www.apache.org/licenses/LICENSE-2.0
    http://www.gnu.org/licenses/gpl-2.0.html

Unless required by applicable law or agreed to in writing, software distributed under the
Apache License or the GPL License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
the specific language governing permissions and limitations under the Apache License and the GPL License.
*/
(function ($) {
    if(typeof $.fn.each2 == "undefined") {
        $.extend($.fn, {
            /*
            * 4-10 times faster .each replacement
            * use it carefully, as it overrides jQuery context of element on each iteration
            */
            each2 : function (c) {
                var j = $([0]), i = -1, l = this.length;
                while (
                    ++i < l
                    && (j.context = j[0] = this[i])
                    && c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
                );
                return this;
            }
        });
    }
})(jQuery);

(function ($, undefined) {
    "use strict";
    /*global document, window, jQuery, console */

    if (window.Select2 !== undefined) {
        return;
    }

    var AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
        lastMousePosition={x:0,y:0}, $document, scrollBarDimensions,

    KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        isArrow: function (k) {
            k = k.which ? k.which : k;
            switch (k) {
            case KEY.LEFT:
            case KEY.RIGHT:
            case KEY.UP:
            case KEY.DOWN:
                return true;
            }
            return false;
        },
        isControl: function (e) {
            var k = e.which;
            switch (k) {
            case KEY.SHIFT:
            case KEY.CTRL:
            case KEY.ALT:
                return true;
            }

            if (e.metaKey) return true;

            return false;
        },
        isFunctionKey: function (k) {
            k = k.which ? k.which : k;
            return k >= 112 && k <= 123;
        }
    },
    MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",

    DIACRITICS = {"\u24B6":"A","\uFF21":"A","\u00C0":"A","\u00C1":"A","\u00C2":"A","\u1EA6":"A","\u1EA4":"A","\u1EAA":"A","\u1EA8":"A","\u00C3":"A","\u0100":"A","\u0102":"A","\u1EB0":"A","\u1EAE":"A","\u1EB4":"A","\u1EB2":"A","\u0226":"A","\u01E0":"A","\u00C4":"A","\u01DE":"A","\u1EA2":"A","\u00C5":"A","\u01FA":"A","\u01CD":"A","\u0200":"A","\u0202":"A","\u1EA0":"A","\u1EAC":"A","\u1EB6":"A","\u1E00":"A","\u0104":"A","\u023A":"A","\u2C6F":"A","\uA732":"AA","\u00C6":"AE","\u01FC":"AE","\u01E2":"AE","\uA734":"AO","\uA736":"AU","\uA738":"AV","\uA73A":"AV","\uA73C":"AY","\u24B7":"B","\uFF22":"B","\u1E02":"B","\u1E04":"B","\u1E06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24B8":"C","\uFF23":"C","\u0106":"C","\u0108":"C","\u010A":"C","\u010C":"C","\u00C7":"C","\u1E08":"C","\u0187":"C","\u023B":"C","\uA73E":"C","\u24B9":"D","\uFF24":"D","\u1E0A":"D","\u010E":"D","\u1E0C":"D","\u1E10":"D","\u1E12":"D","\u1E0E":"D","\u0110":"D","\u018B":"D","\u018A":"D","\u0189":"D","\uA779":"D","\u01F1":"DZ","\u01C4":"DZ","\u01F2":"Dz","\u01C5":"Dz","\u24BA":"E","\uFF25":"E","\u00C8":"E","\u00C9":"E","\u00CA":"E","\u1EC0":"E","\u1EBE":"E","\u1EC4":"E","\u1EC2":"E","\u1EBC":"E","\u0112":"E","\u1E14":"E","\u1E16":"E","\u0114":"E","\u0116":"E","\u00CB":"E","\u1EBA":"E","\u011A":"E","\u0204":"E","\u0206":"E","\u1EB8":"E","\u1EC6":"E","\u0228":"E","\u1E1C":"E","\u0118":"E","\u1E18":"E","\u1E1A":"E","\u0190":"E","\u018E":"E","\u24BB":"F","\uFF26":"F","\u1E1E":"F","\u0191":"F","\uA77B":"F","\u24BC":"G","\uFF27":"G","\u01F4":"G","\u011C":"G","\u1E20":"G","\u011E":"G","\u0120":"G","\u01E6":"G","\u0122":"G","\u01E4":"G","\u0193":"G","\uA7A0":"G","\uA77D":"G","\uA77E":"G","\u24BD":"H","\uFF28":"H","\u0124":"H","\u1E22":"H","\u1E26":"H","\u021E":"H","\u1E24":"H","\u1E28":"H","\u1E2A":"H","\u0126":"H","\u2C67":"H","\u2C75":"H","\uA78D":"H","\u24BE":"I","\uFF29":"I","\u00CC":"I","\u00CD":"I","\u00CE":"I","\u0128":"I","\u012A":"I","\u012C":"I","\u0130":"I","\u00CF":"I","\u1E2E":"I","\u1EC8":"I","\u01CF":"I","\u0208":"I","\u020A":"I","\u1ECA":"I","\u012E":"I","\u1E2C":"I","\u0197":"I","\u24BF":"J","\uFF2A":"J","\u0134":"J","\u0248":"J","\u24C0":"K","\uFF2B":"K","\u1E30":"K","\u01E8":"K","\u1E32":"K","\u0136":"K","\u1E34":"K","\u0198":"K","\u2C69":"K","\uA740":"K","\uA742":"K","\uA744":"K","\uA7A2":"K","\u24C1":"L","\uFF2C":"L","\u013F":"L","\u0139":"L","\u013D":"L","\u1E36":"L","\u1E38":"L","\u013B":"L","\u1E3C":"L","\u1E3A":"L","\u0141":"L","\u023D":"L","\u2C62":"L","\u2C60":"L","\uA748":"L","\uA746":"L","\uA780":"L","\u01C7":"LJ","\u01C8":"Lj","\u24C2":"M","\uFF2D":"M","\u1E3E":"M","\u1E40":"M","\u1E42":"M","\u2C6E":"M","\u019C":"M","\u24C3":"N","\uFF2E":"N","\u01F8":"N","\u0143":"N","\u00D1":"N","\u1E44":"N","\u0147":"N","\u1E46":"N","\u0145":"N","\u1E4A":"N","\u1E48":"N","\u0220":"N","\u019D":"N","\uA790":"N","\uA7A4":"N","\u01CA":"NJ","\u01CB":"Nj","\u24C4":"O","\uFF2F":"O","\u00D2":"O","\u00D3":"O","\u00D4":"O","\u1ED2":"O","\u1ED0":"O","\u1ED6":"O","\u1ED4":"O","\u00D5":"O","\u1E4C":"O","\u022C":"O","\u1E4E":"O","\u014C":"O","\u1E50":"O","\u1E52":"O","\u014E":"O","\u022E":"O","\u0230":"O","\u00D6":"O","\u022A":"O","\u1ECE":"O","\u0150":"O","\u01D1":"O","\u020C":"O","\u020E":"O","\u01A0":"O","\u1EDC":"O","\u1EDA":"O","\u1EE0":"O","\u1EDE":"O","\u1EE2":"O","\u1ECC":"O","\u1ED8":"O","\u01EA":"O","\u01EC":"O","\u00D8":"O","\u01FE":"O","\u0186":"O","\u019F":"O","\uA74A":"O","\uA74C":"O","\u01A2":"OI","\uA74E":"OO","\u0222":"OU","\u24C5":"P","\uFF30":"P","\u1E54":"P","\u1E56":"P","\u01A4":"P","\u2C63":"P","\uA750":"P","\uA752":"P","\uA754":"P","\u24C6":"Q","\uFF31":"Q","\uA756":"Q","\uA758":"Q","\u024A":"Q","\u24C7":"R","\uFF32":"R","\u0154":"R","\u1E58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1E5A":"R","\u1E5C":"R","\u0156":"R","\u1E5E":"R","\u024C":"R","\u2C64":"R","\uA75A":"R","\uA7A6":"R","\uA782":"R","\u24C8":"S","\uFF33":"S","\u1E9E":"S","\u015A":"S","\u1E64":"S","\u015C":"S","\u1E60":"S","\u0160":"S","\u1E66":"S","\u1E62":"S","\u1E68":"S","\u0218":"S","\u015E":"S","\u2C7E":"S","\uA7A8":"S","\uA784":"S","\u24C9":"T","\uFF34":"T","\u1E6A":"T","\u0164":"T","\u1E6C":"T","\u021A":"T","\u0162":"T","\u1E70":"T","\u1E6E":"T","\u0166":"T","\u01AC":"T","\u01AE":"T","\u023E":"T","\uA786":"T","\uA728":"TZ","\u24CA":"U","\uFF35":"U","\u00D9":"U","\u00DA":"U","\u00DB":"U","\u0168":"U","\u1E78":"U","\u016A":"U","\u1E7A":"U","\u016C":"U","\u00DC":"U","\u01DB":"U","\u01D7":"U","\u01D5":"U","\u01D9":"U","\u1EE6":"U","\u016E":"U","\u0170":"U","\u01D3":"U","\u0214":"U","\u0216":"U","\u01AF":"U","\u1EEA":"U","\u1EE8":"U","\u1EEE":"U","\u1EEC":"U","\u1EF0":"U","\u1EE4":"U","\u1E72":"U","\u0172":"U","\u1E76":"U","\u1E74":"U","\u0244":"U","\u24CB":"V","\uFF36":"V","\u1E7C":"V","\u1E7E":"V","\u01B2":"V","\uA75E":"V","\u0245":"V","\uA760":"VY","\u24CC":"W","\uFF37":"W","\u1E80":"W","\u1E82":"W","\u0174":"W","\u1E86":"W","\u1E84":"W","\u1E88":"W","\u2C72":"W","\u24CD":"X","\uFF38":"X","\u1E8A":"X","\u1E8C":"X","\u24CE":"Y","\uFF39":"Y","\u1EF2":"Y","\u00DD":"Y","\u0176":"Y","\u1EF8":"Y","\u0232":"Y","\u1E8E":"Y","\u0178":"Y","\u1EF6":"Y","\u1EF4":"Y","\u01B3":"Y","\u024E":"Y","\u1EFE":"Y","\u24CF":"Z","\uFF3A":"Z","\u0179":"Z","\u1E90":"Z","\u017B":"Z","\u017D":"Z","\u1E92":"Z","\u1E94":"Z","\u01B5":"Z","\u0224":"Z","\u2C7F":"Z","\u2C6B":"Z","\uA762":"Z","\u24D0":"a","\uFF41":"a","\u1E9A":"a","\u00E0":"a","\u00E1":"a","\u00E2":"a","\u1EA7":"a","\u1EA5":"a","\u1EAB":"a","\u1EA9":"a","\u00E3":"a","\u0101":"a","\u0103":"a","\u1EB1":"a","\u1EAF":"a","\u1EB5":"a","\u1EB3":"a","\u0227":"a","\u01E1":"a","\u00E4":"a","\u01DF":"a","\u1EA3":"a","\u00E5":"a","\u01FB":"a","\u01CE":"a","\u0201":"a","\u0203":"a","\u1EA1":"a","\u1EAD":"a","\u1EB7":"a","\u1E01":"a","\u0105":"a","\u2C65":"a","\u0250":"a","\uA733":"aa","\u00E6":"ae","\u01FD":"ae","\u01E3":"ae","\uA735":"ao","\uA737":"au","\uA739":"av","\uA73B":"av","\uA73D":"ay","\u24D1":"b","\uFF42":"b","\u1E03":"b","\u1E05":"b","\u1E07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24D2":"c","\uFF43":"c","\u0107":"c","\u0109":"c","\u010B":"c","\u010D":"c","\u00E7":"c","\u1E09":"c","\u0188":"c","\u023C":"c","\uA73F":"c","\u2184":"c","\u24D3":"d","\uFF44":"d","\u1E0B":"d","\u010F":"d","\u1E0D":"d","\u1E11":"d","\u1E13":"d","\u1E0F":"d","\u0111":"d","\u018C":"d","\u0256":"d","\u0257":"d","\uA77A":"d","\u01F3":"dz","\u01C6":"dz","\u24D4":"e","\uFF45":"e","\u00E8":"e","\u00E9":"e","\u00EA":"e","\u1EC1":"e","\u1EBF":"e","\u1EC5":"e","\u1EC3":"e","\u1EBD":"e","\u0113":"e","\u1E15":"e","\u1E17":"e","\u0115":"e","\u0117":"e","\u00EB":"e","\u1EBB":"e","\u011B":"e","\u0205":"e","\u0207":"e","\u1EB9":"e","\u1EC7":"e","\u0229":"e","\u1E1D":"e","\u0119":"e","\u1E19":"e","\u1E1B":"e","\u0247":"e","\u025B":"e","\u01DD":"e","\u24D5":"f","\uFF46":"f","\u1E1F":"f","\u0192":"f","\uA77C":"f","\u24D6":"g","\uFF47":"g","\u01F5":"g","\u011D":"g","\u1E21":"g","\u011F":"g","\u0121":"g","\u01E7":"g","\u0123":"g","\u01E5":"g","\u0260":"g","\uA7A1":"g","\u1D79":"g","\uA77F":"g","\u24D7":"h","\uFF48":"h","\u0125":"h","\u1E23":"h","\u1E27":"h","\u021F":"h","\u1E25":"h","\u1E29":"h","\u1E2B":"h","\u1E96":"h","\u0127":"h","\u2C68":"h","\u2C76":"h","\u0265":"h","\u0195":"hv","\u24D8":"i","\uFF49":"i","\u00EC":"i","\u00ED":"i","\u00EE":"i","\u0129":"i","\u012B":"i","\u012D":"i","\u00EF":"i","\u1E2F":"i","\u1EC9":"i","\u01D0":"i","\u0209":"i","\u020B":"i","\u1ECB":"i","\u012F":"i","\u1E2D":"i","\u0268":"i","\u0131":"i","\u24D9":"j","\uFF4A":"j","\u0135":"j","\u01F0":"j","\u0249":"j","\u24DA":"k","\uFF4B":"k","\u1E31":"k","\u01E9":"k","\u1E33":"k","\u0137":"k","\u1E35":"k","\u0199":"k","\u2C6A":"k","\uA741":"k","\uA743":"k","\uA745":"k","\uA7A3":"k","\u24DB":"l","\uFF4C":"l","\u0140":"l","\u013A":"l","\u013E":"l","\u1E37":"l","\u1E39":"l","\u013C":"l","\u1E3D":"l","\u1E3B":"l","\u017F":"l","\u0142":"l","\u019A":"l","\u026B":"l","\u2C61":"l","\uA749":"l","\uA781":"l","\uA747":"l","\u01C9":"lj","\u24DC":"m","\uFF4D":"m","\u1E3F":"m","\u1E41":"m","\u1E43":"m","\u0271":"m","\u026F":"m","\u24DD":"n","\uFF4E":"n","\u01F9":"n","\u0144":"n","\u00F1":"n","\u1E45":"n","\u0148":"n","\u1E47":"n","\u0146":"n","\u1E4B":"n","\u1E49":"n","\u019E":"n","\u0272":"n","\u0149":"n","\uA791":"n","\uA7A5":"n","\u01CC":"nj","\u24DE":"o","\uFF4F":"o","\u00F2":"o","\u00F3":"o","\u00F4":"o","\u1ED3":"o","\u1ED1":"o","\u1ED7":"o","\u1ED5":"o","\u00F5":"o","\u1E4D":"o","\u022D":"o","\u1E4F":"o","\u014D":"o","\u1E51":"o","\u1E53":"o","\u014F":"o","\u022F":"o","\u0231":"o","\u00F6":"o","\u022B":"o","\u1ECF":"o","\u0151":"o","\u01D2":"o","\u020D":"o","\u020F":"o","\u01A1":"o","\u1EDD":"o","\u1EDB":"o","\u1EE1":"o","\u1EDF":"o","\u1EE3":"o","\u1ECD":"o","\u1ED9":"o","\u01EB":"o","\u01ED":"o","\u00F8":"o","\u01FF":"o","\u0254":"o","\uA74B":"o","\uA74D":"o","\u0275":"o","\u01A3":"oi","\u0223":"ou","\uA74F":"oo","\u24DF":"p","\uFF50":"p","\u1E55":"p","\u1E57":"p","\u01A5":"p","\u1D7D":"p","\uA751":"p","\uA753":"p","\uA755":"p","\u24E0":"q","\uFF51":"q","\u024B":"q","\uA757":"q","\uA759":"q","\u24E1":"r","\uFF52":"r","\u0155":"r","\u1E59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1E5B":"r","\u1E5D":"r","\u0157":"r","\u1E5F":"r","\u024D":"r","\u027D":"r","\uA75B":"r","\uA7A7":"r","\uA783":"r","\u24E2":"s","\uFF53":"s","\u00DF":"s","\u015B":"s","\u1E65":"s","\u015D":"s","\u1E61":"s","\u0161":"s","\u1E67":"s","\u1E63":"s","\u1E69":"s","\u0219":"s","\u015F":"s","\u023F":"s","\uA7A9":"s","\uA785":"s","\u1E9B":"s","\u24E3":"t","\uFF54":"t","\u1E6B":"t","\u1E97":"t","\u0165":"t","\u1E6D":"t","\u021B":"t","\u0163":"t","\u1E71":"t","\u1E6F":"t","\u0167":"t","\u01AD":"t","\u0288":"t","\u2C66":"t","\uA787":"t","\uA729":"tz","\u24E4":"u","\uFF55":"u","\u00F9":"u","\u00FA":"u","\u00FB":"u","\u0169":"u","\u1E79":"u","\u016B":"u","\u1E7B":"u","\u016D":"u","\u00FC":"u","\u01DC":"u","\u01D8":"u","\u01D6":"u","\u01DA":"u","\u1EE7":"u","\u016F":"u","\u0171":"u","\u01D4":"u","\u0215":"u","\u0217":"u","\u01B0":"u","\u1EEB":"u","\u1EE9":"u","\u1EEF":"u","\u1EED":"u","\u1EF1":"u","\u1EE5":"u","\u1E73":"u","\u0173":"u","\u1E77":"u","\u1E75":"u","\u0289":"u","\u24E5":"v","\uFF56":"v","\u1E7D":"v","\u1E7F":"v","\u028B":"v","\uA75F":"v","\u028C":"v","\uA761":"vy","\u24E6":"w","\uFF57":"w","\u1E81":"w","\u1E83":"w","\u0175":"w","\u1E87":"w","\u1E85":"w","\u1E98":"w","\u1E89":"w","\u2C73":"w","\u24E7":"x","\uFF58":"x","\u1E8B":"x","\u1E8D":"x","\u24E8":"y","\uFF59":"y","\u1EF3":"y","\u00FD":"y","\u0177":"y","\u1EF9":"y","\u0233":"y","\u1E8F":"y","\u00FF":"y","\u1EF7":"y","\u1E99":"y","\u1EF5":"y","\u01B4":"y","\u024F":"y","\u1EFF":"y","\u24E9":"z","\uFF5A":"z","\u017A":"z","\u1E91":"z","\u017C":"z","\u017E":"z","\u1E93":"z","\u1E95":"z","\u01B6":"z","\u0225":"z","\u0240":"z","\u2C6C":"z","\uA763":"z","\u0386":"\u0391","\u0388":"\u0395","\u0389":"\u0397","\u038A":"\u0399","\u03AA":"\u0399","\u038C":"\u039F","\u038E":"\u03A5","\u03AB":"\u03A5","\u038F":"\u03A9","\u03AC":"\u03B1","\u03AD":"\u03B5","\u03AE":"\u03B7","\u03AF":"\u03B9","\u03CA":"\u03B9","\u0390":"\u03B9","\u03CC":"\u03BF","\u03CD":"\u03C5","\u03CB":"\u03C5","\u03B0":"\u03C5","\u03C9":"\u03C9","\u03C2":"\u03C3"};

    $document = $(document);

    nextUid=(function() { var counter=1; return function() { return counter++; }; }());


    function reinsertElement(element) {
        var placeholder = $(document.createTextNode(''));

        element.before(placeholder);
        placeholder.before(element);
        placeholder.remove();
    }

    function stripDiacritics(str) {
        // Used 'uni range + named function' from http://jsperf.com/diacritics/18
        function match(a) {
            return DIACRITICS[a] || a;
        }

        return str.replace(/[^\u0000-\u007E]/g, match);
    }

    function indexOf(value, array) {
        var i = 0, l = array.length;
        for (; i < l; i = i + 1) {
            if (equal(value, array[i])) return i;
        }
        return -1;
    }

    function measureScrollbar () {
        var $template = $( MEASURE_SCROLLBAR_TEMPLATE );
        $template.appendTo(document.body);

        var dim = {
            width: $template.width() - $template[0].clientWidth,
            height: $template.height() - $template[0].clientHeight
        };
        $template.remove();

        return dim;
    }

    /**
     * Compares equality of a and b
     * @param a
     * @param b
     */
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        // Check whether 'a' or 'b' is a string (primitive or object).
        // The concatenation of an empty string (+'') converts its argument to a string's primitive.
        if (a.constructor === String) return a+'' === b+''; // a+'' - in case 'a' is a String object
        if (b.constructor === String) return b+'' === a+''; // b+'' - in case 'b' is a String object
        return false;
    }

    /**
     * Splits the string into an array of values, transforming each value. An empty array is returned for nulls or empty
     * strings
     * @param string
     * @param separator
     */
    function splitVal(string, separator, transform) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = transform(val[i]);
        return val;
    }

    function getSideBorderPadding(element) {
        return element.outerWidth(false) - element.width();
    }

    function installKeyUpChangeEvent(element) {
        var key="keyup-change-value";
        element.on("keydown", function () {
            if ($.data(element, key) === undefined) {
                $.data(element, key, element.val());
            }
        });
        element.on("keyup", function () {
            var val= $.data(element, key);
            if (val !== undefined && element.val() !== val) {
                $.removeData(element, key);
                element.trigger("keyup-change");
            }
        });
    }


    /**
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    function installFilteredMouseMove(element) {
        element.on("mousemove", function (e) {
            var lastpos = lastMousePosition;
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }

    /**
     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
     * within the last quietMillis milliseconds.
     *
     * @param quietMillis number of milliseconds to wait before invoking fn
     * @param fn function to be debounced
     * @param ctx object to be used as this reference within fn
     * @return debounced version of fn
     */
    function debounce(quietMillis, fn, ctx) {
        ctx = ctx || undefined;
        var timeout;
        return function () {
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                fn.apply(ctx, args);
            }, quietMillis);
        };
    }

    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
        element.on("scroll", function (e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }

    function focus($el) {
        if ($el[0] === document.activeElement) return;

        /* set the focus in a 0 timeout - that way the focus is set after the processing
            of the current event has finished - which seems like the only reliable way
            to set focus */
        window.setTimeout(function() {
            var el=$el[0], pos=$el.val().length, range;

            $el.focus();

            /* make sure el received focus so we do not error out when trying to manipulate the caret.
                sometimes modals or others listeners may steal it after its set */
            var isVisible = (el.offsetWidth > 0 || el.offsetHeight > 0);
            if (isVisible && el === document.activeElement) {

                /* after the focus is set move the caret to the end, necessary when we val()
                    just before setting focus */
                if(el.setSelectionRange)
                {
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                }
            }
        }, 0);
    }

    function getCursorInfo(el) {
        el = $(el)[0];
        var offset = 0;
        var length = 0;
        if ('selectionStart' in el) {
            offset = el.selectionStart;
            length = el.selectionEnd - offset;
        } else if ('selection' in document) {
            el.focus();
            var sel = document.selection.createRange();
            length = document.selection.createRange().text.length;
            sel.moveStart('character', -el.value.length);
            offset = sel.text.length - length;
        }
        return { offset: offset, length: length };
    }

    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function killEventImmediately(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function measureTextWidth(e) {
        if (!sizer){
            var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
            sizer = $(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                letterSpacing: style.letterSpacing,
                textTransform: style.textTransform,
                whiteSpace: "nowrap"
            });
            sizer.attr("class","select2-sizer");
            $(document.body).append(sizer);
        }
        sizer.text(e.val());
        return sizer.width();
    }

    function syncCssClasses(dest, src, adapter) {
        var classes, replacements = [], adapted;

        classes = $.trim(dest.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") === 0) {
                    replacements.push(this);
                }
            });
        }

        classes = $.trim(src.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") !== 0) {
                    adapted = adapter(this);

                    if (adapted) {
                        replacements.push(adapted);
                    }
                }
            });
        }

        dest.attr("class", replacements.join(" "));
    }


    function markMatch(text, term, markup, escapeMarkup) {
        var match=stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
            tl=term.length;

        if (match<0) {
            markup.push(escapeMarkup(text));
            return;
        }

        markup.push(escapeMarkup(text.substring(0, match)));
        markup.push("<span class='select2-match'>");
        markup.push(escapeMarkup(text.substring(match, match + tl)));
        markup.push("</span>");
        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
    }

    function defaultEscapeMarkup(markup) {
        var replace_map = {
            '\\': '&#92;',
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            "/": '&#47;'
        };

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
            return replace_map[match];
        });
    }

    /**
     * Produces an ajax-based query function
     *
     * @param options object containing configuration parameters
     * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
     * @param options.url url for the data
     * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
     * @param options.dataType request data type: ajax, jsonp, other datatypes supported by jQuery's $.ajax function or the transport function if specified
     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
     * @param options.results a function(remoteData, pageNumber, query) that converts data returned form the remote request to the format expected by Select2.
     *      The expected format is an object containing the following keys:
     *      results array of objects that will be used as choices
     *      more (optional) boolean indicating whether there are more results available
     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
     */
    function ajax(options) {
        var timeout, // current scheduled but not yet executed request
            handler = null,
            quietMillis = options.quietMillis || 100,
            ajaxUrl = options.url,
            self = this;

        return function (query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                var data = options.data, // ajax data function
                    url = ajaxUrl, // ajax url string or function
                    transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                    // deprecated - to be removed in 4.0  - use params instead
                    deprecated = {
                        type: options.type || 'GET', // set type of request (GET or POST)
                        cache: options.cache || false,
                        jsonpCallback: options.jsonpCallback||undefined,
                        dataType: options.dataType||"json"
                    },
                    params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                data = data ? data.call(self, query.term, query.page, query.context) : null;
                url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                if (handler && typeof handler.abort === "function") { handler.abort(); }

                if (options.params) {
                    if ($.isFunction(options.params)) {
                        $.extend(params, options.params.call(self));
                    } else {
                        $.extend(params, options.params);
                    }
                }

                $.extend(params, {
                    url: url,
                    dataType: options.dataType,
                    data: data,
                    success: function (data) {
                        // TODO - replace query.page with query so users have access to term, page, etc.
                        // added query as third paramter to keep backwards compatibility
                        var results = options.results(data, query.page, query);
                        query.callback(results);
                    },
                    error: function(jqXHR, textStatus, errorThrown){
                        var results = {
                            hasError: true,
                            jqXHR: jqXHR,
                            textStatus: textStatus,
                            errorThrown: errorThrown
                        };

                        query.callback(results);
                    }
                });
                handler = transport.call(self, params);
            }, quietMillis);
        };
    }

    /**
     * Produces a query function that works with a local array
     *
     * @param options object containing configuration parameters. The options parameter can either be an array or an
     * object.
     *
     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
     *
     * If the object form is used it is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
     * the text.
     */
    function local(options) {
        var data = options, // data elements
            dataText,
            tmp,
            text = function (item) { return ""+item.text; }; // function used to retrieve the text portion of a data item that is matched against the search

         if ($.isArray(data)) {
            tmp = data;
            data = { results: tmp };
        }

         if ($.isFunction(data) === false) {
            tmp = data;
            data = function() { return tmp; };
        }

        var dataItem = data();
        if (dataItem.text) {
            text = dataItem.text;
            // if text is not a function we assume it to be a key name
            if (!$.isFunction(text)) {
                dataText = dataItem.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
                text = function (item) { return item[dataText]; };
            }
        }

        return function (query) {
            var t = query.term, filtered = { results: [] }, process;
            if (t === "") {
                query.callback(data());
                return;
            }

            process = function(datum, collection) {
                var group, attr;
                datum = datum[0];
                if (datum.children) {
                    group = {};
                    for (attr in datum) {
                        if (datum.hasOwnProperty(attr)) group[attr]=datum[attr];
                    }
                    group.children=[];
                    $(datum.children).each2(function(i, childDatum) { process(childDatum, group.children); });
                    if (group.children.length || query.matcher(t, text(group), datum)) {
                        collection.push(group);
                    }
                } else {
                    if (query.matcher(t, text(datum), datum)) {
                        collection.push(datum);
                    }
                }
            };

            $(data().results).each2(function(i, datum) { process(datum, filtered.results); });
            query.callback(filtered);
        };
    }

    // TODO javadoc
    function tags(data) {
        var isFunc = $.isFunction(data);
        return function (query) {
            var t = query.term, filtered = {results: []};
            var result = isFunc ? data(query) : data;
            if ($.isArray(result)) {
                $(result).each(function () {
                    var isObject = this.text !== undefined,
                        text = isObject ? this.text : this;
                    if (t === "" || query.matcher(t, text)) {
                        filtered.results.push(isObject ? this : {id: this, text: this});
                    }
                });
                query.callback(filtered);
            }
        };
    }

    /**
     * Checks if the formatter function should be used.
     *
     * Throws an error if it is not a function. Returns true if it should be used,
     * false if no formatting should be performed.
     *
     * @param formatter
     */
    function checkFormatter(formatter, formatterName) {
        if ($.isFunction(formatter)) return true;
        if (!formatter) return false;
        if (typeof(formatter) === 'string') return true;
        throw new Error(formatterName +" must be a string, function, or falsy value");
    }

  /**
   * Returns a given value
   * If given a function, returns its output
   *
   * @param val string|function
   * @param context value of "this" to be passed to function
   * @returns {*}
   */
    function evaluate(val, context) {
        if ($.isFunction(val)) {
            var args = Array.prototype.slice.call(arguments, 2);
            return val.apply(context, args);
        }
        return val;
    }

    function countResults(results) {
        var count = 0;
        $.each(results, function(i, item) {
            if (item.children) {
                count += countResults(item.children);
            } else {
                count++;
            }
        });
        return count;
    }

    /**
     * Default tokenizer. This function uses breaks the input on substring match of any string from the
     * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
     * two options have to be defined in order for the tokenizer to work.
     *
     * @param input text user has typed so far or pasted into the search field
     * @param selection currently selected choices
     * @param selectCallback function(choice) callback tho add the choice to selection
     * @param opts select2's opts
     * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
     */
    function defaultTokenizer(input, selection, selectCallback, opts) {
        var original = input, // store the original so we can compare and know if we need to tell the search to update its text
            dupe = false, // check for whether a token we extracted represents a duplicate selected choice
            token, // token
            index, // position at which the separator was found
            i, l, // looping variables
            separator; // the matched separator

        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;

        while (true) {
            index = -1;

            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                separator = opts.tokenSeparators[i];
                index = input.indexOf(separator);
                if (index >= 0) break;
            }

            if (index < 0) break; // did not find any token separator in the input string, bail

            token = input.substring(0, index);
            input = input.substring(index + separator.length);

            if (token.length > 0) {
                token = opts.createSearchChoice.call(this, token, selection);
                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                    dupe = false;
                    for (i = 0, l = selection.length; i < l; i++) {
                        if (equal(opts.id(token), opts.id(selection[i]))) {
                            dupe = true; break;
                        }
                    }

                    if (!dupe) selectCallback(token);
                }
            }
        }

        if (original!==input) return input;
    }

    function cleanupJQueryElements() {
        var self = this;

        $.each(arguments, function (i, element) {
            self[element].remove();
            self[element] = null;
        });
    }

    /**
     * Creates a new class
     *
     * @param superClass
     * @param methods
     */
    function clazz(SuperClass, methods) {
        var constructor = function () {};
        constructor.prototype = new SuperClass;
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }

    AbstractSelect2 = clazz(Object, {

        // abstract
        bind: function (func) {
            var self = this;
            return function () {
                func.apply(self, arguments);
            };
        },

        // abstract
        init: function (opts) {
            var results, search, resultsSelector = ".select2-results";

            // prepare options
            this.opts = opts = this.prepareOpts(opts);

            this.id=opts.id;

            // destroy if called on an existing component
            if (opts.element.data("select2") !== undefined &&
                opts.element.data("select2") !== null) {
                opts.element.data("select2").destroy();
            }

            this.container = this.createContainer();

            this.liveRegion = $('.select2-hidden-accessible');
            if (this.liveRegion.length == 0) {
                this.liveRegion = $("<span>", {
                        role: "status",
                        "aria-live": "polite"
                    })
                    .addClass("select2-hidden-accessible")
                    .appendTo(document.body);
            }

            this.containerId="s2id_"+(opts.element.attr("id") || "autogen"+nextUid());
            this.containerEventName= this.containerId
                .replace(/([.])/g, '_')
                .replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
            this.container.attr("id", this.containerId);

            this.container.attr("title", opts.element.attr("title"));

            this.body = $(document.body);

            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

            this.container.attr("style", opts.element.attr("style"));
            this.container.css(evaluate(opts.containerCss, this.opts.element));
            this.container.addClass(evaluate(opts.containerCssClass, this.opts.element));

            this.elementTabIndex = this.opts.element.attr("tabindex");

            // swap container for the element
            this.opts.element
                .data("select2", this)
                .attr("tabindex", "-1")
                .before(this.container)
                .on("click.select2", killEvent); // do not leak click events

            this.container.data("select2", this);

            this.dropdown = this.container.find(".select2-drop");

            syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

            this.dropdown.addClass(evaluate(opts.dropdownCssClass, this.opts.element));
            this.dropdown.data("select2", this);
            this.dropdown.on("click", killEvent);

            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input.select2-input");

            this.queryCount = 0;
            this.resultsPage = 0;
            this.context = null;

            // initialize the container
            this.initContainer();

            this.container.on("click", killEvent);

            installFilteredMouseMove(this.results);

            this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
            this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function (event) {
                this._touchEvent = true;
                this.highlightUnderEvent(event);
            }));
            this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
            this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));

            // Waiting for a click event on touch devices to select option and hide dropdown
            // otherwise click will be triggered on an underlying element
            this.dropdown.on('click', this.bind(function (event) {
                if (this._touchEvent) {
                    this._touchEvent = false;
                    this.selectHighlighted();
                }
            }));

            installDebouncedScroll(80, this.results);
            this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

            // do not propagate change event from the search field out of the component
            $(this.container).on("change", ".select2-input", function(e) {e.stopPropagation();});
            $(this.dropdown).on("change", ".select2-input", function(e) {e.stopPropagation();});

            // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
            if ($.fn.mousewheel) {
                results.mousewheel(function (e, delta, deltaX, deltaY) {
                    var top = results.scrollTop();
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }

            installKeyUpChangeEvent(search);
            search.on("keyup-change input paste", this.bind(this.updateResults));
            search.on("focus", function () { search.addClass("select2-focused"); });
            search.on("blur", function () { search.removeClass("select2-focused");});

            this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                if ($(e.target).closest(".select2-result-selectable").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                }
            }));

            // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
            // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
            // dom it will trigger the popup close, which is not what we want
            // focusin can cause focus wars between modals and select2 since the dropdown is outside the modal.
            this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function (e) { e.stopPropagation(); });

            this.lastSearchTerm = undefined;

            if ($.isFunction(this.opts.initSelection)) {
                // initialize selection based on the current value of the source element
                this.initSelection();

                // if the user has provided a function that can set selection based on the value of the source element
                // we monitor the change event on the element and trigger it, allowing for two way synchronization
                this.monitorSource();
            }

            if (opts.maximumInputLength !== null) {
                this.search.attr("maxlength", opts.maximumInputLength);
            }

            var disabled = opts.element.prop("disabled");
            if (disabled === undefined) disabled = false;
            this.enable(!disabled);

            var readonly = opts.element.prop("readonly");
            if (readonly === undefined) readonly = false;
            this.readonly(readonly);

            // Calculate size of scrollbar
            scrollBarDimensions = scrollBarDimensions || measureScrollbar();

            this.autofocus = opts.element.prop("autofocus");
            opts.element.prop("autofocus", false);
            if (this.autofocus) this.focus();

            this.search.attr("placeholder", opts.searchInputPlaceholder);
        },

        // abstract
        destroy: function () {
            var element=this.opts.element, select2 = element.data("select2"), self = this;

            this.close();

            if (element.length && element[0].detachEvent && self._sync) {
                element.each(function () {
                    if (self._sync) {
                        this.detachEvent("onpropertychange", self._sync);
                    }
                });
            }
            if (this.propertyObserver) {
                this.propertyObserver.disconnect();
                this.propertyObserver = null;
            }
            this._sync = null;

            if (select2 !== undefined) {
                select2.container.remove();
                select2.liveRegion.remove();
                select2.dropdown.remove();
                element.removeData("select2")
                    .off("select2");
                if (!element.is("input[type='hidden']")) {
                    element
                        .show()
                        .prop("autofocus", this.autofocus || false);
                    if (this.elementTabIndex) {
                        element.attr({tabindex: this.elementTabIndex});
                    } else {
                        element.removeAttr("tabindex");
                    }
                    element.show();
                } else {
                    element.css("display", "");
                }
            }

            cleanupJQueryElements.call(this,
                "container",
                "liveRegion",
                "dropdown",
                "results",
                "search"
            );
        },

        // abstract
        optionToData: function(element) {
            if (element.is("option")) {
                return {
                    id:element.prop("value"),
                    text:element.text(),
                    element: element.get(),
                    css: element.attr("class"),
                    disabled: element.prop("disabled"),
                    locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                };
            } else if (element.is("optgroup")) {
                return {
                    text:element.attr("label"),
                    children:[],
                    element: element.get(),
                    css: element.attr("class")
                };
            }
        },

        // abstract
        prepareOpts: function (opts) {
            var element, select, idKey, ajaxUrl, self = this;

            element = opts.element;

            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }

            if (select) {
                // these options are not allowed when attached to a select because they are picked up off the element itself
                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                    if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
            }

            opts = $.extend({}, {
                populateResults: function(container, results, query) {
                    var populate, id=this.opts.id, liveRegion=this.liveRegion;

                    populate=function(results, container, depth) {

                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                        results = opts.sortResults(results, container, query);

                        // collect the created nodes for bulk append
                        var nodes = [];
                        for (i = 0, l = results.length; i < l; i = i + 1) {

                            result=results[i];

                            disabled = (result.disabled === true);
                            selectable = (!disabled) && (id(result) !== undefined);

                            compound=result.children && result.children.length > 0;

                            node=$("<li></li>");
                            node.addClass("select2-results-dept-"+depth);
                            node.addClass("select2-result");
                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                            if (disabled) { node.addClass("select2-disabled"); }
                            if (compound) { node.addClass("select2-result-with-children"); }
                            node.addClass(self.opts.formatResultCssClass(result));
                            node.attr("role", "presentation");

                            label=$(document.createElement("div"));
                            label.addClass("select2-result-label");
                            label.attr("id", "select2-result-label-" + nextUid());
                            label.attr("role", "option");

                            formatted=opts.formatResult(result, label, query, self.opts.escapeMarkup);
                            if (formatted!==undefined) {
                                label.html(formatted);
                                node.append(label);
                            }


                            if (compound) {

                                innerContainer=$("<ul></ul>");
                                innerContainer.addClass("select2-result-sub");
                                populate(result.children, innerContainer, depth+1);
                                node.append(innerContainer);
                            }

                            node.data("select2-data", result);
                            nodes.push(node[0]);
                        }

                        // bulk append the created nodes
                        container.append(nodes);
                        liveRegion.text(opts.formatMatches(results.length));
                    };

                    populate(results, container, 0);
                }
            }, $.fn.select2.defaults, opts);

            if (typeof(opts.id) !== "function") {
                idKey = opts.id;
                opts.id = function (e) { return e[idKey]; };
            }

            if ($.isArray(opts.element.data("select2Tags"))) {
                if ("tags" in opts) {
                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                }
                opts.tags=opts.element.data("select2Tags");
            }

            if (select) {
                opts.query = this.bind(function (query) {
                    var data = { results: [], more: false },
                        term = query.term,
                        children, placeholderOption, process;

                    process=function(element, collection) {
                        var group;
                        if (element.is("option")) {
                            if (query.matcher(term, element.text(), element)) {
                                collection.push(self.optionToData(element));
                            }
                        } else if (element.is("optgroup")) {
                            group=self.optionToData(element);
                            element.children().each2(function(i, elm) { process(elm, group.children); });
                            if (group.children.length>0) {
                                collection.push(group);
                            }
                        }
                    };

                    children=element.children();

                    // ignore the placeholder option if there is one
                    if (this.getPlaceholder() !== undefined && children.length > 0) {
                        placeholderOption = this.getPlaceholderOption();
                        if (placeholderOption) {
                            children=children.not(placeholderOption);
                        }
                    }

                    children.each2(function(i, elm) { process(elm, data.results); });

                    query.callback(data);
                });
                // this is needed because inside val() we construct choices from options and their id is hardcoded
                opts.id=function(e) { return e.id; };
            } else {
                if (!("query" in opts)) {

                    if ("ajax" in opts) {
                        ajaxUrl = opts.element.data("ajax-url");
                        if (ajaxUrl && ajaxUrl.length > 0) {
                            opts.ajax.url = ajaxUrl;
                        }
                        opts.query = ajax.call(opts.element, opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        if (opts.createSearchChoice === undefined) {
                            opts.createSearchChoice = function (term) { return {id: $.trim(term), text: $.trim(term)}; };
                        }
                        if (opts.initSelection === undefined) {
                            opts.initSelection = function (element, callback) {
                                var data = [];
                                $(splitVal(element.val(), opts.separator, opts.transformVal)).each(function () {
                                    var obj = { id: this, text: this },
                                        tags = opts.tags;
                                    if ($.isFunction(tags)) tags=tags();
                                    $(tags).each(function() { if (equal(this.id, obj.id)) { obj = this; return false; } });
                                    data.push(obj);
                                });

                                callback(data);
                            };
                        }
                    }
                }
            }
            if (typeof(opts.query) !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }

            if (opts.createSearchChoicePosition === 'top') {
                opts.createSearchChoicePosition = function(list, item) { list.unshift(item); };
            }
            else if (opts.createSearchChoicePosition === 'bottom') {
                opts.createSearchChoicePosition = function(list, item) { list.push(item); };
            }
            else if (typeof(opts.createSearchChoicePosition) !== "function")  {
                throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
            }

            return opts;
        },

        /**
         * Monitor the original element for changes and update select2 accordingly
         */
        // abstract
        monitorSource: function () {
            var el = this.opts.element, observer, self = this;

            el.on("change.select2", this.bind(function (e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));

            this._sync = this.bind(function () {

                // sync enabled state
                var disabled = el.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);

                var readonly = el.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);

                if (this.container) {
                    syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                    this.container.addClass(evaluate(this.opts.containerCssClass, this.opts.element));
                }

                if (this.dropdown) {
                    syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                    this.dropdown.addClass(evaluate(this.opts.dropdownCssClass, this.opts.element));
                }

            });

            // IE8-10 (IE9/10 won't fire propertyChange via attachEventListener)
            if (el.length && el[0].attachEvent) {
                el.each(function() {
                    this.attachEvent("onpropertychange", self._sync);
                });
            }

            // safari, chrome, firefox, IE11
            observer = window.MutationObserver || window.WebKitMutationObserver|| window.MozMutationObserver;
            if (observer !== undefined) {
                if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
                this.propertyObserver = new observer(function (mutations) {
                    $.each(mutations, self._sync);
                });
                this.propertyObserver.observe(el.get(0), { attributes:true, subtree:false });
            }
        },

        // abstract
        triggerSelect: function(data) {
            var evt = $.Event("select2-selecting", { val: this.id(data), object: data, choice: data });
            this.opts.element.trigger(evt);
            return !evt.isDefaultPrevented();
        },

        /**
         * Triggers the change event on the source element
         */
        // abstract
        triggerChange: function (details) {

            details = details || {};
            details= $.extend({}, details, { type: "change", val: this.val() });
            // prevents recursive triggering
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger(details);
            this.opts.element.data("select2-change-triggered", false);

            // some validation frameworks ignore the change event and listen instead to keyup, click for selects
            // so here we trigger the click event manually
            this.opts.element.click();

            // ValidationEngine ignores the change event and listens instead to blur
            // so here we trigger the blur event manually if so desired
            if (this.opts.blurOnChange)
                this.opts.element.blur();
        },

        //abstract
        isInterfaceEnabled: function()
        {
            return this.enabledInterface === true;
        },

        // abstract
        enableInterface: function() {
            var enabled = this._enabled && !this._readonly,
                disabled = !enabled;

            if (enabled === this.enabledInterface) return false;

            this.container.toggleClass("select2-container-disabled", disabled);
            this.close();
            this.enabledInterface = enabled;

            return true;
        },

        // abstract
        enable: function(enabled) {
            if (enabled === undefined) enabled = true;
            if (this._enabled === enabled) return;
            this._enabled = enabled;

            this.opts.element.prop("disabled", !enabled);
            this.enableInterface();
        },

        // abstract
        disable: function() {
            this.enable(false);
        },

        // abstract
        readonly: function(enabled) {
            if (enabled === undefined) enabled = false;
            if (this._readonly === enabled) return;
            this._readonly = enabled;

            this.opts.element.prop("readonly", enabled);
            this.enableInterface();
        },

        // abstract
        opened: function () {
            return (this.container) ? this.container.hasClass("select2-dropdown-open") : false;
        },

        // abstract
        positionDropdown: function() {
            var $dropdown = this.dropdown,
                container = this.container,
                offset = container.offset(),
                height = container.outerHeight(false),
                width = container.outerWidth(false),
                dropHeight = $dropdown.outerHeight(false),
                $window = $(window),
                windowWidth = $window.width(),
                windowHeight = $window.height(),
                viewPortRight = $window.scrollLeft() + windowWidth,
                viewportBottom = $window.scrollTop() + windowHeight,
                dropTop = offset.top + height,
                dropLeft = offset.left,
                enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                enoughRoomAbove = (offset.top - dropHeight) >= $window.scrollTop(),
                dropWidth = $dropdown.outerWidth(false),
                enoughRoomOnRight = function() {
                    return dropLeft + dropWidth <= viewPortRight;
                },
                enoughRoomOnLeft = function() {
                    return offset.left + viewPortRight + container.outerWidth(false)  > dropWidth;
                },
                aboveNow = $dropdown.hasClass("select2-drop-above"),
                bodyOffset,
                above,
                changeDirection,
                css,
                resultsListNode;

            // always prefer the current above/below alignment, unless there is not enough room
            if (aboveNow) {
                above = true;
                if (!enoughRoomAbove && enoughRoomBelow) {
                    changeDirection = true;
                    above = false;
                }
            } else {
                above = false;
                if (!enoughRoomBelow && enoughRoomAbove) {
                    changeDirection = true;
                    above = true;
                }
            }

            //if we are changing direction we need to get positions when dropdown is hidden;
            if (changeDirection) {
                $dropdown.hide();
                offset = this.container.offset();
                height = this.container.outerHeight(false);
                width = this.container.outerWidth(false);
                dropHeight = $dropdown.outerHeight(false);
                viewPortRight = $window.scrollLeft() + windowWidth;
                viewportBottom = $window.scrollTop() + windowHeight;
                dropTop = offset.top + height;
                dropLeft = offset.left;
                dropWidth = $dropdown.outerWidth(false);
                $dropdown.show();

                // fix so the cursor does not move to the left within the search-textbox in IE
                this.focusSearch();
            }

            if (this.opts.dropdownAutoWidth) {
                resultsListNode = $('.select2-results', $dropdown)[0];
                $dropdown.addClass('select2-drop-auto-width');
                $dropdown.css('width', '');
                // Add scrollbar width to dropdown if vertical scrollbar is present
                dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                dropWidth > width ? width = dropWidth : dropWidth = width;
                dropHeight = $dropdown.outerHeight(false);
            }
            else {
                this.container.removeClass('select2-drop-auto-width');
            }

            //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
            //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body.scrollTop(), "enough?", enoughRoomAbove);

            // fix positioning when body has an offset and is not position: static
            if (this.body.css('position') !== 'static') {
                bodyOffset = this.body.offset();
                dropTop -= bodyOffset.top;
                dropLeft -= bodyOffset.left;
            }

            if (!enoughRoomOnRight() && enoughRoomOnLeft()) {
                dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
            }

            css =  {
                left: dropLeft,
                width: width
            };

            if (above) {
                this.container.addClass("select2-drop-above");
                $dropdown.addClass("select2-drop-above");
                dropHeight = $dropdown.outerHeight(false);
                css.top = offset.top - dropHeight;
                css.bottom = 'auto';
            }
            else {
                css.top = dropTop;
                css.bottom = 'auto';
                this.container.removeClass("select2-drop-above");
                $dropdown.removeClass("select2-drop-above");
            }
            css = $.extend(css, evaluate(this.opts.dropdownCss, this.opts.element));

            $dropdown.css(css);
        },

        // abstract
        shouldOpen: function() {
            var event;

            if (this.opened()) return false;

            if (this._enabled === false || this._readonly === true) return false;

            event = $.Event("select2-opening");
            this.opts.element.trigger(event);
            return !event.isDefaultPrevented();
        },

        // abstract
        clearDropdownAlignmentPreference: function() {
            // clear the classes used to figure out the preference of where the dropdown should be opened
            this.container.removeClass("select2-drop-above");
            this.dropdown.removeClass("select2-drop-above");
        },

        /**
         * Opens the dropdown
         *
         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
         */
        // abstract
        open: function () {

            if (!this.shouldOpen()) return false;

            this.opening();

            // Only bind the document mousemove when the dropdown is visible
            $document.on("mousemove.select2Event", function (e) {
                lastMousePosition.x = e.pageX;
                lastMousePosition.y = e.pageY;
            });

            return true;
        },

        /**
         * Performs the opening of the dropdown
         */
        // abstract
        opening: function() {
            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid,
                mask;

            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

            this.clearDropdownAlignmentPreference();

            if(this.dropdown[0] !== this.body.children().last()[0]) {
                this.dropdown.detach().appendTo(this.body);
            }

            // create the dropdown mask if doesn't already exist
            mask = $("#select2-drop-mask");
            if (mask.length === 0) {
                mask = $(document.createElement("div"));
                mask.attr("id","select2-drop-mask").attr("class","select2-drop-mask");
                mask.hide();
                mask.appendTo(this.body);
                mask.on("mousedown touchstart click", function (e) {
                    // Prevent IE from generating a click event on the body
                    reinsertElement(mask);

                    var dropdown = $("#select2-drop"), self;
                    if (dropdown.length > 0) {
                        self=dropdown.data("select2");
                        if (self.opts.selectOnBlur) {
                            self.selectHighlighted({noFocus: true});
                        }
                        self.close();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }

            // ensure the mask is always right before the dropdown
            if (this.dropdown.prev()[0] !== mask[0]) {
                this.dropdown.before(mask);
            }

            // move the global id to the correct dropdown
            $("#select2-drop").removeAttr("id");
            this.dropdown.attr("id", "select2-drop");

            // show the elements
            mask.show();

            this.positionDropdown();
            this.dropdown.show();
            this.positionDropdown();

            this.dropdown.addClass("select2-drop-active");

            // attach listeners to events that can change the position of the container and thus require
            // the position of the dropdown to be updated as well so it does not come unglued from the container
            var that = this;
            this.container.parents().add(window).each(function () {
                $(this).on(resize+" "+scroll+" "+orient, function (e) {
                    if (that.opened()) that.positionDropdown();
                });
            });


        },

        // abstract
        close: function () {
            if (!this.opened()) return;

            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid;

            // unbind event listeners
            this.container.parents().add(window).each(function () { $(this).off(scroll).off(resize).off(orient); });

            this.clearDropdownAlignmentPreference();

            $("#select2-drop-mask").hide();
            this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
            this.results.empty();

            // Now that the dropdown is closed, unbind the global document mousemove event
            $document.off("mousemove.select2Event");

            this.clearSearch();
            this.search.removeClass("select2-active");

            // Remove the aria active descendant for highlighted element
            this.search.removeAttr("aria-activedescendant");
            this.opts.element.trigger($.Event("select2-close"));
        },

        /**
         * Opens control, sets input value, and updates results.
         */
        // abstract
        externalSearch: function (term) {
            this.open();
            this.search.val(term);
            this.updateResults(false);
        },

        // abstract
        clearSearch: function () {

        },

        /**
         * @return {Boolean} Whether or not search value was changed.
         * @private
         */
        prefillNextSearchTerm: function () {
            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if(this.search.val() !== "") {
                return false;
            }

            var nextSearchTerm = this.opts.nextSearchTerm(this.data(), this.lastSearchTerm);
            if(nextSearchTerm !== undefined){
                this.search.val(nextSearchTerm);
                this.search.select();
                return true;
            }

            return false;
        },

        //abstract
        getMaximumSelectionSize: function() {
            return evaluate(this.opts.maximumSelectionSize, this.opts.element);
        },

        // abstract
        ensureHighlightVisible: function () {
            var results = this.results, children, index, child, hb, rb, y, more, topOffset;

            index = this.highlight();

            if (index < 0) return;

            if (index == 0) {

                // if the first element is highlighted scroll all the way to the top,
                // that way any unselectable headers above it will also be scrolled
                // into view

                results.scrollTop(0);
                return;
            }

            children = this.findHighlightableChoices().find('.select2-result-label');

            child = $(children[index]);

            topOffset = (child.offset() || {}).top || 0;

            hb = topOffset + child.outerHeight(true);

            // if this is the last child lets also make sure select2-more-results is visible
            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight(true);
                }
            }

            rb = results.offset().top + results.outerHeight(false);
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = topOffset - results.offset().top;

            // make sure the top of the element is visible
            if (y < 0 && child.css('display') != 'none' ) {
                results.scrollTop(results.scrollTop() + y); // y is negative
            }
        },

        // abstract
        findHighlightableChoices: function() {
            return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
        },

        // abstract
        moveHighlight: function (delta) {
            var choices = this.findHighlightableChoices(),
                index = this.highlight();

            while (index > -1 && index < choices.length) {
                index += delta;
                var choice = $(choices[index]);
                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                    this.highlight(index);
                    break;
                }
            }
        },

        // abstract
        highlight: function (index) {
            var choices = this.findHighlightableChoices(),
                choice,
                data;

            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }

            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;

            this.removeHighlight();

            choice = $(choices[index]);
            choice.addClass("select2-highlighted");

            // ensure assistive technology can determine the active choice
            this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));

            this.ensureHighlightVisible();

            this.liveRegion.text(choice.text());

            data = choice.data("select2-data");
            if (data) {
                this.opts.element.trigger({ type: "select2-highlight", val: this.id(data), choice: data });
            }
        },

        removeHighlight: function() {
            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
        },

        touchMoved: function() {
            this._touchMoved = true;
        },

        clearTouchMoved: function() {
          this._touchMoved = false;
        },

        // abstract
        countSelectableResults: function() {
            return this.findHighlightableChoices().length;
        },

        // abstract
        highlightUnderEvent: function (event) {
            var el = $(event.target).closest(".select2-result-selectable");
            if (el.length > 0 && !el.is(".select2-highlighted")) {
                var choices = this.findHighlightableChoices();
                this.highlight(choices.index(el));
            } else if (el.length == 0) {
                // if we are over an unselectable item remove all highlights
                this.removeHighlight();
            }
        },

        // abstract
        loadMoreIfNeeded: function () {
            var results = this.results,
                more = results.find("li.select2-more-results"),
                below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                page = this.resultsPage + 1,
                self=this,
                term=this.search.val(),
                context=this.context;

            if (more.length === 0) return;
            below = more.offset().top - results.offset().top - results.height();

            if (below <= this.opts.loadMorePadding) {
                more.addClass("select2-active");
                this.opts.query({
                        element: this.opts.element,
                        term: term,
                        page: page,
                        context: context,
                        matcher: this.opts.matcher,
                        callback: this.bind(function (data) {

                    // ignore a response if the select2 has been closed before it was received
                    if (!self.opened()) return;


                    self.opts.populateResults.call(this, results, data.results, {term: term, page: page, context:context});
                    self.postprocessResults(data, false, false);

                    if (data.more===true) {
                        more.detach().appendTo(results).html(self.opts.escapeMarkup(evaluate(self.opts.formatLoadMore, self.opts.element, page+1)));
                        window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                    } else {
                        more.remove();
                    }
                    self.positionDropdown();
                    self.resultsPage = page;
                    self.context = data.context;
                    this.opts.element.trigger({ type: "select2-loaded", items: data });
                })});
            }
        },

        /**
         * Default tokenizer function which does nothing
         */
        tokenize: function() {

        },

        /**
         * @param initial whether or not this is the call to this method right after the dropdown has been opened
         */
        // abstract
        updateResults: function (initial) {
            var search = this.search,
                results = this.results,
                opts = this.opts,
                data,
                self = this,
                input,
                term = search.val(),
                lastTerm = $.data(this.container, "select2-last-term"),
                // sequence number used to drop out-of-order responses
                queryNumber;

            // prevent duplicate queries against the same term
            if (initial !== true && lastTerm && equal(term, lastTerm)) return;

            $.data(this.container, "select2-last-term", term);

            // if the search is currently hidden we do not alter the results
            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                return;
            }

            function postRender() {
                search.removeClass("select2-active");
                self.positionDropdown();
                if (results.find('.select2-no-results,.select2-selection-limit,.select2-searching').length) {
                    self.liveRegion.text(results.text());
                }
                else {
                    self.liveRegion.text(self.opts.formatMatches(results.find('.select2-result-selectable:not(".select2-selected")').length));
                }
            }

            function render(html) {
                results.html(html);
                postRender();
            }

            queryNumber = ++this.queryCount;

            var maxSelSize = this.getMaximumSelectionSize();
            if (maxSelSize >=1) {
                data = this.data();
                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                    render("<li class='select2-selection-limit'>" + evaluate(opts.formatSelectionTooBig, opts.element, maxSelSize) + "</li>");
                    return;
                }
            }

            if (search.val().length < opts.minimumInputLength) {
                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooShort, opts.element, search.val(), opts.minimumInputLength) + "</li>");
                } else {
                    render("");
                }
                if (initial && this.showSearch) this.showSearch(true);
                return;
            }

            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooLong, opts.element, search.val(), opts.maximumInputLength) + "</li>");
                } else {
                    render("");
                }
                return;
            }

            if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                render("<li class='select2-searching'>" + evaluate(opts.formatSearching, opts.element) + "</li>");
            }

            search.addClass("select2-active");

            this.removeHighlight();

            // give the tokenizer a chance to pre-process the input
            input = this.tokenize();
            if (input != undefined && input != null) {
                search.val(input);
            }

            this.resultsPage = 1;

            opts.query({
                element: opts.element,
                    term: search.val(),
                    page: this.resultsPage,
                    context: null,
                    matcher: opts.matcher,
                    callback: this.bind(function (data) {
                var def; // default choice

                // ignore old responses
                if (queryNumber != this.queryCount) {
                  return;
                }

                // ignore a response if the select2 has been closed before it was received
                if (!this.opened()) {
                    this.search.removeClass("select2-active");
                    return;
                }

                // handle ajax error
                if(data.hasError !== undefined && checkFormatter(opts.formatAjaxError, "formatAjaxError")) {
                    render("<li class='select2-ajax-error'>" + evaluate(opts.formatAjaxError, opts.element, data.jqXHR, data.textStatus, data.errorThrown) + "</li>");
                    return;
                }

                // save context, if any
                this.context = (data.context===undefined) ? null : data.context;
                // create a default choice and prepend it to the list
                if (this.opts.createSearchChoice && search.val() !== "") {
                    def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                    if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                        if ($(data.results).filter(
                            function () {
                                return equal(self.id(this), self.id(def));
                            }).length === 0) {
                            this.opts.createSearchChoicePosition(data.results, def);
                        }
                    }
                }

                if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatNoMatches, opts.element, search.val()) + "</li>");
                    this.showSearch(search.val());
                    return;
                }

                results.empty();
                self.opts.populateResults.call(this, results, data.results, {term: search.val(), page: this.resultsPage, context:null});

                if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                    results.append("<li class='select2-more-results'>" + opts.escapeMarkup(evaluate(opts.formatLoadMore, opts.element, this.resultsPage)) + "</li>");
                    window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                }

                this.postprocessResults(data, initial);

                postRender();

                this.opts.element.trigger({ type: "select2-loaded", items: data });
            })});
        },

        // abstract
        cancel: function () {
            this.close();
        },

        // abstract
        blur: function () {
            // if selectOnBlur == true, select the currently highlighted option
            if (this.opts.selectOnBlur)
                this.selectHighlighted({noFocus: true});

            this.close();
            this.container.removeClass("select2-container-active");
            // synonymous to .is(':focus'), which is available in jquery >= 1.6
            if (this.search[0] === document.activeElement) { this.search.blur(); }
            this.clearSearch();
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
        },

        // abstract
        focusSearch: function () {
            focus(this.search);
        },

        // abstract
        selectHighlighted: function (options) {
            if (this._touchMoved) {
              this.clearTouchMoved();
              return;
            }
            var index=this.highlight(),
                highlighted=this.results.find(".select2-highlighted"),
                data = highlighted.closest('.select2-result').data("select2-data");

            if (data) {
                this.highlight(index);
                this.onSelect(data, options);
            } else if (options && options.noFocus) {
                this.close();
            }
        },

        // abstract
        getPlaceholder: function () {
            var placeholderOption;
            return this.opts.element.attr("placeholder") ||
                this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
                this.opts.element.data("placeholder") ||
                this.opts.placeholder ||
                ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
        },

        // abstract
        getPlaceholderOption: function() {
            if (this.select) {
                var firstOption = this.select.children('option').first();
                if (this.opts.placeholderOption !== undefined ) {
                    //Determine the placeholder option based on the specified placeholderOption setting
                    return (this.opts.placeholderOption === "first" && firstOption) ||
                           (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                } else if ($.trim(firstOption.text()) === "" && firstOption.val() === "") {
                    //No explicit placeholder option specified, use the first if it's blank
                    return firstOption;
                }
            }
        },

        /**
         * Get the desired width for the container element.  This is
         * derived first from option `width` passed to select2, then
         * the inline 'style' on the original element, and finally
         * falls back to the jQuery calculated element width.
         */
        // abstract
        initContainerWidth: function () {
            function resolveContainerWidth() {
                var style, attrs, matches, i, l, attr;

                if (this.opts.width === "off") {
                    return null;
                } else if (this.opts.width === "element"){
                    return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                    // check if there is inline style on the element that contains width
                    style = this.opts.element.attr('style');
                    if (typeof(style) === "string") {
                        attrs = style.split(';');
                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
                            attr = attrs[i].replace(/\s/g, '');
                            matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                            if (matches !== null && matches.length >= 1)
                                return matches[1];
                        }
                    }

                    if (this.opts.width === "resolve") {
                        // next check if css('width') can resolve a width that is percent based, this is sometimes possible
                        // when attached to input type=hidden or elements hidden via css
                        style = this.opts.element.css('width');
                        if (style.indexOf("%") > 0) return style;

                        // finally, fallback on the calculated width of the element
                        return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                    }

                    return null;
                } else if ($.isFunction(this.opts.width)) {
                    return this.opts.width();
                } else {
                    return this.opts.width;
               }
            };

            var width = resolveContainerWidth.call(this);
            if (width !== null) {
                this.container.css("width", width);
            }
        }
    });

    SingleSelect2 = clazz(AbstractSelect2, {

        // single

        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container"
            }).html([
                "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>",
                "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>",
                "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>",
                "</a>",
                "<label for='' class='select2-offscreen'></label>",
                "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />",
                "<div class='select2-drop select2-display-none'>",
                "   <div class='select2-search'>",
                "       <label for='' class='select2-offscreen'></label>",
                "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'",
                "       aria-autocomplete='list' />",
                "   </div>",
                "   <ul class='select2-results' role='listbox'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // single
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.focusser.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // single
        opening: function () {
            var el, range, len;

            if (this.opts.minimumResultsForSearch >= 0) {
                this.showSearch(true);
            }

            this.parent.opening.apply(this, arguments);

            if (this.showSearchInput !== false) {
                // IE appends focusser.val() at the end of field :/ so we manually insert it at the beginning using a range
                // all other browsers handle this just fine

                this.search.val(this.focusser.val());
            }
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
                // move the cursor to the end after focussing, otherwise it will be at the beginning and
                // new text will appear *before* focusser.val()
                el = this.search.get(0);
                if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                } else if (el.setSelectionRange) {
                    len = this.search.val().length;
                    el.setSelectionRange(len, len);
                }
            }

            this.prefillNextSearchTerm();

            this.focusser.prop("disabled", true).val("");
            this.updateResults(true);
            this.opts.element.trigger($.Event("select2-open"));
        },

        // single
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);

            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        focus: function () {
            if (this.opened()) {
                this.close();
            } else {
                this.focusser.prop("disabled", false);
                if (this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }
            }
        },

        // single
        isFocused: function () {
            return this.container.hasClass("select2-container-active");
        },

        // single
        cancel: function () {
            this.parent.cancel.apply(this, arguments);
            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        destroy: function() {
            $("label[for='" + this.focusser.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "selection",
                "focusser"
            );
        },

        // single
        initContainer: function () {

            var selection,
                container = this.container,
                dropdown = this.dropdown,
                idSuffix = nextUid(),
                elementLabel;

            if (this.opts.minimumResultsForSearch < 0) {
                this.showSearch(false);
            } else {
                this.showSearch(true);
            }

            this.selection = selection = container.find(".select2-choice");

            this.focusser = container.find(".select2-focusser");

            // add aria associations
            selection.find(".select2-chosen").attr("id", "select2-chosen-"+idSuffix);
            this.focusser.attr("aria-labelledby", "select2-chosen-"+idSuffix);
            this.results.attr("id", "select2-results-"+idSuffix);
            this.search.attr("aria-owns", "select2-results-"+idSuffix);

            // rewrite labels from original element to focusser
            this.focusser.attr("id", "s2id_autogen"+idSuffix);

            elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
            this.opts.element.focus(this.bind(function () { this.focus(); }));

            this.focusser.prev()
                .text(elementLabel.text())
                .attr('for', this.focusser.attr('id'));

            // Ensure the original element retains an accessible name
            var originalTitle = this.opts.element.attr("title");
            this.opts.element.attr("title", (originalTitle || elementLabel.text()));

            this.focusser.attr("tabindex", this.elementTabIndex);

            // write label for search field using the label from the focusser element
            this.search.attr("id", this.focusser.attr('id') + '_search');

            this.search.prev()
                .text($("label[for='" + this.focusser.attr('id') + "']").text())
                .attr('for', this.search.attr('id'));

            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                // filter 229 keyCodes (input method editor is processing key input)
                if (229 == e.keyCode) return;

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                    return;
                }

                switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus: true});
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                }
            }));

            this.search.on("blur", this.bind(function(e) {
                // a workaround for chrome to keep the search field focussed when the scroll bar is used to scroll the dropdown.
                // without this the search field loses focus which is annoying
                if (document.activeElement === this.body.get(0)) {
                    window.setTimeout(this.bind(function() {
                        if (this.opened()) {
                            this.search.focus();
                        }
                    }), 0);
                }
            }));

            this.focusser.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }

                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DOWN || e.which == KEY.UP
                    || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;

                    this.open();
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                    if (this.opts.allowClear) {
                        this.clear();
                    }
                    killEvent(e);
                    return;
                }
            }));


            installKeyUpChangeEvent(this.focusser);
            this.focusser.on("keyup-change input", this.bind(function(e) {
                if (this.opts.minimumResultsForSearch >= 0) {
                    e.stopPropagation();
                    if (this.opened()) return;
                    this.open();
                }
            }));

            selection.on("mousedown touchstart", "abbr", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) {
                    return;
                }

                this.clear();
                killEventImmediately(e);
                this.close();

                if (this.selection) {
                    this.selection.focus();
                }
            }));

            selection.on("mousedown touchstart", this.bind(function (e) {
                // Prevent IE from generating a click event on the body
                reinsertElement(selection);

                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }

                if (this.opened()) {
                    this.close();
                } else if (this.isInterfaceEnabled()) {
                    this.open();
                }

                killEvent(e);
            }));

            dropdown.on("mousedown touchstart", this.bind(function() {
                if (this.opts.shouldFocusInput(this)) {
                    this.search.focus();
                }
            }));

            selection.on("focus", this.bind(function(e) {
                killEvent(e);
            }));

            this.focusser.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            })).on("blur", this.bind(function() {
                if (!this.opened()) {
                    this.container.removeClass("select2-container-active");
                    this.opts.element.trigger($.Event("select2-blur"));
                }
            }));
            this.search.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            }));

            this.initContainerWidth();
            this.opts.element.hide();
            this.setPlaceholder();

        },

        // single
        clear: function(triggerChange) {
            var data=this.selection.data("select2-data");
            if (data) { // guard against queued quick consecutive clicks
                var evt = $.Event("select2-clearing");
                this.opts.element.trigger(evt);
                if (evt.isDefaultPrevented()) {
                    return;
                }
                var placeholderOption = this.getPlaceholderOption();
                this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                this.selection.find(".select2-chosen").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder();

                if (triggerChange !== false){
                    this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                    this.triggerChange({removed:data});
                }
            }
        },

        /**
         * Sets selection based on source element's value
         */
        // single
        initSelection: function () {
            var selected;
            if (this.isPlaceholderOptionSelected()) {
                this.updateSelection(null);
                this.close();
                this.setPlaceholder();
            } else {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(selected){
                    if (selected !== undefined && selected !== null) {
                        self.updateSelection(selected);
                        self.close();
                        self.setPlaceholder();
                        self.lastSearchTerm = self.search.val();
                    }
                });
            }
        },

        isPlaceholderOptionSelected: function() {
            var placeholderOption;
            if (this.getPlaceholder() === undefined) return false; // no placeholder specified so no option should be considered
            return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                || (this.opts.element.val() === "")
                || (this.opts.element.val() === undefined)
                || (this.opts.element.val() === null);
        },

        // single
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {
                    var selected = element.find("option").filter(function() { return this.selected && !this.disabled });
                    // a single select box always has a value, no need to null check 'selected'
                    callback(self.optionToData(selected));
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var id = element.val();
                    //search in data by id, storing the actual matching item
                    var match = null;
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = equal(id, opts.id(el));
                            if (is_match) {
                                match = el;
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            callback(match);
                        }
                    });
                };
            }

            return opts;
        },

        // single
        getPlaceholder: function() {
            // if a placeholder is specified on a single select without a valid placeholder option ignore it
            if (this.select) {
                if (this.getPlaceholderOption() === undefined) {
                    return undefined;
                }
            }

            return this.parent.getPlaceholder.apply(this, arguments);
        },

        // single
        setPlaceholder: function () {
            var placeholder = this.getPlaceholder();

            if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                // check for a placeholder option if attached to a select
                if (this.select && this.getPlaceholderOption() === undefined) return;

                this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                this.selection.addClass("select2-default");

                this.container.removeClass("select2-allowclear");
            }
        },

        // single
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var selected = 0, self = this, showSearchInput = true;

            // find the selected element in the result list

            this.findHighlightableChoices().each2(function (i, elm) {
                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });

            // and highlight it
            if (noHighlightUpdate !== false) {
                if (initial === true && selected >= 0) {
                    this.highlight(selected);
                } else {
                    this.highlight(0);
                }
            }

            // hide the search box if this is the first we got the results and there are enough of them for search

            if (initial === true) {
                var min = this.opts.minimumResultsForSearch;
                if (min >= 0) {
                    this.showSearch(countResults(data.results) >= min);
                }
            }
        },

        // single
        showSearch: function(showSearchInput) {
            if (this.showSearchInput === showSearchInput) return;

            this.showSearchInput = showSearchInput;

            this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
            this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
            //add "select2-with-searchbox" to the container if search box is shown
            $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
        },

        // single
        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            var old = this.opts.element.val(),
                oldData = this.data();

            this.opts.element.val(this.id(data));
            this.updateSelection(data);

            this.opts.element.trigger({ type: "select2-selected", val: this.id(data), choice: data });

            this.lastSearchTerm = this.search.val();
            this.close();

            if ((!options || !options.noFocus) && this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }

            if (!equal(old, this.id(data))) {
                this.triggerChange({ added: data, removed: oldData });
            }
        },

        // single
        updateSelection: function (data) {

            var container=this.selection.find(".select2-chosen"), formatted, cssClass;

            this.selection.data("select2-data", data);

            container.empty();
            if (data !== null) {
                formatted=this.opts.formatSelection(data, container, this.opts.escapeMarkup);
            }
            if (formatted !== undefined) {
                container.append(formatted);
            }
            cssClass=this.opts.formatSelectionCssClass(data, container);
            if (cssClass !== undefined) {
                container.addClass(cssClass);
            }

            this.selection.removeClass("select2-default");

            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.container.addClass("select2-allowclear");
            }
        },

        // single
        val: function () {
            var val,
                triggerChange = false,
                data = null,
                self = this,
                oldData = this.data();

            if (arguments.length === 0) {
                return this.opts.element.val();
            }

            val = arguments[0];

            if (arguments.length > 1) {
                triggerChange = arguments[1];
            }

            if (this.select) {
                this.select
                    .val(val)
                    .find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                        data = self.optionToData(elm);
                        return false;
                    });
                this.updateSelection(data);
                this.setPlaceholder();
                if (triggerChange) {
                    this.triggerChange({added: data, removed:oldData});
                }
            } else {
                // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                if (!val && val !== 0) {
                    this.clear(triggerChange);
                    return;
                }
                if (this.opts.initSelection === undefined) {
                    throw new Error("cannot call val() if initSelection() is not defined");
                }
                this.opts.element.val(val);
                this.opts.initSelection(this.opts.element, function(data){
                    self.opts.element.val(!data ? "" : self.id(data));
                    self.updateSelection(data);
                    self.setPlaceholder();
                    if (triggerChange) {
                        self.triggerChange({added: data, removed:oldData});
                    }
                });
            }
        },

        // single
        clearSearch: function () {
            this.search.val("");
            this.focusser.val("");
        },

        // single
        data: function(value) {
            var data,
                triggerChange = false;

            if (arguments.length === 0) {
                data = this.selection.data("select2-data");
                if (data == undefined) data = null;
                return data;
            } else {
                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }
                if (!value) {
                    this.clear(triggerChange);
                } else {
                    data = this.data();
                    this.opts.element.val(!value ? "" : this.id(value));
                    this.updateSelection(value);
                    if (triggerChange) {
                        this.triggerChange({added: value, removed:data});
                    }
                }
            }
        }
    });

    MultiSelect2 = clazz(AbstractSelect2, {

        // multi
        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container select2-container-multi"
            }).html([
                "<ul class='select2-choices'>",
                "  <li class='select2-search-field'>",
                "    <label for='' class='select2-offscreen'></label>",
                "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                "  </li>",
                "</ul>",
                "<div class='select2-drop select2-drop-multi select2-display-none'>",
                "   <ul class='select2-results'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // multi
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            // TODO validate placeholder is a string if specified
            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {

                    var data = [];

                    element.find("option").filter(function() { return this.selected && !this.disabled }).each2(function (i, elm) {
                        data.push(self.optionToData(elm));
                    });
                    callback(data);
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var ids = splitVal(element.val(), opts.separator, opts.transformVal);
                    //search in data by array of ids, storing matching items in a list
                    var matches = [];
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = $.grep(ids, function(id) {
                                return equal(id, opts.id(el));
                            }).length;
                            if (is_match) {
                                matches.push(el);
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            // reorder matches based on the order they appear in the ids array because right now
                            // they are in the order in which they appear in data array
                            var ordered = [];
                            for (var i = 0; i < ids.length; i++) {
                                var id = ids[i];
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    if (equal(id, opts.id(match))) {
                                        ordered.push(match);
                                        matches.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                            callback(ordered);
                        }
                    });
                };
            }

            return opts;
        },

        // multi
        selectChoice: function (choice) {

            var selected = this.container.find(".select2-search-choice-focus");
            if (selected.length && choice && choice[0] == selected[0]) {

            } else {
                if (selected.length) {
                    this.opts.element.trigger("choice-deselected", selected);
                }
                selected.removeClass("select2-search-choice-focus");
                if (choice && choice.length) {
                    this.close();
                    choice.addClass("select2-search-choice-focus");
                    this.opts.element.trigger("choice-selected", choice);
                }
            }
        },

        // multi
        destroy: function() {
            $("label[for='" + this.search.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "searchContainer",
                "selection"
            );
        },

        // multi
        initContainer: function () {

            var selector = ".select2-choices", selection;

            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);

            var _this = this;
            this.selection.on("click", ".select2-container:not(.select2-container-disabled) .select2-search-choice:not(.select2-locked)", function (e) {
                _this.search[0].focus();
                _this.selectChoice($(this));
            });

            // rewrite labels from original element to focusser
            this.search.attr("id", "s2id_autogen"+nextUid());

            this.search.prev()
                .text($("label[for='" + this.opts.element.attr("id") + "']").text())
                .attr('for', this.search.attr('id'));
            this.opts.element.focus(this.bind(function () { this.focus(); }));

            this.search.on("input paste", this.bind(function() {
                if (this.search.attr('placeholder') && this.search.val().length == 0) return;
                if (!this.isInterfaceEnabled()) return;
                if (!this.opened()) {
                    this.open();
                }
            }));

            this.search.attr("tabindex", this.elementTabIndex);

            this.keydowns = 0;
            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                ++this.keydowns;
                var selected = selection.find(".select2-search-choice-focus");
                var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                var next = selected.next(".select2-search-choice:not(.select2-locked)");
                var pos = getCursorInfo(this.search);

                if (selected.length &&
                    (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                    var selectedChoice = selected;
                    if (e.which == KEY.LEFT && prev.length) {
                        selectedChoice = prev;
                    }
                    else if (e.which == KEY.RIGHT) {
                        selectedChoice = next.length ? next : null;
                    }
                    else if (e.which === KEY.BACKSPACE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = prev.length ? prev : next;
                        }
                    } else if (e.which == KEY.DELETE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = next.length ? next : null;
                        }
                    } else if (e.which == KEY.ENTER) {
                        selectedChoice = null;
                    }

                    this.selectChoice(selectedChoice);
                    killEvent(e);
                    if (!selectedChoice || !selectedChoice.length) {
                        this.open();
                    }
                    return;
                } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                    || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                    this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                    killEvent(e);
                    return;
                } else {
                    this.selectChoice(null);
                }

                if (this.opened()) {
                    switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus:true});
                        this.close();
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                    }
                }

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                 || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }

                if (e.which === KEY.ENTER) {
                    if (this.opts.openOnEnter === false) {
                        return;
                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                }

                this.open();

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                }

                if (e.which === KEY.ENTER) {
                    // prevent form from being submitted
                    killEvent(e);
                }

            }));

            this.search.on("keyup", this.bind(function (e) {
                this.keydowns = 0;
                this.resizeSearch();
            })
            );

            this.search.on("blur", this.bind(function(e) {
                this.container.removeClass("select2-container-active");
                this.search.removeClass("select2-focused");
                this.selectChoice(null);
                if (!this.opened()) this.clearSearch();
                e.stopImmediatePropagation();
                this.opts.element.trigger($.Event("select2-blur"));
            }));

            this.container.on("click", selector, this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                if ($(e.target).closest(".select2-search-choice").length > 0) {
                    // clicked inside a select2 search choice, do not open
                    return;
                }
                this.selectChoice(null);
                this.clearPlaceholder();
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));

            this.container.on("focus", selector, this.bind(function () {
                if (!this.isInterfaceEnabled()) return;
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
                this.dropdown.addClass("select2-drop-active");
                this.clearPlaceholder();
            }));

            this.initContainerWidth();
            this.opts.element.hide();

            // set the placeholder if necessary
            this.clearSearch();
        },

        // multi
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.search.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // multi
        initSelection: function () {
            var data;
            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                this.updateSelection([]);
                this.close();
                // set the placeholder if necessary
                this.clearSearch();
            }
            if (this.select || this.opts.element.val() !== "") {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(data){
                    if (data !== undefined && data !== null) {
                        self.updateSelection(data);
                        self.close();
                        // set the placeholder if necessary
                        self.clearSearch();
                    }
                });
            }
        },

        // multi
        clearSearch: function () {
            var placeholder = this.getPlaceholder(),
                maxWidth = this.getMaxSearchWidth();

            if (placeholder !== undefined  && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                this.search.val(placeholder).addClass("select2-default");
                // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                // we could call this.resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
                this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
            } else {
                this.search.val("").width(10);
            }
        },

        // multi
        clearPlaceholder: function () {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },

        // multi
        opening: function () {
            this.clearPlaceholder(); // should be done before super so placeholder is not used to search
            this.resizeSearch();

            this.parent.opening.apply(this, arguments);

            this.focusSearch();

            this.prefillNextSearchTerm();
            this.updateResults(true);

            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
            }
            this.opts.element.trigger($.Event("select2-open"));
        },

        // multi
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        // multi
        focus: function () {
            this.close();
            this.search.focus();
        },

        // multi
        isFocused: function () {
            return this.search.hasClass("select2-focused");
        },

        // multi
        updateSelection: function (data) {
            var ids = {}, filtered = [], self = this;

            // filter out duplicates
            $(data).each(function () {
                if (!(self.id(this) in ids)) {
                    ids[self.id(this)] = 0;
                    filtered.push(this);
                }
            });

            this.selection.find(".select2-search-choice").remove();
            this.addSelectedChoice(filtered);
            self.postprocessResults();
        },

        // multi
        tokenize: function() {
            var input = this.search.val();
            input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
            if (input != null && input != undefined) {
                this.search.val(input);
                if (input.length > 0) {
                    this.open();
                }
            }

        },

        // multi
        onSelect: function (data, options) {

            if (!this.triggerSelect(data) || data.text === "") { return; }

            this.addSelectedChoice(data);

            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });

            // keep track of the search's value before it gets cleared
            this.lastSearchTerm = this.search.val();

            this.clearSearch();
            this.updateResults();

            if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect===true);

            if (this.opts.closeOnSelect) {
                this.close();
                this.search.width(10);
            } else {
                if (this.countSelectableResults()>0) {
                    this.search.width(10);
                    this.resizeSearch();
                    if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                        // if we reached max selection size repaint the results so choices
                        // are replaced with the max selection reached message
                        this.updateResults(true);
                    } else {
                        // initializes search's value with nextSearchTerm and update search result
                        if (this.prefillNextSearchTerm()) {
                            this.updateResults();
                        }
                    }
                    this.positionDropdown();
                } else {
                    // if nothing left to select close
                    this.close();
                    this.search.width(10);
                }
            }

            // since its not possible to select an element that has already been
            // added we do not need to check if this is a new element before firing change
            this.triggerChange({ added: data });

            if (!options || !options.noFocus)
                this.focusSearch();
        },

        // multi
        cancel: function () {
            this.close();
            this.focusSearch();
        },

        addSelectedChoice: function (data) {
            var val = this.getVal(), self = this;
            $(data).each(function () {
                val.push(self.createChoice(this));
            });
            this.setVal(val);
        },
        
        createChoice: function (data) {
            var enableChoice = !data.locked,
                enabledItem = $(
                    "<li class='select2-search-choice'>" +
                    "    <div></div>" +
                    "    <a href='#' class='select2-search-choice-close' tabindex='-1'></a>" +
                    "</li>"),
                disabledItem = $(
                    "<li class='select2-search-choice select2-locked'>" +
                    "<div></div>" +
                    "</li>");
            var choice = enableChoice ? enabledItem : disabledItem,
                id = this.id(data),
                formatted,
                cssClass;

            formatted=this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
            if (formatted != undefined) {
                choice.find("div").replaceWith($("<div></div>").html(formatted));
            }
            cssClass=this.opts.formatSelectionCssClass(data, choice.find("div"));
            if (cssClass != undefined) {
                choice.addClass(cssClass);
            }

            if(enableChoice){
              choice.find(".select2-search-choice-close")
                  .on("mousedown", killEvent)
                  .on("click dblclick", this.bind(function (e) {
                  if (!this.isInterfaceEnabled()) return;

                  this.unselect($(e.target));
                  this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                  killEvent(e);
                  this.close();
                  this.focusSearch();
              })).on("focus", this.bind(function () {
                  if (!this.isInterfaceEnabled()) return;
                  this.container.addClass("select2-container-active");
                  this.dropdown.addClass("select2-drop-active");
              }));
            }

            choice.data("select2-data", data);
            choice.insertBefore(this.searchContainer);

            return id;
        },

        // multi
        unselect: function (selected) {
            var val = this.getVal(),
                data,
                index;
            selected = selected.closest(".select2-search-choice");

            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }

            data = selected.data("select2-data");

            if (!data) {
                // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
                // and invoked on an element already removed
                return;
            }

            var evt = $.Event("select2-removing");
            evt.val = this.id(data);
            evt.choice = data;
            this.opts.element.trigger(evt);

            if (evt.isDefaultPrevented()) {
                return false;
            }

            while((index = indexOf(this.id(data), val)) >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }

            selected.remove();

            this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
            this.triggerChange({ removed: data });

            return true;
        },

        // multi
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var val = this.getVal(),
                choices = this.results.find(".select2-result"),
                compound = this.results.find(".select2-result-with-children"),
                self = this;

            choices.each2(function (i, choice) {
                var id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-selected");
                    // mark all children of the selected parent as selected
                    choice.find(".select2-result-selectable").addClass("select2-selected");
                }
            });

            compound.each2(function(i, choice) {
                // hide an optgroup if it doesn't have any selectable children
                if (!choice.is('.select2-result-selectable')
                    && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                    choice.addClass("select2-selected");
                }
            });

            if (this.highlight() == -1 && noHighlightUpdate !== false && this.opts.closeOnSelect === true){
                self.highlight(0);
            }

            //If all results are chosen render formatNoMatches
            if(!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0){
                if(!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                    if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                        this.results.append("<li class='select2-no-results'>" + evaluate(self.opts.formatNoMatches, self.opts.element, self.search.val()) + "</li>");
                    }
                }
            }

        },

        // multi
        getMaxSearchWidth: function() {
            return this.selection.width() - getSideBorderPadding(this.search);
        },

        // multi
        resizeSearch: function () {
            var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                sideBorderPadding = getSideBorderPadding(this.search);

            minimumWidth = measureTextWidth(this.search) + 10;

            left = this.search.offset().left;

            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;

            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth < 40) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth <= 0) {
              searchWidth = minimumWidth;
            }

            this.search.width(Math.floor(searchWidth));
        },

        // multi
        getVal: function () {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, this.opts.separator, this.opts.transformVal);
            }
        },

        // multi
        setVal: function (val) {
            if (this.select) {
                this.select.val(val);
            } else {
                var unique = [], valMap = {};
                // filter out duplicates
                $(val).each(function () {
                    if (!(this in valMap)) {
                        unique.push(this);
                        valMap[this] = 0;
                    }
                });
                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
            }
        },

        // multi
        buildChangeDetails: function (old, current) {
            var current = current.slice(0),
                old = old.slice(0);

            // remove intersection from each array
            for (var i = 0; i < current.length; i++) {
                for (var j = 0; j < old.length; j++) {
                    if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                        current.splice(i, 1);
                        i--;
                        old.splice(j, 1);
                        break;
                    }
                }
            }

            return {added: current, removed: old};
        },


        // multi
        val: function (val, triggerChange) {
            var oldData, self=this;

            if (arguments.length === 0) {
                return this.getVal();
            }

            oldData=this.data();
            if (!oldData.length) oldData=[];

            // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
            if (!val && val !== 0) {
                this.opts.element.val("");
                this.updateSelection([]);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange({added: this.data(), removed: oldData});
                }
                return;
            }

            // val is a list of ids
            this.setVal(val);

            if (this.select) {
                this.opts.initSelection(this.select, this.bind(this.updateSelection));
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                }
            } else {
                if (this.opts.initSelection === undefined) {
                    throw new Error("val() cannot be called if initSelection() is not defined");
                }

                this.opts.initSelection(this.opts.element, function(data){
                    var ids=$.map(data, self.id);
                    self.setVal(ids);
                    self.updateSelection(data);
                    self.clearSearch();
                    if (triggerChange) {
                        self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                    }
                });
            }
            this.clearSearch();
        },

        // multi
        onSortStart: function() {
            if (this.select) {
                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
            }

            // collapse search field into 0 width so its container can be collapsed as well
            this.search.width(0);
            // hide the container
            this.searchContainer.hide();
        },

        // multi
        onSortEnd:function() {

            var val=[], self=this;

            // show search and move it to the end of the list
            this.searchContainer.show();
            // make sure the search container is the last item in the list
            this.searchContainer.appendTo(this.searchContainer.parent());
            // since we collapsed the width in dragStarted, we resize it here
            this.resizeSearch();

            // update selection
            this.selection.find(".select2-search-choice").each(function() {
                val.push(self.opts.id($(this).data("select2-data")));
            });
            this.setVal(val);
            this.triggerChange();
        },

        // multi
        data: function(values, triggerChange) {
            var self=this, ids, old;
            if (arguments.length === 0) {
                 return this.selection
                     .children(".select2-search-choice")
                     .map(function() { return $(this).data("select2-data"); })
                     .get();
            } else {
                old = this.data();
                if (!values) { values = []; }
                ids = $.map(values, function(e) { return self.opts.id(e); });
                this.setVal(ids);
                this.updateSelection(values);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(old, this.data()));
                }
            }
        }
    });

    $.fn.select2 = function () {

        var args = Array.prototype.slice.call(arguments, 0),
            opts,
            select2,
            method, value, multiple,
            allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
            valueMethods = ["opened", "isFocused", "container", "dropdown"],
            propertyMethods = ["val", "data"],
            methodsMap = { search: "externalSearch" };

        this.each(function () {
            if (args.length === 0 || typeof(args[0]) === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.prop("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) {opts.multiple = multiple = true;}
                }

                select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
                select2.init(opts);
            } else if (typeof(args[0]) === "string") {

                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }

                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;

                method=args[0];

                if (method === "container") {
                    value = select2.container;
                } else if (method === "dropdown") {
                    value = select2.dropdown;
                } else {
                    if (methodsMap[method]) method = methodsMap[method];

                    value = select2[method].apply(select2, args.slice(1));
                }
                if (indexOf(args[0], valueMethods) >= 0
                    || (indexOf(args[0], propertyMethods) >= 0 && args.length == 1)) {
                    return false; // abort the iteration, ready to return first matched value
                }
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return (value === undefined) ? this : value;
    };

    // plugin defaults, accessible to users
    $.fn.select2.defaults = {
        width: "copy",
        loadMorePadding: 0,
        closeOnSelect: true,
        openOnEnter: true,
        containerCss: {},
        dropdownCss: {},
        containerCssClass: "",
        dropdownCssClass: "",
        formatResult: function(result, container, query, escapeMarkup) {
            var markup=[];
            markMatch(this.text(result), query.term, markup, escapeMarkup);
            return markup.join("");
        },
        transformVal: function(val) {
            return $.trim(val);
        },
        formatSelection: function (data, container, escapeMarkup) {
            return data ? escapeMarkup(this.text(data)) : undefined;
        },
        sortResults: function (results, container, query) {
            return results;
        },
        formatResultCssClass: function(data) {return data.css;},
        formatSelectionCssClass: function(data, container) {return undefined;},
        minimumResultsForSearch: 0,
        minimumInputLength: 0,
        maximumInputLength: null,
        maximumSelectionSize: 0,
        id: function (e) { return e == undefined ? null : e.id; },
        text: function (e) {
          if (e && this.data && this.data.text) {
            if ($.isFunction(this.data.text)) {
              return this.data.text(e);
            } else {
              return e[this.data.text];
            }
          } else {
            return e.text;
          }
        },
        matcher: function(term, text) {
            return stripDiacritics(''+text).toUpperCase().indexOf(stripDiacritics(''+term).toUpperCase()) >= 0;
        },
        separator: ",",
        tokenSeparators: [],
        tokenizer: defaultTokenizer,
        escapeMarkup: defaultEscapeMarkup,
        blurOnChange: false,
        selectOnBlur: false,
        adaptContainerCssClass: function(c) { return c; },
        adaptDropdownCssClass: function(c) { return null; },
        nextSearchTerm: function(selectedObject, currentSearchTerm) { return undefined; },
        searchInputPlaceholder: '',
        createSearchChoicePosition: 'top',
        shouldFocusInput: function (instance) {
            // Attempt to detect touch devices
            var supportsTouchEvents = (('ontouchstart' in window) ||
                                       (navigator.msMaxTouchPoints > 0));

            // Only devices which support touch events should be special cased
            if (!supportsTouchEvents) {
                return true;
            }

            // Never focus the input if search is disabled
            if (instance.opts.minimumResultsForSearch < 0) {
                return false;
            }

            return true;
        }
    };

    $.fn.select2.locales = [];

    $.fn.select2.locales['en'] = {
         formatMatches: function (matches) { if (matches === 1) { return "One result is available, press enter to select it."; } return matches + " results are available, use up and down arrow keys to navigate."; },
         formatNoMatches: function () { return "No matches found"; },
         formatAjaxError: function (jqXHR, textStatus, errorThrown) { return "Loading failed"; },
         formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " or more character" + (n == 1 ? "" : "s"); },
         formatInputTooLong: function (input, max) { var n = input.length - max; return "Please delete " + n + " character" + (n == 1 ? "" : "s"); },
         formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
         formatLoadMore: function (pageNumber) { return "Loading more results…"; },
         formatSearching: function () { return "Searching…"; }
    };

    $.extend($.fn.select2.defaults, $.fn.select2.locales['en']);

    $.fn.select2.ajaxDefaults = {
        transport: $.ajax,
        params: {
            type: "GET",
            cache: false,
            dataType: "json"
        }
    };

    // exports
    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        }, util: {
            debounce: debounce,
            markMatch: markMatch,
            escapeMarkup: defaultEscapeMarkup,
            stripDiacritics: stripDiacritics
        }, "class": {
            "abstract": AbstractSelect2,
            "single": SingleSelect2,
            "multi": MultiSelect2
        }
    };

}(jQuery));

/*
 * Mentions Input
 * Version 1.0.2
 * Written by: Kenneth Auchenberg (Podio)
 *
 * Using underscore.js
 *
 * License: MIT License - http://www.opensource.org/licenses/mit-license.php
 */

(function ($, _, undefined) {

    // Settings
    var KEY = { BACKSPACE : 8, TAB : 9, RETURN : 13, ESC : 27, LEFT : 37, UP : 38, RIGHT : 39, DOWN : 40, COMMA : 188, SPACE : 32, HOME : 36, END : 35 }; // Keys "enum"

    //Default settings
    var defaultSettings = {
        triggerChar   : '@', //Char that respond to event
        onDataRequest : $.noop, //Function where we can search the data
        minChars      : 2, //Minimum chars to fire the event
        allowRepeat   : false, //Allow repeat mentions
        showAvatars   : true, //Show the avatars
        elastic       : true, //Grow the textarea automatically
        onCaret       : false,
        classes       : {
            autoCompleteItemActive : "active" //Classes to apply in each item
        },
        templates     : {
            wrapper                    : _.template('<div class="mentions-input-box"></div>'),
            autocompleteList           : _.template('<div class="mentions-autocomplete-list"></div>'),
            autocompleteListItem       : _.template('<li data-ref-id="<%= id %>" data-ref-type="<%= type %>" data-display="<%= display %>"><%= content %></li>'),
            autocompleteListItemAvatar : _.template('<img src="<%= avatar %>" />'),
            autocompleteListItemIcon   : _.template('<div class="icon <%= icon %>"></div>'),
            mentionsOverlay            : _.template('<div class="mentions"><div></div></div>'),
            mentionItemSyntax          : _.template('@[<%= value %>](<%= type %>:<%= id %>)'),
            mentionItemHighlight       : _.template('<strong><span><%= value %></span></strong>')
        }
    };

    //Class util
    var utils = {
        //Encodes the character with _.escape function (undersocre)
        htmlEncode       : function (str) {
            return _.escape(str);
        },
        //Encodes the character to be used with RegExp
        regexpEncode     : function (str) {
            return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        },
        //
        highlightTerm    : function (value, term) {
            if (!term && !term.length) {
                return value;
            }
            return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<b>$1</b>");
        },
        //Sets the caret in a valid position
        setCaratPosition : function (domNode, caretPos) {
            if (domNode.createTextRange) {
                var range = domNode.createTextRange();
                range.move('character', caretPos);
                range.select();
            } else {
                if (domNode.selectionStart) {
                    domNode.focus();
                    domNode.setSelectionRange(caretPos, caretPos);
                } else {
                    domNode.focus();
                }
            }
        },
        //Deletes the white spaces
        rtrim: function(string) {
            return string.replace(/\s+$/,"");
        }
    };

    //Main class of MentionsInput plugin
    var MentionsInput = function (settings) {

        var domInput,
            elmInputBox,
            elmInputWrapper,
            elmAutocompleteList,
            elmWrapperBox,
            elmMentionsOverlay,
            elmActiveAutoCompleteItem,
            mentionsCollection = [],
            autocompleteItemCollection = {},
            inputBuffer = [],
            currentDataQuery = '';

        //Mix the default setting with the users settings
        settings = $.extend(true, {}, defaultSettings, settings );

        //Initializes the text area target
        function initTextarea() {
            elmInputBox = $(domInput); //Get the text area target

            //If the text area is already configured, return
            if (elmInputBox.attr('data-mentions-input') === 'true') {
                return;
            }

            elmInputWrapper = elmInputBox.parent(); //Get the DOM element parent
            elmWrapperBox = $(settings.templates.wrapper());
            elmInputBox.wrapAll(elmWrapperBox); //Wrap all the text area into the div elmWrapperBox
            elmWrapperBox = elmInputWrapper.find('> div.mentions-input-box'); //Obtains the div elmWrapperBox that now contains the text area

            elmInputBox.attr('data-mentions-input', 'true'); //Sets the attribute data-mentions-input to true -> Defines if the text area is already configured
            elmInputBox.bind('keydown', onInputBoxKeyDown); //Bind the keydown event to the text area
            elmInputBox.bind('keypress', onInputBoxKeyPress); //Bind the keypress event to the text area
            elmInputBox.bind('click', onInputBoxClick); //Bind the click event to the text area
            elmInputBox.bind('blur', onInputBoxBlur); //Bind the blur event to the text area

            if (navigator.userAgent.indexOf("MSIE 8") > -1) {
                elmInputBox.bind('propertychange', onInputBoxInput); //IE8 won't fire the input event, so let's bind to the propertychange
            } else {
                elmInputBox.bind('input', onInputBoxInput); //Bind the input event to the text area
            }

        }

        //Initializes the autocomplete list, append to elmWrapperBox and delegate the mousedown event to li elements
        function initAutocomplete() {
            elmAutocompleteList = $(settings.templates.autocompleteList()); //Get the HTML code for the list
            elmAutocompleteList.appendTo(elmWrapperBox); //Append to elmWrapperBox element
            elmAutocompleteList.delegate('li', 'mousedown', onAutoCompleteItemClick); //Delegate the event
        }

        //Initializes the mentions' overlay
        function initMentionsOverlay() {
            elmMentionsOverlay = $(settings.templates.mentionsOverlay()); //Get the HTML code of the mentions' overlay
            elmMentionsOverlay.prependTo(elmWrapperBox); //Insert into elmWrapperBox the mentions overlay
        }

        //Updates the values of the main variables
        function updateValues() {
            var syntaxMessage = getInputBoxValue(); //Get the actual value of the text area

            _.each(mentionsCollection, function (mention) {
                var textSyntax = settings.templates.mentionItemSyntax(mention);
                syntaxMessage = syntaxMessage.replace(new RegExp(utils.regexpEncode(mention.value), 'g'), textSyntax);
            });

            var mentionText = utils.htmlEncode(syntaxMessage); //Encode the syntaxMessage

            _.each(mentionsCollection, function (mention) {
                var formattedMention = _.extend({}, mention, {value: utils.htmlEncode(mention.value)});
                var textSyntax = settings.templates.mentionItemSyntax(formattedMention);
                var textHighlight = settings.templates.mentionItemHighlight(formattedMention);

                mentionText = mentionText.replace(new RegExp(utils.regexpEncode(textSyntax), 'g'), textHighlight);
            });

            mentionText = mentionText.replace(/\n/g, '<br />'); //Replace the escape character for <br />
            mentionText = mentionText.replace(/ {2}/g, '&nbsp; '); //Replace the 2 preceding token to &nbsp;

            elmInputBox.data('messageText', syntaxMessage); //Save the messageText to elmInputBox
            elmInputBox.trigger('updated');
            elmMentionsOverlay.find('div').html(mentionText); //Insert into a div of the elmMentionsOverlay the mention text
        }

        //Cleans the buffer
        function resetBuffer() {
            inputBuffer = [];
        }

        //Updates the mentions collection
        function updateMentionsCollection() {
            var inputText = getInputBoxValue(); //Get the actual value of text area

            //Returns the values that doesn't match the condition
            mentionsCollection = _.reject(mentionsCollection, function (mention, index) {
                return !mention.value || inputText.indexOf(mention.value) == -1;
            });
            mentionsCollection = _.compact(mentionsCollection); //Delete all the falsy values of the array and return the new array
        }

        //Adds mention to mentions collections
        function addMention(mention) {

            var currentMessage = getInputBoxValue(); //Get the actual value of the text area

            // Using a regex to figure out positions
            var regex = new RegExp("\\" + settings.triggerChar + currentDataQuery, "gi");
            regex.exec(currentMessage); //Executes a search for a match in a specified string. Returns a result array, or null

            var startCaretPosition = regex.lastIndex - currentDataQuery.length - 1; //Set the star caret position
            var currentCaretPosition = regex.lastIndex; //Set the current caret position

            var start = currentMessage.substr(0, startCaretPosition);
            var end = currentMessage.substr(currentCaretPosition, currentMessage.length);
            var startEndIndex = (start + mention.value).length + 1;

            // See if there's the same mention in the list
            if( !_.find(mentionsCollection, function (object) { return object.id == mention.id; }) ) {
                mentionsCollection.push(mention);//Add the mention to mentionsColletions
            }

            // Cleaning before inserting the value, otherwise auto-complete would be triggered with "old" inputbuffer
            resetBuffer();
            currentDataQuery = '';
            hideAutoComplete();

            // Mentions and syntax message
            var updatedMessageText = start + mention.value + ' ' + end;
            elmInputBox.val(updatedMessageText); //Set the value to the txt area
            elmInputBox.trigger('mention');
            updateValues();

            // Set correct focus and selection
            elmInputBox.focus();
            utils.setCaratPosition(elmInputBox[0], startEndIndex);
        }

        //Gets the actual value of the text area without white spaces from the beginning and end of the value
        function getInputBoxValue() {
            return $.trim(elmInputBox.val());
        }

        // This is taken straight from live (as of Sep 2012) GitHub code. The
        // technique is known around the web. Just google it. Github's is quite
        // succint though. NOTE: relies on selectionEnd, which as far as IE is concerned,
        // it'll only work on 9+. Good news is nothing will happen if the browser
        // doesn't support it.
        function textareaSelectionPosition($el) {
            var a, b, c, d, e, f, g, h, i, j, k;
            if (!(i = $el[0])) return;
            if (!$(i).is("textarea")) return;
            if (i.selectionEnd == null) return;
            g = {
                position: "absolute",
                overflow: "auto",
                whiteSpace: "pre-wrap",
                wordWrap: "break-word",
                boxSizing: "content-box",
                top: 0,
                left: -9999
            }, h = ["boxSizing", "fontFamily", "fontSize", "fontStyle", "fontVariant", "fontWeight", "height", "letterSpacing", "lineHeight", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "textDecoration", "textIndent", "textTransform", "width", "word-spacing"];
            for (j = 0, k = h.length; j < k; j++) e = h[j], g[e] = $(i).css(e);
            return c = document.createElement("div"), $(c).css(g), $(i).after(c), b = document.createTextNode(i.value.substring(0, i.selectionEnd)), a = document.createTextNode(i.value.substring(i.selectionEnd)), d = document.createElement("span"), d.innerHTML = "&nbsp;", c.appendChild(b), c.appendChild(d), c.appendChild(a), c.scrollTop = i.scrollTop, f = $(d).position(), $(c).remove(), f
        }

        //Scrolls back to the input after autocomplete if the window has scrolled past the input
        function scrollToInput() {
            var elmDistanceFromTop = $(elmInputBox).offset().top; //input offset
            var bodyDistanceFromTop = $('body').offset().top; //body offset
            var distanceScrolled = $(window).scrollTop(); //distance scrolled

            if (distanceScrolled > elmDistanceFromTop) {
                //subtracts body distance to handle fixed headers
                $(window).scrollTop(elmDistanceFromTop - bodyDistanceFromTop);
            }

        }

        //Takes the click event when the user select a item of the dropdown
        function onAutoCompleteItemClick(e) {
            var elmTarget = $(this); //Get the item selected
            var mention = autocompleteItemCollection[elmTarget.attr('data-uid')]; //Obtains the mention

            addMention(mention);

            scrollToInput();

            return false;
        }

        //Takes the click event on text area
        function onInputBoxClick(e) {
            resetBuffer();
        }

        //Takes the blur event on text area
        function onInputBoxBlur(e) {
            hideAutoComplete();
        }

        //Takes the input event when users write or delete something
        function onInputBoxInput(e) {
            updateValues();
            updateMentionsCollection();

            var triggerCharIndex = _.lastIndexOf(inputBuffer, settings.triggerChar); //Returns the last match of the triggerChar in the inputBuffer
            if (triggerCharIndex > -1) { //If the triggerChar is present in the inputBuffer array
                currentDataQuery = inputBuffer.slice(triggerCharIndex + 1).join(''); //Gets the currentDataQuery
                currentDataQuery = utils.rtrim(currentDataQuery); //Deletes the whitespaces

                _.defer(_.bind(doSearch, this, currentDataQuery)); //Invoking the function doSearch ( Bind the function to this)
            }
        }

        //Takes the keypress event
        function onInputBoxKeyPress(e) {
            if(e.keyCode !== KEY.BACKSPACE) { //If the key pressed is not the backspace
                var typedValue = String.fromCharCode(e.which || e.keyCode); //Takes the string that represent this CharCode
                inputBuffer.push(typedValue); //Push the value pressed into inputBuffer
            }
        }

        //Takes the keydown event
        function onInputBoxKeyDown(e) {

            // This also matches HOME/END on OSX which is CMD+LEFT, CMD+RIGHT
            if (e.keyCode === KEY.LEFT || e.keyCode === KEY.RIGHT || e.keyCode === KEY.HOME || e.keyCode === KEY.END) {
                // Defer execution to ensure carat pos has changed after HOME/END keys then call the resetBuffer function
                _.defer(resetBuffer);

                // IE9 doesn't fire the oninput event when backspace or delete is pressed. This causes the highlighting
                // to stay on the screen whenever backspace is pressed after a highlighed word. This is simply a hack
                // to force updateValues() to fire when backspace/delete is pressed in IE9.
                if (navigator.userAgent.indexOf("MSIE 9") > -1) {
                    _.defer(updateValues); //Call the updateValues function
                }

                return;
            }

            //If the key pressed was the backspace
            if (e.keyCode === KEY.BACKSPACE) {
                inputBuffer = inputBuffer.slice(0, -1 + inputBuffer.length); // Can't use splice, not available in IE
                return;
            }

            //If the elmAutocompleteList is hidden
            if (!elmAutocompleteList.is(':visible')) {
                return true;
            }

            switch (e.keyCode) {
                case KEY.UP: //If the key pressed was UP or DOWN
                case KEY.DOWN:
                    var elmCurrentAutoCompleteItem = null;
                    if (e.keyCode === KEY.DOWN) { //If the key pressed was DOWN
                        if (elmActiveAutoCompleteItem && elmActiveAutoCompleteItem.length) { //If elmActiveAutoCompleteItem exits
                            elmCurrentAutoCompleteItem = elmActiveAutoCompleteItem.next(); //Gets the next li element in the list
                        } else {
                            elmCurrentAutoCompleteItem = elmAutocompleteList.find('li').first(); //Gets the first li element found
                        }
                    } else {
                        elmCurrentAutoCompleteItem = $(elmActiveAutoCompleteItem).prev(); //The key pressed was UP and gets the previous li element
                    }

                    if (elmCurrentAutoCompleteItem.length) {
                        selectAutoCompleteItem(elmCurrentAutoCompleteItem);
                    }

                    return false;

                case KEY.RETURN: //If the key pressed was RETURN or TAB
                case KEY.TAB:
                    if (elmActiveAutoCompleteItem && elmActiveAutoCompleteItem.length) { //If the elmActiveAutoCompleteItem exists
                        elmActiveAutoCompleteItem.trigger('mousedown'); //Calls the mousedown event
                        return false;
                    }

                    break;
            }

            return true;
        }

        //Hides the autoomplete
        function hideAutoComplete() {
            elmActiveAutoCompleteItem = null;
            elmAutocompleteList.empty().hide();
        }

        //Selects the item in the autocomplete list
        function selectAutoCompleteItem(elmItem) {
            elmItem.addClass(settings.classes.autoCompleteItemActive); //Add the class active to item
            elmItem.siblings().removeClass(settings.classes.autoCompleteItemActive); //Gets all li elements in autocomplete list and remove the class active

            elmActiveAutoCompleteItem = elmItem; //Sets the item to elmActiveAutoCompleteItem
        }

        //Populates dropdown
        function populateDropdown(query, results) {
            elmAutocompleteList.show(); //Shows the autocomplete list

            if(!settings.allowRepeat) {
                // Filter items that has already been mentioned
                var mentionValues = _.pluck(mentionsCollection, 'value');
                results = _.reject(results, function (item) {
                    return _.include(mentionValues, item.name);
                });
            }

            if (!results.length) { //If there are not elements hide the autocomplete list
                hideAutoComplete();
                return;
            }

            elmAutocompleteList.empty(); //Remove all li elements in autocomplete list
            var elmDropDownList = $("<ul>").appendTo(elmAutocompleteList).hide(); //Inserts a ul element to autocomplete div and hide it

            _.each(results, function (item, index) {
                var itemUid = _.uniqueId('mention_'); //Gets the item with unique id

                autocompleteItemCollection[itemUid] = _.extend({}, item, {value: item.name}); //Inserts the new item to autocompleteItemCollection

                var elmListItem = $(settings.templates.autocompleteListItem({
                    'id'      : utils.htmlEncode(item.id),
                    'display' : utils.htmlEncode(item.name),
                    'type'    : utils.htmlEncode(item.type),
                    'content' : utils.highlightTerm(utils.htmlEncode((item.display ? item.display : item.name)), query)
                })).attr('data-uid', itemUid); //Inserts the new item to list

                //If the index is 0
                if (index === 0) {
                    selectAutoCompleteItem(elmListItem);
                }

                //If show avatars is true
                if (settings.showAvatars) {
                    var elmIcon;

                    //If the item has an avatar
                    if (item.avatar) {
                        elmIcon = $(settings.templates.autocompleteListItemAvatar({ avatar : item.avatar }));
                    } else { //If not then we set an default icon
                        elmIcon = $(settings.templates.autocompleteListItemIcon({ icon : item.icon }));
                    }
                    elmIcon.prependTo(elmListItem); //Inserts the elmIcon to elmListItem
                }
                elmListItem = elmListItem.appendTo(elmDropDownList); //Insets the elmListItem to elmDropDownList
            });

            elmAutocompleteList.show(); //Shows the elmAutocompleteList div
            if (settings.onCaret) {
                positionAutocomplete(elmAutocompleteList, elmInputBox);
            }
            elmDropDownList.show(); //Shows the elmDropDownList
        }

        //Search into data list passed as parameter
        function doSearch(query) {
            //If the query is not null, undefined, empty and has the minimum chars
            if (query && query.length && query.length >= settings.minChars) {
                //Call the onDataRequest function and then call the populateDropDrown
                settings.onDataRequest.call(this, 'search', query, function (responseData) {
                    populateDropdown(query, responseData);
                });
            } else { //If the query is null, undefined, empty or has not the minimun chars
                hideAutoComplete(); //Hide the autocompletelist
            }
        }

        function positionAutocomplete(elmAutocompleteList, elmInputBox) {
            var position = textareaSelectionPosition(elmInputBox),
                lineHeight = parseInt(elmInputBox.css('line-height'), 10) || 18;
            elmAutocompleteList.css('width', '15em'); // Sort of a guess
            elmAutocompleteList.css('left', position.left);
            elmAutocompleteList.css('bottom', lineHeight + position.top);
        }

        //Resets the text area
        function resetInput() {
            elmInputBox.val('');
            mentionsCollection = [];
            updateValues();
        }

        // Public methods
        return {
            //Initializes the mentionsInput component on a specific element.
            init : function (domTarget) {

                domInput = domTarget;

                initTextarea();
                initAutocomplete();
                initMentionsOverlay();
                resetInput();

                //If the autocomplete list has prefill mentions
                if( settings.prefillMention ) {
                    addMention( settings.prefillMention );
                }

            },

            //An async method which accepts a callback function and returns a value of the input field (including markup) as a first parameter of this function. This is the value you want to send to your server.
            val : function (callback) {
                if (!_.isFunction(callback)) {
                    return;
                }

                callback.call(this, mentionsCollection.length ? elmInputBox.data('messageText') : getInputBoxValue());
            },

            //Resets the text area value and clears all mentions
            reset : function () {
                resetInput();
            },

            //An async method which accepts a callback function and returns a collection of mentions as hash objects as a first parameter.
            getMentions : function (callback) {
                if (!_.isFunction(callback)) {
                    return;
                }

                callback.call(this, mentionsCollection);
            }
        };
    };

    //Main function to include into jQuery and initialize the plugin
    $.fn.mentionsInput = function (method, settings) {

        var outerArguments = arguments; //Gets the arguments

        //If method is not a function
        if (typeof method === 'object' || !method) {
            settings = method;
        }

        return this.each(function () {
            var instance = $.data(this, 'mentionsInput') || $.data(this, 'mentionsInput', new MentionsInput(settings));

            if (_.isFunction(instance[method])) {
                return instance[method].apply(this, Array.prototype.slice.call(outerArguments, 1));

            } else if (typeof method === 'object' || !method) {
                return instance.init.call(this, this);

            } else {
                $.error('Method ' + method + ' does not exist');
            }

        });
    };

})(jQuery, _);

//! moment.js
//! version : 2.8.3
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
(function(a){function b(a,b,c){switch(arguments.length){case 2:return null!=a?a:b;case 3:return null!=a?a:null!=b?b:c;default:throw new Error("Implement me")}}function c(a,b){return zb.call(a,b)}function d(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function e(a){tb.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+a)}function f(a,b){var c=!0;return m(function(){return c&&(e(a),c=!1),b.apply(this,arguments)},b)}function g(a,b){qc[a]||(e(b),qc[a]=!0)}function h(a,b){return function(c){return p(a.call(this,c),b)}}function i(a,b){return function(c){return this.localeData().ordinal(a.call(this,c),b)}}function j(){}function k(a,b){b!==!1&&F(a),n(this,a),this._d=new Date(+a._d)}function l(a){var b=y(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._milliseconds=+k+1e3*j+6e4*i+36e5*h,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._locale=tb.localeData(),this._bubble()}function m(a,b){for(var d in b)c(b,d)&&(a[d]=b[d]);return c(b,"toString")&&(a.toString=b.toString),c(b,"valueOf")&&(a.valueOf=b.valueOf),a}function n(a,b){var c,d,e;if("undefined"!=typeof b._isAMomentObject&&(a._isAMomentObject=b._isAMomentObject),"undefined"!=typeof b._i&&(a._i=b._i),"undefined"!=typeof b._f&&(a._f=b._f),"undefined"!=typeof b._l&&(a._l=b._l),"undefined"!=typeof b._strict&&(a._strict=b._strict),"undefined"!=typeof b._tzm&&(a._tzm=b._tzm),"undefined"!=typeof b._isUTC&&(a._isUTC=b._isUTC),"undefined"!=typeof b._offset&&(a._offset=b._offset),"undefined"!=typeof b._pf&&(a._pf=b._pf),"undefined"!=typeof b._locale&&(a._locale=b._locale),Ib.length>0)for(c in Ib)d=Ib[c],e=b[d],"undefined"!=typeof e&&(a[d]=e);return a}function o(a){return 0>a?Math.ceil(a):Math.floor(a)}function p(a,b,c){for(var d=""+Math.abs(a),e=a>=0;d.length<b;)d="0"+d;return(e?c?"+":"":"-")+d}function q(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,"M").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,"M"),c}function r(a,b){var c;return b=K(b,a),a.isBefore(b)?c=q(a,b):(c=q(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c}function s(a,b){return function(c,d){var e,f;return null===d||isNaN(+d)||(g(b,"moment()."+b+"(period, number) is deprecated. Please use moment()."+b+"(number, period)."),f=c,c=d,d=f),c="string"==typeof c?+c:c,e=tb.duration(c,d),t(this,e,a),this}}function t(a,b,c,d){var e=b._milliseconds,f=b._days,g=b._months;d=null==d?!0:d,e&&a._d.setTime(+a._d+e*c),f&&nb(a,"Date",mb(a,"Date")+f*c),g&&lb(a,mb(a,"Month")+g*c),d&&tb.updateOffset(a,f||g)}function u(a){return"[object Array]"===Object.prototype.toString.call(a)}function v(a){return"[object Date]"===Object.prototype.toString.call(a)||a instanceof Date}function w(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&A(a[d])!==A(b[d]))&&g++;return g+f}function x(a){if(a){var b=a.toLowerCase().replace(/(.)s$/,"$1");a=jc[a]||kc[b]||b}return a}function y(a){var b,d,e={};for(d in a)c(a,d)&&(b=x(d),b&&(e[b]=a[d]));return e}function z(b){var c,d;if(0===b.indexOf("week"))c=7,d="day";else{if(0!==b.indexOf("month"))return;c=12,d="month"}tb[b]=function(e,f){var g,h,i=tb._locale[b],j=[];if("number"==typeof e&&(f=e,e=a),h=function(a){var b=tb().utc().set(d,a);return i.call(tb._locale,b,e||"")},null!=f)return h(f);for(g=0;c>g;g++)j.push(h(g));return j}}function A(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=b>=0?Math.floor(b):Math.ceil(b)),c}function B(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function C(a,b,c){return hb(tb([a,11,31+b-c]),b,c).week}function D(a){return E(a)?366:365}function E(a){return a%4===0&&a%100!==0||a%400===0}function F(a){var b;a._a&&-2===a._pf.overflow&&(b=a._a[Bb]<0||a._a[Bb]>11?Bb:a._a[Cb]<1||a._a[Cb]>B(a._a[Ab],a._a[Bb])?Cb:a._a[Db]<0||a._a[Db]>23?Db:a._a[Eb]<0||a._a[Eb]>59?Eb:a._a[Fb]<0||a._a[Fb]>59?Fb:a._a[Gb]<0||a._a[Gb]>999?Gb:-1,a._pf._overflowDayOfYear&&(Ab>b||b>Cb)&&(b=Cb),a._pf.overflow=b)}function G(a){return null==a._isValid&&(a._isValid=!isNaN(a._d.getTime())&&a._pf.overflow<0&&!a._pf.empty&&!a._pf.invalidMonth&&!a._pf.nullInput&&!a._pf.invalidFormat&&!a._pf.userInvalidated,a._strict&&(a._isValid=a._isValid&&0===a._pf.charsLeftOver&&0===a._pf.unusedTokens.length)),a._isValid}function H(a){return a?a.toLowerCase().replace("_","-"):a}function I(a){for(var b,c,d,e,f=0;f<a.length;){for(e=H(a[f]).split("-"),b=e.length,c=H(a[f+1]),c=c?c.split("-"):null;b>0;){if(d=J(e.slice(0,b).join("-")))return d;if(c&&c.length>=b&&w(e,c,!0)>=b-1)break;b--}f++}return null}function J(a){var b=null;if(!Hb[a]&&Jb)try{b=tb.locale(),require("./locale/"+a),tb.locale(b)}catch(c){}return Hb[a]}function K(a,b){return b._isUTC?tb(a).zone(b._offset||0):tb(a).local()}function L(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function M(a){var b,c,d=a.match(Nb);for(b=0,c=d.length;c>b;b++)d[b]=pc[d[b]]?pc[d[b]]:L(d[b]);return function(e){var f="";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function N(a,b){return a.isValid()?(b=O(b,a.localeData()),lc[b]||(lc[b]=M(b)),lc[b](a)):a.localeData().invalidDate()}function O(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Ob.lastIndex=0;d>=0&&Ob.test(a);)a=a.replace(Ob,c),Ob.lastIndex=0,d-=1;return a}function P(a,b){var c,d=b._strict;switch(a){case"Q":return Zb;case"DDDD":return _b;case"YYYY":case"GGGG":case"gggg":return d?ac:Rb;case"Y":case"G":case"g":return cc;case"YYYYYY":case"YYYYY":case"GGGGG":case"ggggg":return d?bc:Sb;case"S":if(d)return Zb;case"SS":if(d)return $b;case"SSS":if(d)return _b;case"DDD":return Qb;case"MMM":case"MMMM":case"dd":case"ddd":case"dddd":return Ub;case"a":case"A":return b._locale._meridiemParse;case"X":return Xb;case"Z":case"ZZ":return Vb;case"T":return Wb;case"SSSS":return Tb;case"MM":case"DD":case"YY":case"GG":case"gg":case"HH":case"hh":case"mm":case"ss":case"ww":case"WW":return d?$b:Pb;case"M":case"D":case"d":case"H":case"h":case"m":case"s":case"w":case"W":case"e":case"E":return Pb;case"Do":return Yb;default:return c=new RegExp(Y(X(a.replace("\\","")),"i"))}}function Q(a){a=a||"";var b=a.match(Vb)||[],c=b[b.length-1]||[],d=(c+"").match(hc)||["-",0,0],e=+(60*d[1])+A(d[2]);return"+"===d[0]?-e:e}function R(a,b,c){var d,e=c._a;switch(a){case"Q":null!=b&&(e[Bb]=3*(A(b)-1));break;case"M":case"MM":null!=b&&(e[Bb]=A(b)-1);break;case"MMM":case"MMMM":d=c._locale.monthsParse(b),null!=d?e[Bb]=d:c._pf.invalidMonth=b;break;case"D":case"DD":null!=b&&(e[Cb]=A(b));break;case"Do":null!=b&&(e[Cb]=A(parseInt(b,10)));break;case"DDD":case"DDDD":null!=b&&(c._dayOfYear=A(b));break;case"YY":e[Ab]=tb.parseTwoDigitYear(b);break;case"YYYY":case"YYYYY":case"YYYYYY":e[Ab]=A(b);break;case"a":case"A":c._isPm=c._locale.isPM(b);break;case"H":case"HH":case"h":case"hh":e[Db]=A(b);break;case"m":case"mm":e[Eb]=A(b);break;case"s":case"ss":e[Fb]=A(b);break;case"S":case"SS":case"SSS":case"SSSS":e[Gb]=A(1e3*("0."+b));break;case"X":c._d=new Date(1e3*parseFloat(b));break;case"Z":case"ZZ":c._useUTC=!0,c._tzm=Q(b);break;case"dd":case"ddd":case"dddd":d=c._locale.weekdaysParse(b),null!=d?(c._w=c._w||{},c._w.d=d):c._pf.invalidWeekday=b;break;case"w":case"ww":case"W":case"WW":case"d":case"e":case"E":a=a.substr(0,1);case"gggg":case"GGGG":case"GGGGG":a=a.substr(0,2),b&&(c._w=c._w||{},c._w[a]=A(b));break;case"gg":case"GG":c._w=c._w||{},c._w[a]=tb.parseTwoDigitYear(b)}}function S(a){var c,d,e,f,g,h,i;c=a._w,null!=c.GG||null!=c.W||null!=c.E?(g=1,h=4,d=b(c.GG,a._a[Ab],hb(tb(),1,4).year),e=b(c.W,1),f=b(c.E,1)):(g=a._locale._week.dow,h=a._locale._week.doy,d=b(c.gg,a._a[Ab],hb(tb(),g,h).year),e=b(c.w,1),null!=c.d?(f=c.d,g>f&&++e):f=null!=c.e?c.e+g:g),i=ib(d,e,f,h,g),a._a[Ab]=i.year,a._dayOfYear=i.dayOfYear}function T(a){var c,d,e,f,g=[];if(!a._d){for(e=V(a),a._w&&null==a._a[Cb]&&null==a._a[Bb]&&S(a),a._dayOfYear&&(f=b(a._a[Ab],e[Ab]),a._dayOfYear>D(f)&&(a._pf._overflowDayOfYear=!0),d=db(f,0,a._dayOfYear),a._a[Bb]=d.getUTCMonth(),a._a[Cb]=d.getUTCDate()),c=0;3>c&&null==a._a[c];++c)a._a[c]=g[c]=e[c];for(;7>c;c++)a._a[c]=g[c]=null==a._a[c]?2===c?1:0:a._a[c];a._d=(a._useUTC?db:cb).apply(null,g),null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()+a._tzm)}}function U(a){var b;a._d||(b=y(a._i),a._a=[b.year,b.month,b.day,b.hour,b.minute,b.second,b.millisecond],T(a))}function V(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function W(a){if(a._f===tb.ISO_8601)return void $(a);a._a=[],a._pf.empty=!0;var b,c,d,e,f,g=""+a._i,h=g.length,i=0;for(d=O(a._f,a._locale).match(Nb)||[],b=0;b<d.length;b++)e=d[b],c=(g.match(P(e,a))||[])[0],c&&(f=g.substr(0,g.indexOf(c)),f.length>0&&a._pf.unusedInput.push(f),g=g.slice(g.indexOf(c)+c.length),i+=c.length),pc[e]?(c?a._pf.empty=!1:a._pf.unusedTokens.push(e),R(e,c,a)):a._strict&&!c&&a._pf.unusedTokens.push(e);a._pf.charsLeftOver=h-i,g.length>0&&a._pf.unusedInput.push(g),a._isPm&&a._a[Db]<12&&(a._a[Db]+=12),a._isPm===!1&&12===a._a[Db]&&(a._a[Db]=0),T(a),F(a)}function X(a){return a.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e})}function Y(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function Z(a){var b,c,e,f,g;if(0===a._f.length)return a._pf.invalidFormat=!0,void(a._d=new Date(0/0));for(f=0;f<a._f.length;f++)g=0,b=n({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._pf=d(),b._f=a._f[f],W(b),G(b)&&(g+=b._pf.charsLeftOver,g+=10*b._pf.unusedTokens.length,b._pf.score=g,(null==e||e>g)&&(e=g,c=b));m(a,c||b)}function $(a){var b,c,d=a._i,e=dc.exec(d);if(e){for(a._pf.iso=!0,b=0,c=fc.length;c>b;b++)if(fc[b][1].exec(d)){a._f=fc[b][0]+(e[6]||" ");break}for(b=0,c=gc.length;c>b;b++)if(gc[b][1].exec(d)){a._f+=gc[b][0];break}d.match(Vb)&&(a._f+="Z"),W(a)}else a._isValid=!1}function _(a){$(a),a._isValid===!1&&(delete a._isValid,tb.createFromInputFallback(a))}function ab(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function bb(b){var c,d=b._i;d===a?b._d=new Date:v(d)?b._d=new Date(+d):null!==(c=Kb.exec(d))?b._d=new Date(+c[1]):"string"==typeof d?_(b):u(d)?(b._a=ab(d.slice(0),function(a){return parseInt(a,10)}),T(b)):"object"==typeof d?U(b):"number"==typeof d?b._d=new Date(d):tb.createFromInputFallback(b)}function cb(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970>a&&h.setFullYear(a),h}function db(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970>a&&b.setUTCFullYear(a),b}function eb(a,b){if("string"==typeof a)if(isNaN(a)){if(a=b.weekdaysParse(a),"number"!=typeof a)return null}else a=parseInt(a,10);return a}function fb(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function gb(a,b,c){var d=tb.duration(a).abs(),e=yb(d.as("s")),f=yb(d.as("m")),g=yb(d.as("h")),h=yb(d.as("d")),i=yb(d.as("M")),j=yb(d.as("y")),k=e<mc.s&&["s",e]||1===f&&["m"]||f<mc.m&&["mm",f]||1===g&&["h"]||g<mc.h&&["hh",g]||1===h&&["d"]||h<mc.d&&["dd",h]||1===i&&["M"]||i<mc.M&&["MM",i]||1===j&&["y"]||["yy",j];return k[2]=b,k[3]=+a>0,k[4]=c,fb.apply({},k)}function hb(a,b,c){var d,e=c-b,f=c-a.day();return f>e&&(f-=7),e-7>f&&(f+=7),d=tb(a).add(f,"d"),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function ib(a,b,c,d,e){var f,g,h=db(a,0,1).getUTCDay();return h=0===h?7:h,c=null!=c?c:e,f=e-h+(h>d?7:0)-(e>h?7:0),g=7*(b-1)+(c-e)+f+1,{year:g>0?a:a-1,dayOfYear:g>0?g:D(a-1)+g}}function jb(b){var c=b._i,d=b._f;return b._locale=b._locale||tb.localeData(b._l),null===c||d===a&&""===c?tb.invalid({nullInput:!0}):("string"==typeof c&&(b._i=c=b._locale.preparse(c)),tb.isMoment(c)?new k(c,!0):(d?u(d)?Z(b):W(b):bb(b),new k(b)))}function kb(a,b){var c,d;if(1===b.length&&u(b[0])&&(b=b[0]),!b.length)return tb();for(c=b[0],d=1;d<b.length;++d)b[d][a](c)&&(c=b[d]);return c}function lb(a,b){var c;return"string"==typeof b&&(b=a.localeData().monthsParse(b),"number"!=typeof b)?a:(c=Math.min(a.date(),B(a.year(),b)),a._d["set"+(a._isUTC?"UTC":"")+"Month"](b,c),a)}function mb(a,b){return a._d["get"+(a._isUTC?"UTC":"")+b]()}function nb(a,b,c){return"Month"===b?lb(a,c):a._d["set"+(a._isUTC?"UTC":"")+b](c)}function ob(a,b){return function(c){return null!=c?(nb(this,a,c),tb.updateOffset(this,b),this):mb(this,a)}}function pb(a){return 400*a/146097}function qb(a){return 146097*a/400}function rb(a){tb.duration.fn[a]=function(){return this._data[a]}}function sb(a){"undefined"==typeof ender&&(ub=xb.moment,xb.moment=a?f("Accessing Moment through the global scope is deprecated, and will be removed in an upcoming release.",tb):tb)}for(var tb,ub,vb,wb="2.8.3",xb="undefined"!=typeof global?global:this,yb=Math.round,zb=Object.prototype.hasOwnProperty,Ab=0,Bb=1,Cb=2,Db=3,Eb=4,Fb=5,Gb=6,Hb={},Ib=[],Jb="undefined"!=typeof module&&module.exports,Kb=/^\/?Date\((\-?\d+)/i,Lb=/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,Mb=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,Nb=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,Ob=/(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,Pb=/\d\d?/,Qb=/\d{1,3}/,Rb=/\d{1,4}/,Sb=/[+\-]?\d{1,6}/,Tb=/\d+/,Ub=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,Vb=/Z|[\+\-]\d\d:?\d\d/gi,Wb=/T/i,Xb=/[\+\-]?\d+(\.\d{1,3})?/,Yb=/\d{1,2}/,Zb=/\d/,$b=/\d\d/,_b=/\d{3}/,ac=/\d{4}/,bc=/[+-]?\d{6}/,cc=/[+-]?\d+/,dc=/^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,ec="YYYY-MM-DDTHH:mm:ssZ",fc=[["YYYYYY-MM-DD",/[+-]\d{6}-\d{2}-\d{2}/],["YYYY-MM-DD",/\d{4}-\d{2}-\d{2}/],["GGGG-[W]WW-E",/\d{4}-W\d{2}-\d/],["GGGG-[W]WW",/\d{4}-W\d{2}/],["YYYY-DDD",/\d{4}-\d{3}/]],gc=[["HH:mm:ss.SSSS",/(T| )\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],hc=/([\+\-]|\d\d)/gi,ic=("Date|Hours|Minutes|Seconds|Milliseconds".split("|"),{Milliseconds:1,Seconds:1e3,Minutes:6e4,Hours:36e5,Days:864e5,Months:2592e6,Years:31536e6}),jc={ms:"millisecond",s:"second",m:"minute",h:"hour",d:"day",D:"date",w:"week",W:"isoWeek",M:"month",Q:"quarter",y:"year",DDD:"dayOfYear",e:"weekday",E:"isoWeekday",gg:"weekYear",GG:"isoWeekYear"},kc={dayofyear:"dayOfYear",isoweekday:"isoWeekday",isoweek:"isoWeek",weekyear:"weekYear",isoweekyear:"isoWeekYear"},lc={},mc={s:45,m:45,h:22,d:26,M:11},nc="DDD w W M D d".split(" "),oc="M D H h m s w W".split(" "),pc={M:function(){return this.month()+1},MMM:function(a){return this.localeData().monthsShort(this,a)},MMMM:function(a){return this.localeData().months(this,a)},D:function(){return this.date()},DDD:function(){return this.dayOfYear()},d:function(){return this.day()},dd:function(a){return this.localeData().weekdaysMin(this,a)},ddd:function(a){return this.localeData().weekdaysShort(this,a)},dddd:function(a){return this.localeData().weekdays(this,a)},w:function(){return this.week()},W:function(){return this.isoWeek()},YY:function(){return p(this.year()%100,2)},YYYY:function(){return p(this.year(),4)},YYYYY:function(){return p(this.year(),5)},YYYYYY:function(){var a=this.year(),b=a>=0?"+":"-";return b+p(Math.abs(a),6)},gg:function(){return p(this.weekYear()%100,2)},gggg:function(){return p(this.weekYear(),4)},ggggg:function(){return p(this.weekYear(),5)},GG:function(){return p(this.isoWeekYear()%100,2)},GGGG:function(){return p(this.isoWeekYear(),4)},GGGGG:function(){return p(this.isoWeekYear(),5)},e:function(){return this.weekday()},E:function(){return this.isoWeekday()},a:function(){return this.localeData().meridiem(this.hours(),this.minutes(),!0)},A:function(){return this.localeData().meridiem(this.hours(),this.minutes(),!1)},H:function(){return this.hours()},h:function(){return this.hours()%12||12},m:function(){return this.minutes()},s:function(){return this.seconds()},S:function(){return A(this.milliseconds()/100)},SS:function(){return p(A(this.milliseconds()/10),2)},SSS:function(){return p(this.milliseconds(),3)},SSSS:function(){return p(this.milliseconds(),3)},Z:function(){var a=-this.zone(),b="+";return 0>a&&(a=-a,b="-"),b+p(A(a/60),2)+":"+p(A(a)%60,2)},ZZ:function(){var a=-this.zone(),b="+";return 0>a&&(a=-a,b="-"),b+p(A(a/60),2)+p(A(a)%60,2)},z:function(){return this.zoneAbbr()},zz:function(){return this.zoneName()},X:function(){return this.unix()},Q:function(){return this.quarter()}},qc={},rc=["months","monthsShort","weekdays","weekdaysShort","weekdaysMin"];nc.length;)vb=nc.pop(),pc[vb+"o"]=i(pc[vb],vb);for(;oc.length;)vb=oc.pop(),pc[vb+vb]=h(pc[vb],2);pc.DDDD=h(pc.DDD,3),m(j.prototype,{set:function(a){var b,c;for(c in a)b=a[c],"function"==typeof b?this[c]=b:this["_"+c]=b},_months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),months:function(a){return this._months[a.month()]},_monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),monthsShort:function(a){return this._monthsShort[a.month()]},monthsParse:function(a){var b,c,d;for(this._monthsParse||(this._monthsParse=[]),b=0;12>b;b++)if(this._monthsParse[b]||(c=tb.utc([2e3,b]),d="^"+this.months(c,"")+"|^"+this.monthsShort(c,""),this._monthsParse[b]=new RegExp(d.replace(".",""),"i")),this._monthsParse[b].test(a))return b},_weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdays:function(a){return this._weekdays[a.day()]},_weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysShort:function(a){return this._weekdaysShort[a.day()]},_weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),weekdaysMin:function(a){return this._weekdaysMin[a.day()]},weekdaysParse:function(a){var b,c,d;for(this._weekdaysParse||(this._weekdaysParse=[]),b=0;7>b;b++)if(this._weekdaysParse[b]||(c=tb([2e3,1]).day(b),d="^"+this.weekdays(c,"")+"|^"+this.weekdaysShort(c,"")+"|^"+this.weekdaysMin(c,""),this._weekdaysParse[b]=new RegExp(d.replace(".",""),"i")),this._weekdaysParse[b].test(a))return b},_longDateFormat:{LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY LT",LLLL:"dddd, MMMM D, YYYY LT"},longDateFormat:function(a){var b=this._longDateFormat[a];return!b&&this._longDateFormat[a.toUpperCase()]&&(b=this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a]=b),b},isPM:function(a){return"p"===(a+"").toLowerCase().charAt(0)},_meridiemParse:/[ap]\.?m?\.?/i,meridiem:function(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"},_calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},calendar:function(a,b){var c=this._calendar[a];return"function"==typeof c?c.apply(b):c},_relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},relativeTime:function(a,b,c,d){var e=this._relativeTime[c];return"function"==typeof e?e(a,b,c,d):e.replace(/%d/i,a)},pastFuture:function(a,b){var c=this._relativeTime[a>0?"future":"past"];return"function"==typeof c?c(b):c.replace(/%s/i,b)},ordinal:function(a){return this._ordinal.replace("%d",a)},_ordinal:"%d",preparse:function(a){return a},postformat:function(a){return a},week:function(a){return hb(a,this._week.dow,this._week.doy).week},_week:{dow:0,doy:6},_invalidDate:"Invalid date",invalidDate:function(){return this._invalidDate}}),tb=function(b,c,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._i=b,g._f=c,g._l=e,g._strict=f,g._isUTC=!1,g._pf=d(),jb(g)},tb.suppressDeprecationWarnings=!1,tb.createFromInputFallback=f("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.",function(a){a._d=new Date(a._i)}),tb.min=function(){var a=[].slice.call(arguments,0);return kb("isBefore",a)},tb.max=function(){var a=[].slice.call(arguments,0);return kb("isAfter",a)},tb.utc=function(b,c,e,f){var g;return"boolean"==typeof e&&(f=e,e=a),g={},g._isAMomentObject=!0,g._useUTC=!0,g._isUTC=!0,g._l=e,g._i=b,g._f=c,g._strict=f,g._pf=d(),jb(g).utc()},tb.unix=function(a){return tb(1e3*a)},tb.duration=function(a,b){var d,e,f,g,h=a,i=null;return tb.isDuration(a)?h={ms:a._milliseconds,d:a._days,M:a._months}:"number"==typeof a?(h={},b?h[b]=a:h.milliseconds=a):(i=Lb.exec(a))?(d="-"===i[1]?-1:1,h={y:0,d:A(i[Cb])*d,h:A(i[Db])*d,m:A(i[Eb])*d,s:A(i[Fb])*d,ms:A(i[Gb])*d}):(i=Mb.exec(a))?(d="-"===i[1]?-1:1,f=function(a){var b=a&&parseFloat(a.replace(",","."));return(isNaN(b)?0:b)*d},h={y:f(i[2]),M:f(i[3]),d:f(i[4]),h:f(i[5]),m:f(i[6]),s:f(i[7]),w:f(i[8])}):"object"==typeof h&&("from"in h||"to"in h)&&(g=r(tb(h.from),tb(h.to)),h={},h.ms=g.milliseconds,h.M=g.months),e=new l(h),tb.isDuration(a)&&c(a,"_locale")&&(e._locale=a._locale),e},tb.version=wb,tb.defaultFormat=ec,tb.ISO_8601=function(){},tb.momentProperties=Ib,tb.updateOffset=function(){},tb.relativeTimeThreshold=function(b,c){return mc[b]===a?!1:c===a?mc[b]:(mc[b]=c,!0)},tb.lang=f("moment.lang is deprecated. Use moment.locale instead.",function(a,b){return tb.locale(a,b)}),tb.locale=function(a,b){var c;return a&&(c="undefined"!=typeof b?tb.defineLocale(a,b):tb.localeData(a),c&&(tb.duration._locale=tb._locale=c)),tb._locale._abbr},tb.defineLocale=function(a,b){return null!==b?(b.abbr=a,Hb[a]||(Hb[a]=new j),Hb[a].set(b),tb.locale(a),Hb[a]):(delete Hb[a],null)},tb.langData=f("moment.langData is deprecated. Use moment.localeData instead.",function(a){return tb.localeData(a)}),tb.localeData=function(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return tb._locale;if(!u(a)){if(b=J(a))return b;a=[a]}return I(a)},tb.isMoment=function(a){return a instanceof k||null!=a&&c(a,"_isAMomentObject")},tb.isDuration=function(a){return a instanceof l};for(vb=rc.length-1;vb>=0;--vb)z(rc[vb]);tb.normalizeUnits=function(a){return x(a)},tb.invalid=function(a){var b=tb.utc(0/0);return null!=a?m(b._pf,a):b._pf.userInvalidated=!0,b},tb.parseZone=function(){return tb.apply(null,arguments).parseZone()},tb.parseTwoDigitYear=function(a){return A(a)+(A(a)>68?1900:2e3)},m(tb.fn=k.prototype,{clone:function(){return tb(this)},valueOf:function(){return+this._d+6e4*(this._offset||0)},unix:function(){return Math.floor(+this/1e3)},toString:function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},toDate:function(){return this._offset?new Date(+this):this._d},toISOString:function(){var a=tb(this).utc();return 0<a.year()&&a.year()<=9999?N(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):N(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")},toArray:function(){var a=this;return[a.year(),a.month(),a.date(),a.hours(),a.minutes(),a.seconds(),a.milliseconds()]},isValid:function(){return G(this)},isDSTShifted:function(){return this._a?this.isValid()&&w(this._a,(this._isUTC?tb.utc(this._a):tb(this._a)).toArray())>0:!1},parsingFlags:function(){return m({},this._pf)},invalidAt:function(){return this._pf.overflow},utc:function(a){return this.zone(0,a)},local:function(a){return this._isUTC&&(this.zone(0,a),this._isUTC=!1,a&&this.add(this._dateTzOffset(),"m")),this},format:function(a){var b=N(this,a||tb.defaultFormat);return this.localeData().postformat(b)},add:s(1,"add"),subtract:s(-1,"subtract"),diff:function(a,b,c){var d,e,f,g=K(a,this),h=6e4*(this.zone()-g.zone());return b=x(b),"year"===b||"month"===b?(d=432e5*(this.daysInMonth()+g.daysInMonth()),e=12*(this.year()-g.year())+(this.month()-g.month()),f=this-tb(this).startOf("month")-(g-tb(g).startOf("month")),f-=6e4*(this.zone()-tb(this).startOf("month").zone()-(g.zone()-tb(g).startOf("month").zone())),e+=f/d,"year"===b&&(e/=12)):(d=this-g,e="second"===b?d/1e3:"minute"===b?d/6e4:"hour"===b?d/36e5:"day"===b?(d-h)/864e5:"week"===b?(d-h)/6048e5:d),c?e:o(e)},from:function(a,b){return tb.duration({to:this,from:a}).locale(this.locale()).humanize(!b)},fromNow:function(a){return this.from(tb(),a)},calendar:function(a){var b=a||tb(),c=K(b,this).startOf("day"),d=this.diff(c,"days",!0),e=-6>d?"sameElse":-1>d?"lastWeek":0>d?"lastDay":1>d?"sameDay":2>d?"nextDay":7>d?"nextWeek":"sameElse";return this.format(this.localeData().calendar(e,this))},isLeapYear:function(){return E(this.year())},isDST:function(){return this.zone()<this.clone().month(0).zone()||this.zone()<this.clone().month(5).zone()},day:function(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=eb(a,this.localeData()),this.add(a-b,"d")):b},month:ob("Month",!0),startOf:function(a){switch(a=x(a)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===a?this.weekday(0):"isoWeek"===a&&this.isoWeekday(1),"quarter"===a&&this.month(3*Math.floor(this.month()/3)),this},endOf:function(a){return a=x(a),this.startOf(a).add(1,"isoWeek"===a?"week":a).subtract(1,"ms")},isAfter:function(a,b){return b=x("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=tb.isMoment(a)?a:tb(a),+this>+a):+this.clone().startOf(b)>+tb(a).startOf(b)},isBefore:function(a,b){return b=x("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=tb.isMoment(a)?a:tb(a),+a>+this):+this.clone().startOf(b)<+tb(a).startOf(b)},isSame:function(a,b){return b=x(b||"millisecond"),"millisecond"===b?(a=tb.isMoment(a)?a:tb(a),+this===+a):+this.clone().startOf(b)===+K(a,this).startOf(b)},min:f("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",function(a){return a=tb.apply(null,arguments),this>a?this:a}),max:f("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",function(a){return a=tb.apply(null,arguments),a>this?this:a}),zone:function(a,b){var c,d=this._offset||0;return null==a?this._isUTC?d:this._dateTzOffset():("string"==typeof a&&(a=Q(a)),Math.abs(a)<16&&(a=60*a),!this._isUTC&&b&&(c=this._dateTzOffset()),this._offset=a,this._isUTC=!0,null!=c&&this.subtract(c,"m"),d!==a&&(!b||this._changeInProgress?t(this,tb.duration(d-a,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,tb.updateOffset(this,!0),this._changeInProgress=null)),this)},zoneAbbr:function(){return this._isUTC?"UTC":""},zoneName:function(){return this._isUTC?"Coordinated Universal Time":""},parseZone:function(){return this._tzm?this.zone(this._tzm):"string"==typeof this._i&&this.zone(this._i),this},hasAlignedHourOffset:function(a){return a=a?tb(a).zone():0,(this.zone()-a)%60===0},daysInMonth:function(){return B(this.year(),this.month())},dayOfYear:function(a){var b=yb((tb(this).startOf("day")-tb(this).startOf("year"))/864e5)+1;return null==a?b:this.add(a-b,"d")},quarter:function(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)},weekYear:function(a){var b=hb(this,this.localeData()._week.dow,this.localeData()._week.doy).year;return null==a?b:this.add(a-b,"y")},isoWeekYear:function(a){var b=hb(this,1,4).year;return null==a?b:this.add(a-b,"y")},week:function(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),"d")},isoWeek:function(a){var b=hb(this,1,4).week;return null==a?b:this.add(7*(a-b),"d")},weekday:function(a){var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,"d")},isoWeekday:function(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)},isoWeeksInYear:function(){return C(this.year(),1,4)},weeksInYear:function(){var a=this.localeData()._week;return C(this.year(),a.dow,a.doy)},get:function(a){return a=x(a),this[a]()},set:function(a,b){return a=x(a),"function"==typeof this[a]&&this[a](b),this},locale:function(b){var c;return b===a?this._locale._abbr:(c=tb.localeData(b),null!=c&&(this._locale=c),this)},lang:f("moment().lang() is deprecated. Use moment().localeData() instead.",function(b){return b===a?this.localeData():this.locale(b)}),localeData:function(){return this._locale},_dateTzOffset:function(){return 15*Math.round(this._d.getTimezoneOffset()/15)}}),tb.fn.millisecond=tb.fn.milliseconds=ob("Milliseconds",!1),tb.fn.second=tb.fn.seconds=ob("Seconds",!1),tb.fn.minute=tb.fn.minutes=ob("Minutes",!1),tb.fn.hour=tb.fn.hours=ob("Hours",!0),tb.fn.date=ob("Date",!0),tb.fn.dates=f("dates accessor is deprecated. Use date instead.",ob("Date",!0)),tb.fn.year=ob("FullYear",!0),tb.fn.years=f("years accessor is deprecated. Use year instead.",ob("FullYear",!0)),tb.fn.days=tb.fn.day,tb.fn.months=tb.fn.month,tb.fn.weeks=tb.fn.week,tb.fn.isoWeeks=tb.fn.isoWeek,tb.fn.quarters=tb.fn.quarter,tb.fn.toJSON=tb.fn.toISOString,m(tb.duration.fn=l.prototype,{_bubble:function(){var a,b,c,d=this._milliseconds,e=this._days,f=this._months,g=this._data,h=0;g.milliseconds=d%1e3,a=o(d/1e3),g.seconds=a%60,b=o(a/60),g.minutes=b%60,c=o(b/60),g.hours=c%24,e+=o(c/24),h=o(pb(e)),e-=o(qb(h)),f+=o(e/30),e%=30,h+=o(f/12),f%=12,g.days=e,g.months=f,g.years=h},abs:function(){return this._milliseconds=Math.abs(this._milliseconds),this._days=Math.abs(this._days),this._months=Math.abs(this._months),this._data.milliseconds=Math.abs(this._data.milliseconds),this._data.seconds=Math.abs(this._data.seconds),this._data.minutes=Math.abs(this._data.minutes),this._data.hours=Math.abs(this._data.hours),this._data.months=Math.abs(this._data.months),this._data.years=Math.abs(this._data.years),this},weeks:function(){return o(this.days()/7)},valueOf:function(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*A(this._months/12)},humanize:function(a){var b=gb(this,!a,this.localeData());return a&&(b=this.localeData().pastFuture(+this,b)),this.localeData().postformat(b)},add:function(a,b){var c=tb.duration(a,b);return this._milliseconds+=c._milliseconds,this._days+=c._days,this._months+=c._months,this._bubble(),this},subtract:function(a,b){var c=tb.duration(a,b);return this._milliseconds-=c._milliseconds,this._days-=c._days,this._months-=c._months,this._bubble(),this},get:function(a){return a=x(a),this[a.toLowerCase()+"s"]()},as:function(a){var b,c;if(a=x(a),"month"===a||"year"===a)return b=this._days+this._milliseconds/864e5,c=this._months+12*pb(b),"month"===a?c:c/12;switch(b=this._days+qb(this._months/12),a){case"week":return b/7+this._milliseconds/6048e5;case"day":return b+this._milliseconds/864e5;case"hour":return 24*b+this._milliseconds/36e5;case"minute":return 24*b*60+this._milliseconds/6e4;case"second":return 24*b*60*60+this._milliseconds/1e3;case"millisecond":return Math.floor(24*b*60*60*1e3)+this._milliseconds;default:throw new Error("Unknown unit "+a)}},lang:tb.fn.lang,locale:tb.fn.locale,toIsoString:f("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",function(){return this.toISOString()}),toISOString:function(){var a=Math.abs(this.years()),b=Math.abs(this.months()),c=Math.abs(this.days()),d=Math.abs(this.hours()),e=Math.abs(this.minutes()),f=Math.abs(this.seconds()+this.milliseconds()/1e3);return this.asSeconds()?(this.asSeconds()<0?"-":"")+"P"+(a?a+"Y":"")+(b?b+"M":"")+(c?c+"D":"")+(d||e||f?"T":"")+(d?d+"H":"")+(e?e+"M":"")+(f?f+"S":""):"P0D"},localeData:function(){return this._locale}}),tb.duration.fn.toString=tb.duration.fn.toISOString;for(vb in ic)c(ic,vb)&&rb(vb.toLowerCase());tb.duration.fn.asMilliseconds=function(){return this.as("ms")},tb.duration.fn.asSeconds=function(){return this.as("s")},tb.duration.fn.asMinutes=function(){return this.as("m")},tb.duration.fn.asHours=function(){return this.as("h")},tb.duration.fn.asDays=function(){return this.as("d")},tb.duration.fn.asWeeks=function(){return this.as("weeks")},tb.duration.fn.asMonths=function(){return this.as("M")},tb.duration.fn.asYears=function(){return this.as("y")},tb.locale("en",{ordinal:function(a){var b=a%10,c=1===A(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";
return a+c}}),Jb?module.exports=tb:"function"==typeof define&&define.amd?(define("moment",function(a,b,c){return c.config&&c.config()&&c.config().noGlobal===!0&&(xb.moment=ub),tb}),sb(!0)):sb()}).call(this);
/**
 * Custom bindings for knockout
 *
 * @type {{init: Function, update: Function}}
 */
ko.bindingHandlers.boxSlider = {
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {

        // This will be called when the binding is first applied to an element
        // Set up any initial state, event handlers, etc. here

        if (typeof($.fn.bxSlider) === 'undefined') {
            return false;
        }

        var $el = $(element);
        var options = valueAccessor() || {};

        setTimeout(function () {
            $el.data('boxSlider', $el.bxSlider(options));
        }, 200);

    },
    update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        // This will be called once when the binding is first applied to an element,
        // and again whenever any observables/computeds that are accessed change
        // Update the DOM element based on the supplied values here.

        var oSlider = $(element).data("boxSlider");
        if (oSlider) {
            oSlider.redrawSlider();
        }
    }
};

/**
 * Display tips to the element
 *
 * @type {{init: Function, update: Function}}
 */
ko.bindingHandlers.tipsy = {
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {

        // This will be called when the binding is first applied to an element
        // Set up any initial state, event handlers, etc. here

        if (typeof($.fn.tipsy) === 'undefined') {
            return false;
        }

        var $el = $(element);
        var options = valueAccessor() || {};

        if (typeof(options.content) === 'string') {
            $el.attr('data-wtip', options.content);
            options.title = 'data-wtip';
        }

        $el.tipsy(options);

    },
    update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        // This will be called once when the binding is first applied to an element,
        // and again whenever any observables/computeds that are accessed change
        // Update the DOM element based on the supplied values here.
    }
};


/**
 * Custom bindings for knockout select2 plugin
 *
 * @type {{init: Function, update: Function}}
 */
ko.bindingHandlers.select2 = {
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {

        // This will be called when the binding is first applied to an element
        // Set up any initial state, event handlers, etc. here

        if (typeof($.fn.select2) === 'undefined') {
            return false;
        }

        var $el = $(element);
        var options = valueAccessor() || {};

        $el.select2(options);

    },
    update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        // This will be called once when the binding is first applied to an element,
        // and again whenever any observables/computeds that are accessed change
        // Update the DOM element based on the supplied values here.
    }
};


/**
 * Timer button build
 *
 * @type {{init: Function, update: Function}}
 */
ko.bindingHandlers.timerButton = {
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {

        var options = valueAccessor() || {time_end: 0, total_time: 0, current_time: 0};
        var $element = $(element);

        var oProgressBtn = new ProgressButton(element, {
            statusTime: 10,
            callback: function(oInstance) {
                //Set progress class
                $element.addClass('progress-button');

                //Save jquery object data
                $element.data('oProgressButton', oInstance);
                $element.data('options', options);
                $element.attr('data-progress-button', true);
            }
        });

        $(element).trigger('StartTimer'); //Hack to automatic start the button
    },
    update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        // This will be called once when the binding is first applied to an element,
        // and again whenever any observables/computeds that are accessed change
        // Update the DOM element based on the supplied values here.«
    }

};



/**
 * Display tips to the element
 *
 * @type {{init: Function, update: Function}}
 */
ko.bindingHandlers.scrollbar = {
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {

        // This will be called when the binding is first applied to an element
        // Set up any initial state, event handlers, etc. here

        var $el = $(element);
        var options = valueAccessor() || {};
        $el.addClass('perefect-scroll');

        $el.data('oScroll', omerta.GUI.scroll.build($el, options));


    },
    update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        // This will be called once when the binding is first applied to an element,
        // and again whenever any observables/computeds that are accessed change
        // Update the DOM element based on the supplied values here.

        var $el = $(element);
        var options = valueAccessor() || {};

        var oScroll = $el.data('oScroll');

        if (typeof(oScroll) === 'undefined') {
            return;
        }

        if (typeof(oScroll) === 'object') {
            omerta.GUI.scroll.refresh(oScroll, options);
        }
    }
};


/**
 * Hall of fame widget
 */
ko.components.register('widget-hof', {
    viewModel: function(params) {

        this.title = ko.observable('Loading');
        this.subTitle = ko.observable('');
        this.hof = ko.observableArray([]);

        var self = this;

        var $jqxhr = $.ajax('/?module=Homepage.Reset&action=hof');
        $jqxhr.done(function(data) {
            self.title(data.title);
            self.subTitle(data.subtitle);
            self.hof(data.hof);
        });
    },
    template: { element: 'widget-hof' }
});
/*!
 * classie - class helper functions
 * from bonzo https://github.com/ded/bonzo
 *
 * classie.has( elem, 'my-class' ) -> true/false
 * classie.add( elem, 'my-new-class' )
 * classie.remove( elem, 'my-unwanted-class' )
 * classie.toggle( elem, 'my-class' )
 */

/*jshint browser: true, strict: true, undef: true */
/*global define: false */

( function( window ) {

  'use strict';

// class helper functions from bonzo https://github.com/ded/bonzo

  function classReg( className ) {
    return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
  }

// classList support for class management
// altho to be fair, the api sucks because it won't accept multiple classes at once
  var hasClass, addClass, removeClass;

  if ( 'classList' in document.documentElement ) {
    hasClass = function( elem, c ) {
      return elem.classList.contains( c );
    };
    addClass = function( elem, c ) {
      elem.classList.add( c );
    };
    removeClass = function( elem, c ) {
      elem.classList.remove( c );
    };
  }
  else {
    hasClass = function( elem, c ) {
      return classReg( c ).test( elem.className );
    };
    addClass = function( elem, c ) {
      if ( !hasClass( elem, c ) ) {
        elem.className = elem.className + ' ' + c;
      }
    };
    removeClass = function( elem, c ) {
      elem.className = elem.className.replace( classReg( c ), ' ' );
    };
  }

  function toggleClass( elem, c ) {
    var fn = hasClass( elem, c ) ? removeClass : addClass;
    fn( elem, c );
  }

  var classie = {
    // full names
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    toggleClass: toggleClass,
    // short names
    has: hasClass,
    add: addClass,
    remove: removeClass,
    toggle: toggleClass
  };

// transport
  if ( typeof define === 'function' && define.amd ) {
    // AMD
    define( classie );
  } else {
    // browser global
    window.classie = classie;
  }

})( window );
/**
 * progressButton.js v1.0.0
 * http://www.codrops.com
 *
 * Licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Copyright 2013, Codrops
 * http://www.codrops.com
 */
;( function( window ) {

  'use strict';

  // https://gist.github.com/edankwan/4389601
  Modernizr.addTest('csstransformspreserve3d', function () {
    var prop = Modernizr.prefixed('transformStyle');
    var val = 'preserve-3d';
    var computedStyle;
    if(!prop) return false;

    prop = prop.replace(/([A-Z])/g, function(str,m1){ return '-' + m1.toLowerCase(); }).replace(/^ms-/,'-ms-');

    Modernizr.testStyles('#modernizr{' + prop + ':' + val + ';}', function (el, rule) {
      computedStyle = window.getComputedStyle ? getComputedStyle(el, null).getPropertyValue(prop) : '';
    });

    return (computedStyle === val);
  });

  function extend( a, b ) {
    for( var key in b ) {
      if( b.hasOwnProperty( key ) ) {
        a[key] = b[key];
      }
    }
    return a;
  }

  // support
  var support = { transitions : Modernizr.csstransitions, transforms3d : Modernizr.csstransforms3d && Modernizr.csstransformspreserve3d },
  // transition end event name
          transEndEventNames = {
            'WebkitTransition': 'webkitTransitionEnd',
            'MozTransition': 'transitionend',
            'OTransition': 'oTransitionEnd',
            'msTransition': 'MSTransitionEnd',
            'transition': 'transitionend'
          },
          transEndEventName = transEndEventNames[ Modernizr.prefixed( 'transition' ) ];

  function ProgressButton( el, options ) {
    this.button = el;
    this.options = extend( {}, this.options );
    extend( this.options, options );
    this._init();
  }

  ProgressButton.prototype.options = {
    // time in ms that the status (success or error will be displayed)
    // during this time the button will be disabled
    statusTime : 500
  };

  ProgressButton.prototype._init = function() {
    this._validate();
    // create structure
    this._create();
    // init events
    this._initEvents();
  };

  ProgressButton.prototype._validate = function() {
    // we will consider the fill/horizontal as default
    if( this.button.getAttribute( 'data-style' ) === null ) {
      this.button.setAttribute( 'data-style', 'fill' );
    }
    if( this.button.getAttribute( 'data-vertical' ) === null && this.button.getAttribute( 'data-horizontal' ) === null ) {
      this.button.setAttribute( 'data-horizontal', '' );
    }
    if( !support.transforms3d && this.button.getAttribute( 'data-perspective' ) !== null ) {
      this.button.removeAttribute( 'data-perspective' );
      this.button.setAttribute( 'data-style', 'fill' );
      this.button.removeAttribute( 'data-vertical' );
      this.button.setAttribute( 'data-horizontal', '' );
    }
  };

  ProgressButton.prototype._create = function() {
    var textEl = document.createElement( 'span' );
    textEl.className = 'content';
    textEl.innerHTML = this.button.innerHTML;
    var progressEl = document.createElement( 'span' );
    progressEl.className = 'progress';

    var progressInnerEl = document.createElement( 'span' );
    progressInnerEl.className = 'progress-inner';
    progressEl.appendChild( progressInnerEl );
    // clear content
    this.button.innerHTML = '';

    if( this.button.getAttribute( 'data-perspective' ) !== null ) {
      var progressWrapEl = document.createElement( 'span' );
      progressWrapEl.className = 'progress-wrap';
      progressWrapEl.appendChild( textEl );
      progressWrapEl.appendChild( progressEl );
      this.button.appendChild( progressWrapEl );
    }
    else {
      this.button.appendChild( textEl );
      this.button.appendChild( progressEl );
    }

    // the element that serves as the progress bar
    this.progress = progressInnerEl;

    // property to change on the progress element
    if( this.button.getAttribute( 'data-horizontal' ) !== null ) {
      this.progressProp = 'width';
    }
    else if( this.button.getAttribute( 'data-vertical' ) !== null ) {
      this.progressProp = 'height';
    }
    this._enable();
  };

  ProgressButton.prototype._setProgress = function( val ) {
    this.progress.style[ this.progressProp ] = 100 * val + '%';
  };

  ProgressButton.prototype._initEvents = function() {
    var self = this;

    var evt = document.createEvent("Event");
    evt.initEvent("StartTimer", true, true);

    var initEventCallback = function() {

      // disable the button
      self.button.setAttribute( 'disabled', '' );
      // add class state-loading to the button (applies a specific transform to the button depending which data-style is defined - defined in the stylesheets)
      classie.remove( self.progress, 'notransition' );
      classie.add( this, 'state-loading' );

      setTimeout( function() {
                if( typeof self.options.callback === 'function' ) {
                  self.options.callback( self );
                }
                else {
                  self._setProgress( 1 );
                  var onEndTransFn = function( ev ) {
                    if( support.transitions && ev.propertyName !== self.progressProp ) return;
                    this.removeEventListener( transEndEventName, onEndTransFn );
                    self._stop();
                  };

                  if( support.transitions ) {
                    self.progress.addEventListener( transEndEventName, onEndTransFn );
                  }
                  else {
                    onEndTransFn.call();
                  }

                }
              },
              self.button.getAttribute( 'data-style' ) === 'fill' ||
              self.button.getAttribute( 'data-style' ) === 'top-line' ||
              self.button.getAttribute( 'data-style' ) === 'lateral-lines' ? 0 : 200 ); // TODO: change timeout to transitionend event callback
    };

    this.button.addEventListener( 'StartTimer', initEventCallback );
    this.button.addEventListener( 'click', initEventCallback );

    this.button.dispatchEvent(evt);

  };

  ProgressButton.prototype._stop = function( status ) {
    var self = this;

    setTimeout( function() {
      // fade out progress bar
      self.progress.style.opacity = 0;
      var onEndTransFn = function( ev ) {
        if( support.transitions && ev.propertyName !== 'opacity' ) return;
        this.removeEventListener( transEndEventName, onEndTransFn );
        classie.add( self.progress, 'notransition' );
        self.progress.style[ self.progressProp ] = '0%';
        self.progress.style.opacity = 1;
      };

      if( support.transitions ) {
        self.progress.addEventListener( transEndEventName, onEndTransFn );
      }
      else {
        onEndTransFn.call();
      }


      // add class state-success to the button
      if( typeof status === 'number' ) {
        var statusClass = status >= 0 ? 'state-success' : 'state-error';
        classie.add( self.button, statusClass );
        // after options.statusTime remove status
        setTimeout( function() {
          classie.remove( self.button, statusClass );
          self._enable();
        }, self.options.statusTime );
      }
      else {
        self._enable();
      }

      // remove class state-loading from the button
      classie.remove( self.button, 'state-loading' );
    }, 100 );
  };

  // enable button
  ProgressButton.prototype._enable = function() {
    this.button.removeAttribute( 'disabled' );
  };

  // add to global namespace
  window.ProgressButton = ProgressButton;

})( window );
!function(e,t,r){"use strict";"function"==typeof window.define&&window.define.amd?window.define(r):"undefined"!=typeof module&&module.exports?module.exports=r():t.exports?t.exports=r():t.Fingerprint2=r()}(0,this,function(){"use strict";var e=function(t){if(!(this instanceof e))return new e(t);this.options=this.extend(t,{swfContainerId:"fingerprintjs2",swfPath:"flash/compiled/FontList.swf",detectScreenOrientation:!0,sortPluginsFor:[/palemoon/i],userDefinedFonts:[],excludeDoNotTrack:!0}),this.nativeForEach=Array.prototype.forEach,this.nativeMap=Array.prototype.map};return e.prototype={extend:function(e,t){if(null==e)return t;for(var r in e)null!=e[r]&&t[r]!==e[r]&&(t[r]=e[r]);return t},get:function(e){var t=this,r={data:[],addPreprocessedComponent:function(e){var n=e.value;"function"==typeof t.options.preprocessor&&(n=t.options.preprocessor(e.key,n)),r.data.push({key:e.key,value:n})}};r=this.userAgentKey(r),r=this.languageKey(r),r=this.colorDepthKey(r),r=this.deviceMemoryKey(r),r=this.pixelRatioKey(r),r=this.hardwareConcurrencyKey(r),r=this.screenResolutionKey(r),r=this.availableScreenResolutionKey(r),r=this.timezoneOffsetKey(r),r=this.sessionStorageKey(r),r=this.localStorageKey(r),r=this.indexedDbKey(r),r=this.addBehaviorKey(r),r=this.openDatabaseKey(r),r=this.cpuClassKey(r),r=this.platformKey(r),r=this.doNotTrackKey(r),r=this.pluginsKey(r),r=this.canvasKey(r),r=this.webglKey(r),r=this.webglVendorAndRendererKey(r),r=this.adBlockKey(r),r=this.hasLiedLanguagesKey(r),r=this.hasLiedResolutionKey(r),r=this.hasLiedOsKey(r),r=this.hasLiedBrowserKey(r),r=this.touchSupportKey(r),r=this.customEntropyFunction(r),this.fontsKey(r,function(r){var n=[];t.each(r.data,function(e){var t=e.value;t&&"function"==typeof t.join&&(t=t.join(";")),n.push(t)});var i=t.x64hash128(n.join("~~~"),31);return e(i,r.data)})},customEntropyFunction:function(e){return"function"==typeof this.options.customFunction&&e.addPreprocessedComponent({key:"custom",value:this.options.customFunction()}),e},userAgentKey:function(e){return this.options.excludeUserAgent||e.addPreprocessedComponent({key:"user_agent",value:this.getUserAgent()}),e},getUserAgent:function(){return navigator.userAgent},languageKey:function(e){return this.options.excludeLanguage||e.addPreprocessedComponent({key:"language",value:navigator.language||navigator.userLanguage||navigator.browserLanguage||navigator.systemLanguage||""}),e},colorDepthKey:function(e){return this.options.excludeColorDepth||e.addPreprocessedComponent({key:"color_depth",value:window.screen.colorDepth||-1}),e},deviceMemoryKey:function(e){return this.options.excludeDeviceMemory||e.addPreprocessedComponent({key:"device_memory",value:this.getDeviceMemory()}),e},getDeviceMemory:function(){return navigator.deviceMemory||-1},pixelRatioKey:function(e){return this.options.excludePixelRatio||e.addPreprocessedComponent({key:"pixel_ratio",value:this.getPixelRatio()}),e},getPixelRatio:function(){return window.devicePixelRatio||""},screenResolutionKey:function(e){return this.options.excludeScreenResolution?e:this.getScreenResolution(e)},getScreenResolution:function(e){var t;return t=this.options.detectScreenOrientation&&window.screen.height>window.screen.width?[window.screen.height,window.screen.width]:[window.screen.width,window.screen.height],e.addPreprocessedComponent({key:"resolution",value:t}),e},availableScreenResolutionKey:function(e){return this.options.excludeAvailableScreenResolution?e:this.getAvailableScreenResolution(e)},getAvailableScreenResolution:function(e){var t;return window.screen.availWidth&&window.screen.availHeight&&(t=this.options.detectScreenOrientation?window.screen.availHeight>window.screen.availWidth?[window.screen.availHeight,window.screen.availWidth]:[window.screen.availWidth,window.screen.availHeight]:[window.screen.availHeight,window.screen.availWidth]),void 0!==t&&e.addPreprocessedComponent({key:"available_resolution",value:t}),e},timezoneOffsetKey:function(e){return this.options.excludeTimezoneOffset||e.addPreprocessedComponent({key:"timezone_offset",value:(new Date).getTimezoneOffset()}),e},sessionStorageKey:function(e){return!this.options.excludeSessionStorage&&this.hasSessionStorage()&&e.addPreprocessedComponent({key:"session_storage",value:1}),e},localStorageKey:function(e){return!this.options.excludeSessionStorage&&this.hasLocalStorage()&&e.addPreprocessedComponent({key:"local_storage",value:1}),e},indexedDbKey:function(e){return!this.options.excludeIndexedDB&&this.hasIndexedDB()&&e.addPreprocessedComponent({key:"indexed_db",value:1}),e},addBehaviorKey:function(e){return!this.options.excludeAddBehavior&&document.body&&document.body.addBehavior&&e.addPreprocessedComponent({key:"add_behavior",value:1}),e},openDatabaseKey:function(e){return!this.options.excludeOpenDatabase&&window.openDatabase&&e.addPreprocessedComponent({key:"open_database",value:1}),e},cpuClassKey:function(e){return this.options.excludeCpuClass||e.addPreprocessedComponent({key:"cpu_class",value:this.getNavigatorCpuClass()}),e},platformKey:function(e){return this.options.excludePlatform||e.addPreprocessedComponent({key:"navigator_platform",value:this.getNavigatorPlatform()}),e},doNotTrackKey:function(e){return this.options.excludeDoNotTrack||e.addPreprocessedComponent({key:"do_not_track",value:this.getDoNotTrack()}),e},canvasKey:function(e){return!this.options.excludeCanvas&&this.isCanvasSupported()&&e.addPreprocessedComponent({key:"canvas",value:this.getCanvasFp()}),e},webglKey:function(e){return!this.options.excludeWebGL&&this.isWebGlSupported()&&e.addPreprocessedComponent({key:"webgl",value:this.getWebglFp()}),e},webglVendorAndRendererKey:function(e){return!this.options.excludeWebGLVendorAndRenderer&&this.isWebGlSupported()&&e.addPreprocessedComponent({key:"webgl_vendor",value:this.getWebglVendorAndRenderer()}),e},adBlockKey:function(e){return this.options.excludeAdBlock||e.addPreprocessedComponent({key:"adblock",value:this.getAdBlock()}),e},hasLiedLanguagesKey:function(e){return this.options.excludeHasLiedLanguages||e.addPreprocessedComponent({key:"has_lied_languages",value:this.getHasLiedLanguages()}),e},hasLiedResolutionKey:function(e){return this.options.excludeHasLiedResolution||e.addPreprocessedComponent({key:"has_lied_resolution",value:this.getHasLiedResolution()}),e},hasLiedOsKey:function(e){return this.options.excludeHasLiedOs||e.addPreprocessedComponent({key:"has_lied_os",value:this.getHasLiedOs()}),e},hasLiedBrowserKey:function(e){return this.options.excludeHasLiedBrowser||e.addPreprocessedComponent({key:"has_lied_browser",value:this.getHasLiedBrowser()}),e},fontsKey:function(e,t){return this.options.excludeJsFonts?this.flashFontsKey(e,t):this.jsFontsKey(e,t)},flashFontsKey:function(e,t){return this.options.excludeFlashFonts?t(e):this.hasSwfObjectLoaded()&&this.hasMinFlashInstalled()?void 0===this.options.swfPath?t(e):void this.loadSwfAndDetectFonts(function(r){e.addPreprocessedComponent({key:"swf_fonts",value:r.join(";")}),t(e)}):t(e)},jsFontsKey:function(e,t){var r=this;return setTimeout(function(){var n=["monospace","sans-serif","serif"],i=["Andale Mono","Arial","Arial Black","Arial Hebrew","Arial MT","Arial Narrow","Arial Rounded MT Bold","Arial Unicode MS","Bitstream Vera Sans Mono","Book Antiqua","Bookman Old Style","Calibri","Cambria","Cambria Math","Century","Century Gothic","Century Schoolbook","Comic Sans","Comic Sans MS","Consolas","Courier","Courier New","Garamond","Geneva","Georgia","Helvetica","Helvetica Neue","Impact","Lucida Bright","Lucida Calligraphy","Lucida Console","Lucida Fax","LUCIDA GRANDE","Lucida Handwriting","Lucida Sans","Lucida Sans Typewriter","Lucida Sans Unicode","Microsoft Sans Serif","Monaco","Monotype Corsiva","MS Gothic","MS Outlook","MS PGothic","MS Reference Sans Serif","MS Sans Serif","MS Serif","MYRIAD","MYRIAD PRO","Palatino","Palatino Linotype","Segoe Print","Segoe Script","Segoe UI","Segoe UI Light","Segoe UI Semibold","Segoe UI Symbol","Tahoma","Times","Times New Roman","Times New Roman PS","Trebuchet MS","Verdana","Wingdings","Wingdings 2","Wingdings 3"];r.options.extendedJsFonts&&(i=i.concat(["Abadi MT Condensed Light","Academy Engraved LET","ADOBE CASLON PRO","Adobe Garamond","ADOBE GARAMOND PRO","Agency FB","Aharoni","Albertus Extra Bold","Albertus Medium","Algerian","Amazone BT","American Typewriter","American Typewriter Condensed","AmerType Md BT","Andalus","Angsana New","AngsanaUPC","Antique Olive","Aparajita","Apple Chancery","Apple Color Emoji","Apple SD Gothic Neo","Arabic Typesetting","ARCHER","ARNO PRO","Arrus BT","Aurora Cn BT","AvantGarde Bk BT","AvantGarde Md BT","AVENIR","Ayuthaya","Bandy","Bangla Sangam MN","Bank Gothic","BankGothic Md BT","Baskerville","Baskerville Old Face","Batang","BatangChe","Bauer Bodoni","Bauhaus 93","Bazooka","Bell MT","Bembo","Benguiat Bk BT","Berlin Sans FB","Berlin Sans FB Demi","Bernard MT Condensed","BernhardFashion BT","BernhardMod BT","Big Caslon","BinnerD","Blackadder ITC","BlairMdITC TT","Bodoni 72","Bodoni 72 Oldstyle","Bodoni 72 Smallcaps","Bodoni MT","Bodoni MT Black","Bodoni MT Condensed","Bodoni MT Poster Compressed","Bookshelf Symbol 7","Boulder","Bradley Hand","Bradley Hand ITC","Bremen Bd BT","Britannic Bold","Broadway","Browallia New","BrowalliaUPC","Brush Script MT","Californian FB","Calisto MT","Calligrapher","Candara","CaslonOpnface BT","Castellar","Centaur","Cezanne","CG Omega","CG Times","Chalkboard","Chalkboard SE","Chalkduster","Charlesworth","Charter Bd BT","Charter BT","Chaucer","ChelthmITC Bk BT","Chiller","Clarendon","Clarendon Condensed","CloisterBlack BT","Cochin","Colonna MT","Constantia","Cooper Black","Copperplate","Copperplate Gothic","Copperplate Gothic Bold","Copperplate Gothic Light","CopperplGoth Bd BT","Corbel","Cordia New","CordiaUPC","Cornerstone","Coronet","Cuckoo","Curlz MT","DaunPenh","Dauphin","David","DB LCD Temp","DELICIOUS","Denmark","DFKai-SB","Didot","DilleniaUPC","DIN","DokChampa","Dotum","DotumChe","Ebrima","Edwardian Script ITC","Elephant","English 111 Vivace BT","Engravers MT","EngraversGothic BT","Eras Bold ITC","Eras Demi ITC","Eras Light ITC","Eras Medium ITC","EucrosiaUPC","Euphemia","Euphemia UCAS","EUROSTILE","Exotc350 Bd BT","FangSong","Felix Titling","Fixedsys","FONTIN","Footlight MT Light","Forte","FrankRuehl","Fransiscan","Freefrm721 Blk BT","FreesiaUPC","Freestyle Script","French Script MT","FrnkGothITC Bk BT","Fruitger","FRUTIGER","Futura","Futura Bk BT","Futura Lt BT","Futura Md BT","Futura ZBlk BT","FuturaBlack BT","Gabriola","Galliard BT","Gautami","Geeza Pro","Geometr231 BT","Geometr231 Hv BT","Geometr231 Lt BT","GeoSlab 703 Lt BT","GeoSlab 703 XBd BT","Gigi","Gill Sans","Gill Sans MT","Gill Sans MT Condensed","Gill Sans MT Ext Condensed Bold","Gill Sans Ultra Bold","Gill Sans Ultra Bold Condensed","Gisha","Gloucester MT Extra Condensed","GOTHAM","GOTHAM BOLD","Goudy Old Style","Goudy Stout","GoudyHandtooled BT","GoudyOLSt BT","Gujarati Sangam MN","Gulim","GulimChe","Gungsuh","GungsuhChe","Gurmukhi MN","Haettenschweiler","Harlow Solid Italic","Harrington","Heather","Heiti SC","Heiti TC","HELV","Herald","High Tower Text","Hiragino Kaku Gothic ProN","Hiragino Mincho ProN","Hoefler Text","Humanst 521 Cn BT","Humanst521 BT","Humanst521 Lt BT","Imprint MT Shadow","Incised901 Bd BT","Incised901 BT","Incised901 Lt BT","INCONSOLATA","Informal Roman","Informal011 BT","INTERSTATE","IrisUPC","Iskoola Pota","JasmineUPC","Jazz LET","Jenson","Jester","Jokerman","Juice ITC","Kabel Bk BT","Kabel Ult BT","Kailasa","KaiTi","Kalinga","Kannada Sangam MN","Kartika","Kaufmann Bd BT","Kaufmann BT","Khmer UI","KodchiangUPC","Kokila","Korinna BT","Kristen ITC","Krungthep","Kunstler Script","Lao UI","Latha","Leelawadee","Letter Gothic","Levenim MT","LilyUPC","Lithograph","Lithograph Light","Long Island","Lydian BT","Magneto","Maiandra GD","Malayalam Sangam MN","Malgun Gothic","Mangal","Marigold","Marion","Marker Felt","Market","Marlett","Matisse ITC","Matura MT Script Capitals","Meiryo","Meiryo UI","Microsoft Himalaya","Microsoft JhengHei","Microsoft New Tai Lue","Microsoft PhagsPa","Microsoft Tai Le","Microsoft Uighur","Microsoft YaHei","Microsoft Yi Baiti","MingLiU","MingLiU_HKSCS","MingLiU_HKSCS-ExtB","MingLiU-ExtB","Minion","Minion Pro","Miriam","Miriam Fixed","Mistral","Modern","Modern No. 20","Mona Lisa Solid ITC TT","Mongolian Baiti","MONO","MoolBoran","Mrs Eaves","MS LineDraw","MS Mincho","MS PMincho","MS Reference Specialty","MS UI Gothic","MT Extra","MUSEO","MV Boli","Nadeem","Narkisim","NEVIS","News Gothic","News GothicMT","NewsGoth BT","Niagara Engraved","Niagara Solid","Noteworthy","NSimSun","Nyala","OCR A Extended","Old Century","Old English Text MT","Onyx","Onyx BT","OPTIMA","Oriya Sangam MN","OSAKA","OzHandicraft BT","Palace Script MT","Papyrus","Parchment","Party LET","Pegasus","Perpetua","Perpetua Titling MT","PetitaBold","Pickwick","Plantagenet Cherokee","Playbill","PMingLiU","PMingLiU-ExtB","Poor Richard","Poster","PosterBodoni BT","PRINCETOWN LET","Pristina","PTBarnum BT","Pythagoras","Raavi","Rage Italic","Ravie","Ribbon131 Bd BT","Rockwell","Rockwell Condensed","Rockwell Extra Bold","Rod","Roman","Sakkal Majalla","Santa Fe LET","Savoye LET","Sceptre","Script","Script MT Bold","SCRIPTINA","Serifa","Serifa BT","Serifa Th BT","ShelleyVolante BT","Sherwood","Shonar Bangla","Showcard Gothic","Shruti","Signboard","SILKSCREEN","SimHei","Simplified Arabic","Simplified Arabic Fixed","SimSun","SimSun-ExtB","Sinhala Sangam MN","Sketch Rockwell","Skia","Small Fonts","Snap ITC","Snell Roundhand","Socket","Souvenir Lt BT","Staccato222 BT","Steamer","Stencil","Storybook","Styllo","Subway","Swis721 BlkEx BT","Swiss911 XCm BT","Sylfaen","Synchro LET","System","Tamil Sangam MN","Technical","Teletype","Telugu Sangam MN","Tempus Sans ITC","Terminal","Thonburi","Traditional Arabic","Trajan","TRAJAN PRO","Tristan","Tubular","Tunga","Tw Cen MT","Tw Cen MT Condensed","Tw Cen MT Condensed Extra Bold","TypoUpright BT","Unicorn","Univers","Univers CE 55 Medium","Univers Condensed","Utsaah","Vagabond","Vani","Vijaya","Viner Hand ITC","VisualUI","Vivaldi","Vladimir Script","Vrinda","Westminster","WHITNEY","Wide Latin","ZapfEllipt BT","ZapfHumnst BT","ZapfHumnst Dm BT","Zapfino","Zurich BlkEx BT","Zurich Ex BT","ZWAdobeF"])),i=(i=i.concat(r.options.userDefinedFonts)).filter(function(e,t){return i.indexOf(e)===t});var a=document.getElementsByTagName("body")[0],o=document.createElement("div"),s=document.createElement("div"),l={},d={},h=function(){var e=document.createElement("span");return e.style.position="absolute",e.style.left="-9999px",e.style.fontSize="72px",e.style.fontStyle="normal",e.style.fontWeight="normal",e.style.letterSpacing="normal",e.style.lineBreak="auto",e.style.lineHeight="normal",e.style.texTransform="none",e.style.textAlign="left",e.style.textDecoration="none",e.style.textShadow="none",e.style.whiteSpace="normal",e.style.wordBreak="normal",e.style.wordSpacing="normal",e.innerHTML="mmmmmmmmmmlli",e},c=function(e){for(var t=!1,r=0;r<n.length;r++)if(t=e[r].offsetWidth!==l[n[r]]||e[r].offsetHeight!==d[n[r]])return t;return t},u=function(){for(var e=[],t=0,r=n.length;t<r;t++){var i=h();i.style.fontFamily=n[t],o.appendChild(i),e.push(i)}return e}();a.appendChild(o);for(var g=0,p=n.length;g<p;g++)l[n[g]]=u[g].offsetWidth,d[n[g]]=u[g].offsetHeight;var m=function(){for(var e,t,r,a={},o=0,l=i.length;o<l;o++){for(var d=[],c=0,u=n.length;c<u;c++){var g=(e=i[o],t=n[c],r=void 0,(r=h()).style.fontFamily="'"+e+"',"+t,r);s.appendChild(g),d.push(g)}a[i[o]]=d}return a}();a.appendChild(s);for(var f=[],S=0,T=i.length;S<T;S++)c(m[i[S]])&&f.push(i[S]);a.removeChild(s),a.removeChild(o),e.addPreprocessedComponent({key:"js_fonts",value:f}),t(e)},1)},pluginsKey:function(e){return this.options.excludePlugins||(this.isIE()?this.options.excludeIEPlugins||e.addPreprocessedComponent({key:"ie_plugins",value:this.getIEPlugins()}):e.addPreprocessedComponent({key:"regular_plugins",value:this.getRegularPlugins()})),e},getRegularPlugins:function(){var e=[];if(navigator.plugins)for(var t=0,r=navigator.plugins.length;t<r;t++)navigator.plugins[t]&&e.push(navigator.plugins[t]);return this.pluginsShouldBeSorted()&&(e=e.sort(function(e,t){return e.name>t.name?1:e.name<t.name?-1:0})),this.map(e,function(e){var t=this.map(e,function(e){return[e.type,e.suffixes].join("~")}).join(",");return[e.name,e.description,t].join("::")},this)},getIEPlugins:function(){var e=[];if(Object.getOwnPropertyDescriptor&&Object.getOwnPropertyDescriptor(window,"ActiveXObject")||"ActiveXObject"in window){e=this.map(["AcroPDF.PDF","Adodb.Stream","AgControl.AgControl","DevalVRXCtrl.DevalVRXCtrl.1","MacromediaFlashPaper.MacromediaFlashPaper","Msxml2.DOMDocument","Msxml2.XMLHTTP","PDF.PdfCtrl","QuickTime.QuickTime","QuickTimeCheckObject.QuickTimeCheck.1","RealPlayer","RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)","RealVideo.RealVideo(tm) ActiveX Control (32-bit)","Scripting.Dictionary","SWCtl.SWCtl","Shell.UIHelper","ShockwaveFlash.ShockwaveFlash","Skype.Detection","TDCCtl.TDCCtl","WMPlayer.OCX","rmocx.RealPlayer G2 Control","rmocx.RealPlayer G2 Control.1"],function(e){try{return new window.ActiveXObject(e),e}catch(e){return null}})}return navigator.plugins&&(e=e.concat(this.getRegularPlugins())),e},pluginsShouldBeSorted:function(){for(var e=!1,t=0,r=this.options.sortPluginsFor.length;t<r;t++){var n=this.options.sortPluginsFor[t];if(navigator.userAgent.match(n)){e=!0;break}}return e},touchSupportKey:function(e){return this.options.excludeTouchSupport||e.addPreprocessedComponent({key:"touch_support",value:this.getTouchSupport()}),e},hardwareConcurrencyKey:function(e){return this.options.excludeHardwareConcurrency||e.addPreprocessedComponent({key:"hardware_concurrency",value:this.getHardwareConcurrency()}),e},hasSessionStorage:function(){try{return!!window.sessionStorage}catch(e){return!0}},hasLocalStorage:function(){try{return!!window.localStorage}catch(e){return!0}},hasIndexedDB:function(){try{return!!window.indexedDB}catch(e){return!0}},getHardwareConcurrency:function(){return navigator.hardwareConcurrency?navigator.hardwareConcurrency:"unknown"},getNavigatorCpuClass:function(){return navigator.cpuClass?navigator.cpuClass:"unknown"},getNavigatorPlatform:function(){return navigator.platform?navigator.platform:"unknown"},getDoNotTrack:function(){return navigator.doNotTrack?navigator.doNotTrack:navigator.msDoNotTrack?navigator.msDoNotTrack:window.doNotTrack?window.doNotTrack:"unknown"},getTouchSupport:function(){var e=0,t=!1;void 0!==navigator.maxTouchPoints?e=navigator.maxTouchPoints:void 0!==navigator.msMaxTouchPoints&&(e=navigator.msMaxTouchPoints);try{document.createEvent("TouchEvent"),t=!0}catch(e){}return[e,t,"ontouchstart"in window]},getCanvasFp:function(){var e=[],t=document.createElement("canvas");t.width=2e3,t.height=200,t.style.display="inline";var r=t.getContext("2d");return r.rect(0,0,10,10),r.rect(2,2,6,6),e.push("canvas winding:"+(!1===r.isPointInPath(5,5,"evenodd")?"yes":"no")),r.textBaseline="alphabetic",r.fillStyle="#f60",r.fillRect(125,1,62,20),r.fillStyle="#069",this.options.dontUseFakeFontInCanvas?r.font="11pt Arial":r.font="11pt no-real-font-123",r.fillText("Cwm fjordbank glyphs vext quiz, \ud83d\ude03",2,15),r.fillStyle="rgba(102, 204, 0, 0.2)",r.font="18pt Arial",r.fillText("Cwm fjordbank glyphs vext quiz, \ud83d\ude03",4,45),r.globalCompositeOperation="multiply",r.fillStyle="rgb(255,0,255)",r.beginPath(),r.arc(50,50,50,0,2*Math.PI,!0),r.closePath(),r.fill(),r.fillStyle="rgb(0,255,255)",r.beginPath(),r.arc(100,50,50,0,2*Math.PI,!0),r.closePath(),r.fill(),r.fillStyle="rgb(255,255,0)",r.beginPath(),r.arc(75,100,50,0,2*Math.PI,!0),r.closePath(),r.fill(),r.fillStyle="rgb(255,0,255)",r.arc(75,75,75,0,2*Math.PI,!0),r.arc(75,75,25,0,2*Math.PI,!0),r.fill("evenodd"),t.toDataURL&&e.push("canvas fp:"+t.toDataURL()),e.join("~")},getWebglFp:function(){var e,t=function(t){return e.clearColor(0,0,0,1),e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),"["+t[0]+", "+t[1]+"]"};if(!(e=this.getWebglCanvas()))return null;var r=[],n=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,n);var i=new Float32Array([-.2,-.9,0,.4,-.26,0,0,.732134444,0]);e.bufferData(e.ARRAY_BUFFER,i,e.STATIC_DRAW),n.itemSize=3,n.numItems=3;var a=e.createProgram(),o=e.createShader(e.VERTEX_SHADER);e.shaderSource(o,"attribute vec2 attrVertex;varying vec2 varyinTexCoordinate;uniform vec2 uniformOffset;void main(){varyinTexCoordinate=attrVertex+uniformOffset;gl_Position=vec4(attrVertex,0,1);}"),e.compileShader(o);var s=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(s,"precision mediump float;varying vec2 varyinTexCoordinate;void main() {gl_FragColor=vec4(varyinTexCoordinate,0,1);}"),e.compileShader(s),e.attachShader(a,o),e.attachShader(a,s),e.linkProgram(a),e.useProgram(a),a.vertexPosAttrib=e.getAttribLocation(a,"attrVertex"),a.offsetUniform=e.getUniformLocation(a,"uniformOffset"),e.enableVertexAttribArray(a.vertexPosArray),e.vertexAttribPointer(a.vertexPosAttrib,n.itemSize,e.FLOAT,!1,0,0),e.uniform2f(a.offsetUniform,1,1),e.drawArrays(e.TRIANGLE_STRIP,0,n.numItems);try{r.push(e.canvas.toDataURL())}catch(e){}r.push("extensions:"+(e.getSupportedExtensions()||[]).join(";")),r.push("webgl aliased line width range:"+t(e.getParameter(e.ALIASED_LINE_WIDTH_RANGE))),r.push("webgl aliased point size range:"+t(e.getParameter(e.ALIASED_POINT_SIZE_RANGE))),r.push("webgl alpha bits:"+e.getParameter(e.ALPHA_BITS)),r.push("webgl antialiasing:"+(e.getContextAttributes().antialias?"yes":"no")),r.push("webgl blue bits:"+e.getParameter(e.BLUE_BITS)),r.push("webgl depth bits:"+e.getParameter(e.DEPTH_BITS)),r.push("webgl green bits:"+e.getParameter(e.GREEN_BITS)),r.push("webgl max anisotropy:"+function(e){var t=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic");if(t){var r=e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT);return 0===r&&(r=2),r}return null}(e)),r.push("webgl max combined texture image units:"+e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),r.push("webgl max cube map texture size:"+e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)),r.push("webgl max fragment uniform vectors:"+e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)),r.push("webgl max render buffer size:"+e.getParameter(e.MAX_RENDERBUFFER_SIZE)),r.push("webgl max texture image units:"+e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)),r.push("webgl max texture size:"+e.getParameter(e.MAX_TEXTURE_SIZE)),r.push("webgl max varying vectors:"+e.getParameter(e.MAX_VARYING_VECTORS)),r.push("webgl max vertex attribs:"+e.getParameter(e.MAX_VERTEX_ATTRIBS)),r.push("webgl max vertex texture image units:"+e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)),r.push("webgl max vertex uniform vectors:"+e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)),r.push("webgl max viewport dims:"+t(e.getParameter(e.MAX_VIEWPORT_DIMS))),r.push("webgl red bits:"+e.getParameter(e.RED_BITS)),r.push("webgl renderer:"+e.getParameter(e.RENDERER)),r.push("webgl shading language version:"+e.getParameter(e.SHADING_LANGUAGE_VERSION)),r.push("webgl stencil bits:"+e.getParameter(e.STENCIL_BITS)),r.push("webgl vendor:"+e.getParameter(e.VENDOR)),r.push("webgl version:"+e.getParameter(e.VERSION));try{var l=e.getExtension("WEBGL_debug_renderer_info");l&&(r.push("webgl unmasked vendor:"+e.getParameter(l.UNMASKED_VENDOR_WEBGL)),r.push("webgl unmasked renderer:"+e.getParameter(l.UNMASKED_RENDERER_WEBGL)))}catch(e){}return e.getShaderPrecisionFormat?(r.push("webgl vertex shader high float precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision),r.push("webgl vertex shader high float precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).rangeMin),r.push("webgl vertex shader high float precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).rangeMax),r.push("webgl vertex shader medium float precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision),r.push("webgl vertex shader medium float precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).rangeMin),r.push("webgl vertex shader medium float precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).rangeMax),r.push("webgl vertex shader low float precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_FLOAT).precision),r.push("webgl vertex shader low float precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_FLOAT).rangeMin),r.push("webgl vertex shader low float precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_FLOAT).rangeMax),r.push("webgl fragment shader high float precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision),r.push("webgl fragment shader high float precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).rangeMin),r.push("webgl fragment shader high float precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).rangeMax),r.push("webgl fragment shader medium float precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision),r.push("webgl fragment shader medium float precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).rangeMin),r.push("webgl fragment shader medium float precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).rangeMax),r.push("webgl fragment shader low float precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_FLOAT).precision),r.push("webgl fragment shader low float precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_FLOAT).rangeMin),r.push("webgl fragment shader low float precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_FLOAT).rangeMax),r.push("webgl vertex shader high int precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_INT).precision),r.push("webgl vertex shader high int precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_INT).rangeMin),r.push("webgl vertex shader high int precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_INT).rangeMax),r.push("webgl vertex shader medium int precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_INT).precision),r.push("webgl vertex shader medium int precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_INT).rangeMin),r.push("webgl vertex shader medium int precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_INT).rangeMax),r.push("webgl vertex shader low int precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_INT).precision),r.push("webgl vertex shader low int precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_INT).rangeMin),r.push("webgl vertex shader low int precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_INT).rangeMax),r.push("webgl fragment shader high int precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_INT).precision),r.push("webgl fragment shader high int precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_INT).rangeMin),r.push("webgl fragment shader high int precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_INT).rangeMax),r.push("webgl fragment shader medium int precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_INT).precision),r.push("webgl fragment shader medium int precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_INT).rangeMin),r.push("webgl fragment shader medium int precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_INT).rangeMax),r.push("webgl fragment shader low int precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_INT).precision),r.push("webgl fragment shader low int precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_INT).rangeMin),r.push("webgl fragment shader low int precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_INT).rangeMax),r.join("~")):r.join("~")},getWebglVendorAndRenderer:function(){try{var e=this.getWebglCanvas(),t=e.getExtension("WEBGL_debug_renderer_info");return e.getParameter(t.UNMASKED_VENDOR_WEBGL)+"~"+e.getParameter(t.UNMASKED_RENDERER_WEBGL)}catch(e){return null}},getAdBlock:function(){var e=document.createElement("div");e.innerHTML="&nbsp;",e.className="adsbox";var t=!1;try{document.body.appendChild(e),t=0===document.getElementsByClassName("adsbox")[0].offsetHeight,document.body.removeChild(e)}catch(e){t=!1}return t},getHasLiedLanguages:function(){if(void 0!==navigator.languages)try{if(navigator.languages[0].substr(0,2)!==navigator.language.substr(0,2))return!0}catch(e){return!0}return!1},getHasLiedResolution:function(){return window.screen.width<window.screen.availWidth||window.screen.height<window.screen.availHeight},getHasLiedOs:function(){var e,t=navigator.userAgent.toLowerCase(),r=navigator.oscpu,n=navigator.platform.toLowerCase();if(e=t.indexOf("windows phone")>=0?"Windows Phone":t.indexOf("win")>=0?"Windows":t.indexOf("android")>=0?"Android":t.indexOf("linux")>=0?"Linux":t.indexOf("iphone")>=0||t.indexOf("ipad")>=0?"iOS":t.indexOf("mac")>=0?"Mac":"Other",("ontouchstart"in window||navigator.maxTouchPoints>0||navigator.msMaxTouchPoints>0)&&"Windows Phone"!==e&&"Android"!==e&&"iOS"!==e&&"Other"!==e)return!0;if(void 0!==r){if((r=r.toLowerCase()).indexOf("win")>=0&&"Windows"!==e&&"Windows Phone"!==e)return!0;if(r.indexOf("linux")>=0&&"Linux"!==e&&"Android"!==e)return!0;if(r.indexOf("mac")>=0&&"Mac"!==e&&"iOS"!==e)return!0;if((-1===r.indexOf("win")&&-1===r.indexOf("linux")&&-1===r.indexOf("mac"))!=("Other"===e))return!0}return n.indexOf("win")>=0&&"Windows"!==e&&"Windows Phone"!==e||((n.indexOf("linux")>=0||n.indexOf("android")>=0||n.indexOf("pike")>=0)&&"Linux"!==e&&"Android"!==e||((n.indexOf("mac")>=0||n.indexOf("ipad")>=0||n.indexOf("ipod")>=0||n.indexOf("iphone")>=0)&&"Mac"!==e&&"iOS"!==e||((-1===n.indexOf("win")&&-1===n.indexOf("linux")&&-1===n.indexOf("mac"))!=("Other"===e)||void 0===navigator.plugins&&"Windows"!==e&&"Windows Phone"!==e)))},getHasLiedBrowser:function(){var e,t=navigator.userAgent.toLowerCase(),r=navigator.productSub;if(("Chrome"===(e=t.indexOf("firefox")>=0?"Firefox":t.indexOf("opera")>=0||t.indexOf("opr")>=0?"Opera":t.indexOf("chrome")>=0?"Chrome":t.indexOf("safari")>=0?"Safari":t.indexOf("trident")>=0?"Internet Explorer":"Other")||"Safari"===e||"Opera"===e)&&"20030107"!==r)return!0;var n,i=eval.toString().length;if(37===i&&"Safari"!==e&&"Firefox"!==e&&"Other"!==e)return!0;if(39===i&&"Internet Explorer"!==e&&"Other"!==e)return!0;if(33===i&&"Chrome"!==e&&"Opera"!==e&&"Other"!==e)return!0;try{throw"a"}catch(e){try{e.toSource(),n=!0}catch(e){n=!1}}return!(!n||"Firefox"===e||"Other"===e)},isCanvasSupported:function(){var e=document.createElement("canvas");return!(!e.getContext||!e.getContext("2d"))},isWebGlSupported:function(){if(!this.isCanvasSupported())return!1;var e=this.getWebglCanvas();return!!window.WebGLRenderingContext&&!!e},isIE:function(){return"Microsoft Internet Explorer"===navigator.appName||!("Netscape"!==navigator.appName||!/Trident/.test(navigator.userAgent))},hasSwfObjectLoaded:function(){return void 0!==window.swfobject},hasMinFlashInstalled:function(){return window.swfobject.hasFlashPlayerVersion("9.0.0")},addFlashDivNode:function(){var e=document.createElement("div");e.setAttribute("id",this.options.swfContainerId),document.body.appendChild(e)},loadSwfAndDetectFonts:function(e){var t="___fp_swf_loaded";window[t]=function(t){e(t)};var r=this.options.swfContainerId;this.addFlashDivNode();var n={onReady:t};window.swfobject.embedSWF(this.options.swfPath,r,"1","1","9.0.0",!1,n,{allowScriptAccess:"always",menu:"false"},{})},getWebglCanvas:function(){var e=document.createElement("canvas"),t=null;try{t=e.getContext("webgl")||e.getContext("experimental-webgl")}catch(e){}return t||(t=null),t},each:function(e,t,r){if(null!==e)if(this.nativeForEach&&e.forEach===this.nativeForEach)e.forEach(t,r);else if(e.length===+e.length){for(var n=0,i=e.length;n<i;n++)if(t.call(r,e[n],n,e)==={})return}else for(var a in e)if(e.hasOwnProperty(a)&&t.call(r,e[a],a,e)==={})return},map:function(e,t,r){var n=[];return null==e?n:this.nativeMap&&e.map===this.nativeMap?e.map(t,r):(this.each(e,function(e,i,a){n[n.length]=t.call(r,e,i,a)}),n)},x64Add:function(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var r=[0,0,0,0];return r[3]+=e[3]+t[3],r[2]+=r[3]>>>16,r[3]&=65535,r[2]+=e[2]+t[2],r[1]+=r[2]>>>16,r[2]&=65535,r[1]+=e[1]+t[1],r[0]+=r[1]>>>16,r[1]&=65535,r[0]+=e[0]+t[0],r[0]&=65535,[r[0]<<16|r[1],r[2]<<16|r[3]]},x64Multiply:function(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var r=[0,0,0,0];return r[3]+=e[3]*t[3],r[2]+=r[3]>>>16,r[3]&=65535,r[2]+=e[2]*t[3],r[1]+=r[2]>>>16,r[2]&=65535,r[2]+=e[3]*t[2],r[1]+=r[2]>>>16,r[2]&=65535,r[1]+=e[1]*t[3],r[0]+=r[1]>>>16,r[1]&=65535,r[1]+=e[2]*t[2],r[0]+=r[1]>>>16,r[1]&=65535,r[1]+=e[3]*t[1],r[0]+=r[1]>>>16,r[1]&=65535,r[0]+=e[0]*t[3]+e[1]*t[2]+e[2]*t[1]+e[3]*t[0],r[0]&=65535,[r[0]<<16|r[1],r[2]<<16|r[3]]},x64Rotl:function(e,t){return 32===(t%=64)?[e[1],e[0]]:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t|e[0]>>>32-t]:(t-=32,[e[1]<<t|e[0]>>>32-t,e[0]<<t|e[1]>>>32-t])},x64LeftShift:function(e,t){return 0===(t%=64)?e:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t]:[e[1]<<t-32,0]},x64Xor:function(e,t){return[e[0]^t[0],e[1]^t[1]]},x64Fmix:function(e){return e=this.x64Xor(e,[0,e[0]>>>1]),e=this.x64Multiply(e,[4283543511,3981806797]),e=this.x64Xor(e,[0,e[0]>>>1]),e=this.x64Multiply(e,[3301882366,444984403]),e=this.x64Xor(e,[0,e[0]>>>1])},x64hash128:function(e,t){t=t||0;for(var r=(e=e||"").length%16,n=e.length-r,i=[0,t],a=[0,t],o=[0,0],s=[0,0],l=[2277735313,289559509],d=[1291169091,658871167],h=0;h<n;h+=16)o=[255&e.charCodeAt(h+4)|(255&e.charCodeAt(h+5))<<8|(255&e.charCodeAt(h+6))<<16|(255&e.charCodeAt(h+7))<<24,255&e.charCodeAt(h)|(255&e.charCodeAt(h+1))<<8|(255&e.charCodeAt(h+2))<<16|(255&e.charCodeAt(h+3))<<24],s=[255&e.charCodeAt(h+12)|(255&e.charCodeAt(h+13))<<8|(255&e.charCodeAt(h+14))<<16|(255&e.charCodeAt(h+15))<<24,255&e.charCodeAt(h+8)|(255&e.charCodeAt(h+9))<<8|(255&e.charCodeAt(h+10))<<16|(255&e.charCodeAt(h+11))<<24],o=this.x64Multiply(o,l),o=this.x64Rotl(o,31),o=this.x64Multiply(o,d),i=this.x64Xor(i,o),i=this.x64Rotl(i,27),i=this.x64Add(i,a),i=this.x64Add(this.x64Multiply(i,[0,5]),[0,1390208809]),s=this.x64Multiply(s,d),s=this.x64Rotl(s,33),s=this.x64Multiply(s,l),a=this.x64Xor(a,s),a=this.x64Rotl(a,31),a=this.x64Add(a,i),a=this.x64Add(this.x64Multiply(a,[0,5]),[0,944331445]);switch(o=[0,0],s=[0,0],r){case 15:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+14)],48));case 14:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+13)],40));case 13:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+12)],32));case 12:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+11)],24));case 11:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+10)],16));case 10:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+9)],8));case 9:s=this.x64Xor(s,[0,e.charCodeAt(h+8)]),s=this.x64Multiply(s,d),s=this.x64Rotl(s,33),s=this.x64Multiply(s,l),a=this.x64Xor(a,s);case 8:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+7)],56));case 7:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+6)],48));case 6:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+5)],40));case 5:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+4)],32));case 4:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+3)],24));case 3:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+2)],16));case 2:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+1)],8));case 1:o=this.x64Xor(o,[0,e.charCodeAt(h)]),o=this.x64Multiply(o,l),o=this.x64Rotl(o,31),o=this.x64Multiply(o,d),i=this.x64Xor(i,o)}return i=this.x64Xor(i,[0,e.length]),a=this.x64Xor(a,[0,e.length]),i=this.x64Add(i,a),a=this.x64Add(a,i),i=this.x64Fmix(i),a=this.x64Fmix(a),i=this.x64Add(i,a),a=this.x64Add(a,i),("00000000"+(i[0]>>>0).toString(16)).slice(-8)+("00000000"+(i[1]>>>0).toString(16)).slice(-8)+("00000000"+(a[0]>>>0).toString(16)).slice(-8)+("00000000"+(a[1]>>>0).toString(16)).slice(-8)}},e.VERSION="1.6.1-dev",e});/**
 * Omerta kernel
 * Initialize all the skel
 */

var omerta = {

    // Vars
    timers:		{},

    // Core
    framework:	{},
    core:       {},

    // Models (datasets)
    model:      {},

    // Workers
    services: 	{},
    modules:    {},
    widgets:    {},


    // User Interface
    UI:		{},
    popup:  {},

    // Server
    server: {
        clock: 0
    },

    // Temp crap
    plugins: {},
    GUI:        {},

  //Online users
    users: ko.observableArray(),

    windowFocus: true,

  //Store the round version of the game
  roundVersion: ko.observable()
};
/**
 * Server
 * Server functions
 */
omerta.server = {
    time:   0,
    url:    window.location.host,

    query: function(_type, _url, _data, _callback, _error) {
        $.ajax({
            url:        '/'+ _url,
            data:       _data,
            type:       _type,
            success:    function (response) { omerta.server.getCB(response,_callback, _error); },
            error:      (_error?_error:omerta.server.error),
            dataType:   'JSON'
        });
    },
    getCB: function (response, callback, ecallback) {
        if (response.OK == undefined)
            callback(response);
        else if (response.OK)
            callback(response);
        else if (ecallback)
            ecallback(response, 'ecallback defined');
        else
            omerta.server.error(response, 'ecallback not defined');
    },
    error: function(response, why) {
        console.error("Server request failed:", why, response);
    }
};

/**
 * Debug
 * Debug functions
 */

omerta.debug =     function (page, request, error) {
    var post = {page: page, request: request, error: error};
    $.post('/ajax_debug.php', post);
};


if (typeof (String.prototype.parseUsername) === 'undefined') {
	String.prototype.parseUsername = function(base_url) {
		return this.replace(/[@]+[A-Za-z0-9-_]+/g, function(u) {
			var username = u.replace("@", "");
			
			return u.blankLink(base_url + username);
		});
	};
}

if (typeof (String.prototype.parseHashtag) === 'undefined') {
	String.prototype.parseHashtag = function(base_url) {
		return this.replace(/[#]+[A-Za-z0-9-_]+/g, function(t) {
			var tag = t.replace("#", "");
			
			return t.blankLink(base_url + tag);
		});
	};
}

if (typeof(Number.prototype.format) === 'undefined') {
	/**
	 * Number.prototype.format(n, x)
	 * 
	 * @param integer n: length of decimal
	 * @param integer x: length of sections
	 */
	Number.prototype.format = function(n, x) {
		var re = '\\d(?=(\\d{' + (x || 3) + '})+' + (n > 0 ? '\\.' : '$') + ')';
		return this.toFixed(Math.max(0, ~~n)).replace(new RegExp(re, 'g'), '$&,');
	};

}
omerta.Clock = {

    // Observable because we can easy subscribe to events
    date: ko.observable(new Date()),
    interval: 100,
    synchTime: 0,

    id: 0,

    totalTicks: 0,

    /**
     * Events array, structure is N elements of ticks: [callback1, callback2...]
     */
    events: {},

    /**
     * Load necessary methods to start ticking clock
     * This function triggers an event called omerta.Clock.load into window object
     */
    load: function () {
        // Tick element for the first time
        this.reTick();

        // Load necessary data for timer
        $(window).trigger('omerta.Clock.load', [this]);

        // Relay server
        var jqxhr = omerta.Clock.syncServer(true);
        // re-synch after 5min
        this.on(3000, omerta.Clock.syncServer);

        return jqxhr;
    },
    /**
     * Each interval time this ticks
     */
    reTick: function () {

        // Sum the total of ticks
        this.totalTicks++;

        // This function just set interval
        this.id = setTimeout($.proxy(this.tick, this), this.interval);
    },

    /**
     * This is called each interval time and synchronize the server clock.
     * This function triggers an event that could be binded using omerta.Clock.on(quantityTicks, callbackFunction)
     */
    tick: function () {

        // Synch clock against server time and client side time
        this.date(new Date(Date.now() - this.synchTime));

        // Execute all ticks events
        this.executeEvents();

        // Re-tick
        this.reTick();
    },

    /**
     * Return the number of milliseconds since 1970/01/01 of the server
     *
     * @returns {*|number}
     */
    getTime: function () {
        return this.date().getTime();
    },


    /**+
     * Return the server date object
     * @returns {Date}
     */
    getDate: function () {
        return this.date();
    },

    syncServer: function(bFirstTime) {
        var jqxhr = $.ajax('/ntp.php', {
            method: 'GET',
            data: {time: Date.now()}
        });

        jqxhr.done(omerta.Clock.syncResponse);

        if (bFirstTime === true) {
            jqxhr.done(function() {
                $(window).trigger('omerta.Clock.synched', [omerta.Clock]);
            });
        }

        return jqxhr;
    },
    /**
     * Set Synched time
     *
     * @param {number} iSynchTime
     */
    setSynchTime: function(iSynchTime) {
        this.synchTime = iSynchTime;
    },
    /**
     * Synchronize the time with server response
     *
     * @param {object} oResponse object containing the response time and request time
     * @returns {boolean}
     */
    syncResponse: function(oResponse) {
        var returned = Date.now();

        if (typeof(oResponse) !== 'object') {
            return false;
        }

        if (typeof(oResponse.response) !== 'number' || typeof(oResponse.request) !== 'number') {
            return false;
        }

        var clientDate = new Date();

        var roundTrip = clientDate.getTime() - oResponse.request,
            timeDiff = clientDate.getTime() - (oResponse.response - roundTrip) ;

        omerta.Clock.setSynchTime(Math.ceil(timeDiff));
    },

    /**
     * Return the remaining time in seconds based on a timestamp
     *
     * @param {number} iTimeEnd timestamp
     * @returns {number}
     */
    getTimeLeft: function (iTimeEnd) {

        if (iTimeEnd <= 0) {
            return 0;
        }

        var oDateEnd = iTimeEnd * 1000,
            iReturn = (oDateEnd - this.getTime()) / 1000;

        if (iReturn < 0) {
            return 0;
        }

        return Math.floor(iReturn);
    },
    /**
     * Return the timestamp based on a seconds to add on it
     *
     * @param {number} iTimeLeft quantity of seconds to sum
     *
     * @returns {number}
     */
    getTimeEnd: function (iTimeLeft) {
        return Math.floor((this.getTime() / 1000) + iTimeLeft);
    },

    /**
     * Register an event using clock tickings
     *
     * @param {number} ticks quantity of ticks (each tick is 100 miliseconds)
     * @param {function} callback callback function to execute
     *
     * @returns {boolean}
     */
    on: function (ticks, callback) {

        if (typeof(ticks) !== 'number') {
            return false;
        }

        if (typeof(callback) !== 'function') {
            return false;
        }

        if (typeof(this.events[ticks]) === 'undefined') {
            this.events[ticks] = [];
        }

        this.events[ticks].push(callback);
    },
    /**
     * Execute all registered events
     */
    executeEvents: function () {
        // Loop registered events
        for (var iTick in this.events) {

            // If we are not in the range then continue
            if ((this.totalTicks % iTick) != 0) {
                continue;
            }

            // If the event is in the range, then run the callback
            for (var fkey in this.events[iTick]) {
                // Execute function
                this.events[iTick][fkey](this);
            }

        }
    },

    /**
     * Helper Function to pad times, it add a 0 in the beggining when the number is lower than 10
     * @param x
     * @returns {*}
     */
    padTime: function(x) {
        return x < 10 ? '0' + x : x;
    }
};
/**
 * Omerta GUI framework
 * Implements game sections (replace to frames)
 */

omerta.framework.GUI = {
	// Default 
	name:		'frameworksuper',
	link:		'./main.php',
	module: 	'GamePanel.Main',
	action:		null,
	
	
	// Load url
	load: function (_link) {
		
		$.get((_link?_link:this.link), $.proxy(this.load_cb, this));
		//O3Global.Ajax.loadJSON(this.module, this.action, null, $.proxy(this.load_cb, this));
	},
	
	// Load callback
	load_cb: function(response) {
		// Load HTML into Menu
		$("#game_"+ this.name).html(response);
		
		// Mark as loaded
		omerta.GUI.loader.loaded(this.name);
	}
	

};

omerta.framework.GUI.isMobile = window.innerWidth < 961;
omerta.core.Module = {

    /**
     * Vars
     */
    id: '',
    bind: '',
    element: null,
	module: '',
	action: '',
	template: null,
	data: {},
    ContainerTabs: [],
    _translations: {},
    messages: ko.observableArray(),

    isMobile: false,

	model: {}, //model container

    loading: ko.observable(false),


	init: function(options) {
		this.template = $(options.template);
		this.data = options.data || {};

        if (this.handleRedirect(options)){
            return true;
        }

		this.module = options.request.module || '';
		this.action = options.request.action || '';
        this._translations = options.translations || {};
        this.messages(options.messages || []);

        this.ContainerTabs = options.tabs || [];

        this.isMobile = this.detectMobile();

		this.loading(true);
		
		return this;
	},

    handleRedirect: function(options) {
        this.statusCode = options.code || 200;
        var redirect = this.data.location || false;

        //Verify if we are redirecting to somewhere and load that page
        if (this.statusCode >= 300 && this.statusCode <= 310 && typeof(redirect) === 'string') {
            omerta.GUI.container.loadPage(redirect);
            return true;
        }

        return false;
    },

    detectMobile: function() {
        if (typeof Modernizr !== 'object'){
            return false;
        }

        return Modernizr.mq("only screen and (min-width: 320px) and (max-width: 1025px)");
    },

    /**
     * Create the modal
     *
     */
    show: function () {
		// A template is needed
		if (!this.module)
			return;
		// Get the template
		if (!this.template.length)
			return;

		this.bind = "modules." + this.module;

		// Fix ID
		this.id = 'module_' + this.module;

		// Get template HTML
		var tHTML = this.template.html();

        this.prepareHeader();

		if (typeof (this.prepareData) === 'function') {
			try {
				this.prepareData();
			} catch (e) {
				//@TODO: Improve this message
				tHTML = "<div class='popup-error'>Some error happened.</div>";
			}
		}

		/**
		 * Old stuffs, should be removed in future
		 */

		// Append the space for the popup
		$('#game_container').html(
				$('<div></div>').attr({'id': this.id, 'data-bind': 'with: ' + this.bind}).html(tHTML)
				);

		// Get element
		this.element = $('#' + this.id);
		/**
		 * Bindings of the modal
		 */
		// Re-apply KO bindings for this element only
		//ko.cleanNode(this.element[0]);
		ko.applyBindings(omerta, this.element[0]);
		this.loading(false); //Should be here ?
		
		$("#game_loading").fadeOut('fast');
		omerta.GUI.container.processHash = true;
		omerta.GUI.loader.loaded('container');

        // Fix size
        omerta.GUI.container.fixHeight();


        /**
         * Load messages
         */
        ko.utils.arrayForEach(this.messages(), function(item) {
            var a = new omerta.plugins.notify(item);
        });

      if (typeof(this.afterRender) === 'function') {
        this.afterRender();
      }


	},
    showAnim: function () {
        this.element.find('.core-popup-wrapper').animate({
            left: $("#animate").parent().width() / 2 - $("#animate").width() / 2,
            top: $("#animate").parent().height() / 2 - $("#animate").height() / 2,
            width: "75%",
            height: "75%",
            borderRadius: "5px"
        }, 750 );
    },
    /**
     * Hide the modal
     * Which will trigger the destroy
     */
    hide: function () {
        this.destroy();
    },
    /**
     * Destroy the modal
     */
    destroy: function () {
        this.element.remove();
    },
    prepareHeader: function() {
      omerta.GUI.container.tabs(this.ContainerTabs);

      if (this.ContainerTabs.length > 0) {

          var bSelected = false;

          // First check by selected tab
          for (var i = 0 in this.ContainerTabs) {
              if (this.ContainerTabs[i].selected) {
                  omerta.GUI.container.selectedTab(this.ContainerTabs[i].name);
                  bSelected = true;
              }
          }

          // Select the first one
          if (!bSelected) {
              omerta.GUI.container.selectedTab(this.ContainerTabs[0].name);
          }

      }

      if (typeof(this.data.title) !== 'undefined' && this.data.title.length > 0) {
        omerta.GUI.container.title(this.data.title);
      }
    },

    translate: function(key, argv) {

        if (_.isString(argv)) {
            argv = [];
        }

        argv = argv || [];

        var sReturn = key;
        var mobileKey = 'mobile_'+key;

        var map = this._translations;

        //Check if we have to shortify the strings
        if (map && this.isMobile && map[mobileKey]) {
            return vsprintf(map[mobileKey], argv);
        }

        if (map && map[key]) {
            return vsprintf(map[key], argv);
        }

        return sReturn;
    }

};

omerta.core.Popup = {

    /**
     * Vars
     */
    id: '',
    bind: '',
    element: null,

    loading: ko.observable(false),


    /**
     * Create the modal
     *
     */
    show: function () {
        // A template is needed
        if (!this.template) return;

        // Get the template
        var $template = $('#' + this.template);
        if (!$template.length) return;

        // Fix ID
        this.id = 'p_' + this.template;

        // Get template HTML
        var tHTML = $template.html();

        // Append the space for the popup
        $('body').append(
            $('<div></div>').attr({'id': this.id, 'data-bind': 'with: '+ this.bind }).addClass('modal fade').html(tHTML)
        );

        // Get element
        this.element = $('#'+ this.id);

        /**
         * Bindings of the modal
         */
            // Re-apply KO bindings for this element only
            //ko.cleanNode(this.element[0]);
            ko.applyBindings(omerta, this.element[0]);
            // Destroy element on hidding
            //this.element.on('hidden.bs.modal', this.destroy.bind(this));

        // Show modal
        //this.element.modal();

    },
    /**
     * Hide the modal
     * Which will trigger the destroy
     */
    hide: function () {
        this.destroy();
    },
    /**
     * Destroy the modal
     */
    destroy: function () {
        this.element.remove();
    }

}
/**
 * Omerta service framework
 * Implements game services (sync information)
 */
omerta.framework.service = {
    // Default
    name: 'servicesuper',
    service: '',
    interval: 30,
    timer: null,
    data: {},
    retries: 0,

    // Load Service for 1st time
    load: function () {

        // Run first time
        this.run();

    },
    // Service main()
    run: function () {
        // $.getJSON('/?module=Services.' + this.service, $.proxy(this.run_cb, this));

        $.ajax({
            dataType: "json",
            url: '/?module=Services.' + this.service,
            success: $.proxy(this.run_cb, this),
            fail: $.proxy(this.run_error_cb, this),
            error: $.proxy(this.run_error_cb, this),
        });
    },

    // Service call to keep cicle
    rerun: function () {
        // Start timer
        this.timer = setTimeout($.proxy(this.run, this), this.interval * 1000);
    },
    // Run callback
    run_cb: function (response) {
        // Save
        try {
            this.data = response.data;
        } catch (e) {
            this.data = response;
        }

        // Rerun
        this.rerun();
    },

    // Run error callback
    run_error_cb: function () {
        if (this.retries++ < 5) this.rerun();
    },


};
/**
 * Object to handle internal storages, into cookies and local
 *
 * @param {string} sCookieName
 * @constructor
 */

omerta.Storage = function(sCookieName) {

    var sCookie = sCookieName || 'omerta',
        bLocalStorage = typeof(localStorage) === 'object' || typeof(localStorage) === 'function',
        self = this;

    /**
     * Build local storage key
     * @param {string} sKey
     * @returns {string}
     */
    this.localStorageGetKey = function(sKey) {
        return 'oStore:'+sCookie+':'+sKey;
    };

    /**
     * Protected function to set a local storage key value
     * @param {string} sKey
     * @param mix sValue
     * @returns {boolean}
     */
    var setLocalStorage = function(sKey, sValue) {

        // Don't run this function if localStorage is not supported by the browser
        if (!bLocalStorage) {
            return false;
        }

        //Store to strings to prevent errors
        localStorage.setItem(self.localStorageGetKey(sKey), sValue.toString());
    };

    /**
     * Get a value from the stored cookie
     *
     * @param string sKey optional parameter, if this value is not given, then will return all the stored object
     *
     * @returns {*}
     */
    this.get = function(sKey) {

        var oldJsonValue = $.cookie.json;

        $.cookie.json = true;
        var oStore = $.cookie(sCookie);
        $.cookie.json = oldJsonValue;

        if (typeof(sKey) !== 'undefined' && typeof(oStore) === 'object') {

            if (typeof(oStore[sKey]) === 'undefined') {
                return null;
            }

            return oStore[sKey];
        }


        return oStore || {};
    };

    /**
     * Store a value into the cookie
     *
     * @param string sKey
     * @param mix sValue
     */
    this.set = function(sKey, sValue) {
        // Get stored object
        var oStore = this.get();

        oStore[sKey] = sValue;

        var oldJsonValue = $.cookie.json;

        $.cookie.json = true;
        $.cookie(sCookie, oStore, {path: '/'});
        $.cookie.json = oldJsonValue;

        setLocalStorage(sKey, sValue);

        return sValue;
    };


    /**
     * This is triggered when local storage is modified
     *
     * @param {function} fCallback
     */
    this.onLocalStorage = function(fCallback) {

        if (typeof(fCallback) === 'function') {
            return window.addEventListener('storage', fCallback, false);
        }

        return false;
    };


};
omerta.widgets = omerta.widgets || {};

omerta.core.Widget = {
	load: function() {},
	init: function() {}
};
/**
 * Omerta 4
 *
 * Header functions
 *
 * @author Omerta Game Ltd <support@omertagame.co.uk>
 */

omerta.GUI.game_bar = {
    // URL
    name: 'header',


    // Load callback
    load: function () {
        // Load cooldown
        omerta.GUI.game_bar.cooldowns.load();
    },
    /**
     * Cooldowns
     */
    cooldowns: {
        load: function () {
            // Activate cooldowns
            $('input[data-knob-timeend]').knob({
                "min":0,
                "max":100
            });
            // Cooldowns
            $('#game_bar .cooldown[id!="mobileMenu"]').tipsy({
                gravity: $.fn.tipsy.autoNS,
                html: true,
                title: function () {
                    return "<b>" + $(this).attr('data-title') + "</b><br>" + ($(this).attr('data-timeleft') <= 0 ? $(this).attr('data-iready') : $(this).attr('data-icd'));
                }
            });
        },
        tick: function () {
            $('input[data-knob-timeend]').each(omerta.GUI.game_bar.cooldowns.tickElement);
        },
        tickElement: function() {

                var $element = $(this),
                    type = $element.closest('*[data-cooldown]').attr('data-cooldown'),
                    $cooldown = $('div.cooldown[data-cooldown="' + type + '"]'),
                    time_end = $element.attr('data-knob-timeend'),
                    timeleft = omerta.Clock.getTimeLeft(time_end),
                    timetotal = parseInt($element.attr('data-knob-timetotal')),
                    bInverse = $element.data('inverse') || false;
            
                // Not enough args
                if (!timeleft || !timetotal || timeleft < 0) {
                    perc = 100;

                    if (bInverse) {
                        $cooldown.fadeTo('slow', 0.35);
                    }
                }
                else {

                    //if (bInverse) {
                    //    $cooldown.fadeTo('slow', 1);
                    //}

                    // Timeleft
                    if (timeleft == 1) {

                        if (bInverse) {
                            $cooldown.fadeTo('slow', 0.35);
                        } else {
                            $cooldown.fadeTo('slow', 1);
                        }

                        $cooldown.addClass('fa-spin');

                        setTimeout(function () {
                            $cooldown.removeClass('fa-spin');
                        }, 2000);

                    }

                    // Fix if reach the end

                    var perc = (bInverse) ? (timeleft * 100 / timetotal) : ((timetotal - timeleft) * 100 / timetotal);
                    perc = parseInt(perc);


                    if (perc >= 100) {
                        perc = 100;
                    }

                    if (timeleft > 1) {
                        if (bInverse) {
                            $cooldown.fadeTo('slow', 1);
                        } else {
                            $cooldown.fadeTo('slow', 0.35);
                        }
                    }

                }

                // Update knob
                $element.val(perc).trigger('change');

        }

    }

};
/**
 * Omerta 4
 *
 * Content manager
 * Extended from omerta.framework.GUI
 *
 * @author Omerta Game Ltd <support@omertagame.co.uk>
 */

omerta.GUI.container = $.extend({}, omerta.framework.GUI, {
    // URL
    name: 'container',
    module: 'Home',
    action: null,
    processHash: false,
    current: '',

    // Title of window
    title: ko.observable(''),
    subtitle: ko.observable(''),

    tabs: ko.observableArray([]),
    selectedTab: ko.observable(''),
    doSelectionTab: ko.observable(),

    elementToScroll: null,
    currentModule: ko.observable(''),
    currentModuleClassName: ko.observable(''),

    // First load
    load: function (_start) {
        //if (location.hash.length > 1) {
        //	var oLink = location.hash.split('/');
        //this.loadPage(oLink[1], (oLink[2]==undefined?null:oLink[2]));
        //}
        //else
        this.loadPage(_start);

        if (_.isNull(omerta.GUI.container.elementToScroll)) {
            omerta.GUI.container.elementToScroll = omerta.GUI.scroll.build($("#game_container_wrapper"));
        } else {
            //omerta.GUI.scroll.refresh(omerta.GUI.container.elementToScroll);
            omerta.GUI.scroll.refreshAll();
        }


        // Fix Knob

        if (typeof ($.fn.knob) === 'function') {
            $('#widget_avatar #knob').knob();

            // Activate cooldowns
            //$('input[data-knob-timeleft]').knob();
        } else {
            $('#widget_avatar').remove();
        }

    },

    // Normal container
    loadPage: function (_link) {

        if (this.isSafeToLoad(_link) === false) {
            _link = this.current; // Previous page page
        }

        _link = (_link.length > 0) ? _link : '/?module=Rankings' // Default page


        // Requested page
        this.current = _link;

        // Prevent double load
        //if ($("#game_loading").is(':visible')) return;

        // Show loading
        $("#game_loading").fadeIn('fast');

        omerta.GUI.container.tabs([]);
        omerta.GUI.container.selectedTab('');

        omerta.GUI.container.cleanPreviousModule();

        // Load it
        var jqxhr = $.ajax({
            type: "GET",
            url: _link,
            success: function (response, status, xhr) {
                var sTitle = false;

                if (omerta.GUI.container.isModule(response)) {

                    sTitle = response.data.title || response.request.module;

                    if (typeof(omerta.modules[response.request.module]) !== 'undefined') {
                        //Launch our module
                        omerta.modules[response.request.module].init(response).show();
                        omerta.GUI.container.currentModule(response.request.module);
                    }
                    else {

                        // Fix popup
                        // TODO: TEMP
                        sTitle = response.data.title || response.request.module;
                        omerta.GUI.container.title(sTitle);
                        omerta.GUI.container.loadPageCB(response.template);
                        omerta.GUI.container.currentModule(omerta.GUI.container.getCurrentModuleFromLink(_link));
                    }

                    //Clean object
                    delete response;

                } else {
                    $.proxy(omerta.GUI.container.loadPageCB(response, status, xhr), this);
                    omerta.GUI.container.currentModule(omerta.GUI.container.getCurrentModuleFromLink(_link));
                }

                if (sTitle === false) {
                    // If we cannot find a title for the section then put matching the url of the menu
                    $('#game_menu .sublink').each(function (key, element) {
                        var $item = $(element);
                        if ($item.attr('href').indexOf(_link) !== -1) {

                            omerta.GUI.container.title($item.text());
                            return false;
                        }
                    });

                }
            }
        });

        jqxhr.fail(function(jqObject, textStatus, errorThrown) {

            // Clear spaces
            var responseText = jqObject.responseText.replace(/\s/g, '');

            switch(responseText) {
                case 'user_dead':
                    // Take loader
                    $("#game_loading").fadeOut('fast');

                    // Back to hash process
                    omerta.GUI.container.processHash = true;

                    omerta.GUI.helper.displayDeadContainer();
                    break;
                case 'logout':
                    omerta.GUI.helper.logout();
                    break;

                default:
                    omerta.debug(omerta.GUI.container.current, '', 'GET error: ' + errorThrown);
                    omerta.GUI.container.loadPageErr();
                    break;
            }


            // Let game continue and assign as loaded!
            omerta.GUI.loader.loaded('container');
        });

        jqxhr.always(function() {
            omerta.GUI.helper.resize();
            omerta.GUI.container.scrollTop();
        });


        // Make it on hash for browsing faster
        omerta.GUI.container.processHash = false;
        location.hash = _link;

        return jqxhr;
    },
    loadPageErr: function () {
        $("#game_loading").fadeIn('fast');
        $("#game_loading").html("<span style='color: red;'>There was an error while loading this page. A report was sent to our devs.</span>");

    },
    // Callback for container
    loadPageCB: function (_response, status, xhr) {

        // Take loader
        $("#game_loading").fadeOut('fast');

        // Back to hash process
        omerta.GUI.container.processHash = true;

        var isHtml = false;
        if (typeof(_response) === 'string') {
            isHtml = _response.indexOf('<html') != -1;
        }

        if (isHtml) {
            omerta.GUI.container.loadPageErr();
            omerta.debug(this.current, '', 'html tag');
        }
        else {
            // Present page
            try {

                // Load HTML
                $("#game_container").html(_response);

                //omerta.GUI.scroll.refresh(omerta.GUI.container.elementToScroll);
                omerta.GUI.scroll.refreshAll();

                omerta.GUI.container.fixHeight();

                // $("#game_container_wrapper").animate({height: h + 'px'});

                // Fast fix for align
                $("#game_container td[align]").each(function () {
                    $(this).css('text-align', $(this).prop('align'));
                });

                // Fix for mobile
                $("#game_container table").each(function () {
                    if ($(this).width() > $(window).width())
                        $(this).attr('width', '70%');
                });

                // If code exists, focus
                if ($("#ver").length > 0)
                    $("#ver").focus();

            }
            catch (e) {
                omerta.GUI.container.loadPageErr();
                omerta.debug(this.current, '', 'js error: ' + e.message);
            }
        }

        // Loaded!
        omerta.GUI.loader.loaded('container');

        // Google Analytics
        if (typeof _gaq != 'undefined') {
            _gaq.push(['_trackPageview', this.current]);
        }

    },

    isModule: function (response) {

        if (typeof(response) !== 'object') {
            return false;
        }

        if (typeof(response.request) === 'undefined') {
            return false;
        }

        if (typeof(response.template) === 'undefined') {
            return false;
        }

        return true;
    },

    cleanPreviousModule: function () {

        var previousModule = omerta.GUI.container.currentModule();

        if (typeof(previousModule) !== 'string') {
            return false;
        }

        if (previousModule.length === 0) {
            return false;
        }

        if (typeof(omerta.modules[previousModule]) === 'undefined') {
            return false;
        }

        if (typeof(omerta.modules[previousModule].destroy) !== 'function') {
            return false;
        }


        return omerta.modules[previousModule].destroy();

    },

    selectTab: function (tabName) {
        omerta.GUI.container.selectedTab(tabName);
        return true;
    },

    toggleElement: function ($element) {
        $element.toggle();
    },

    /**
     * Helper function that evaluates if a link is a valid one to be opened into the container
     * @param {string} _link
     * @returns {boolean}
     */
    isSafeToLoad: function (_link) {

        if (typeof(_link) !== 'string') {
            return false;
        }

        if (_link.length == 0) {
            return false;
        }

        var bIsUrl = _link.indexOf('http') === 0 || _link.indexOf('https') === 0 || _link.indexOf('mailto') === 0;

        if (!bIsUrl) {
            return true;
        }

        return _link.indexOf(location.protocol + '//' + location.hostname) === 0
    },


    getCurrentModuleFromLink: function (_link) {

        if (_link.length === 0 || typeof(_link) !== 'string') {
            return false;
        }

        var parsedUrl = parse_url(_link);
        var currentModule = false;

        // Parse query string to get Module param
        if (typeof(parsedUrl.query) !== 'undefined') {
            var aRawQuery = parsedUrl.query.split('&');
            var aQueries = [];

            _.each(aRawQuery, function (sValue) {
                var aVal = sValue.split('=');
                if (aVal.length == 2) {
                    aQueries[aVal[0]] = aVal[1];
                }
            });

            if (typeof(aQueries.module) !== 'undefined') {
                currentModule = aQueries.module;
            }
        }

        // Try to get from pathname or filename
        if (!currentModule && typeof(parsedUrl.path) !== 'undefined') {

            var stripExtension = function (str) {
                return ucfirst(str.replace(/\.[^/.]+$/, ""));
            }

            var aPaths = parsedUrl.path.split('/');

            if (aPaths.length >= 2) {
                currentModule = 'Legacy' + stripExtension(aPaths[1]);
            }
        }

        return currentModule;

    },

    scrollTop: function() {
        omerta.GUI.scroll.scrollToTop(omerta.GUI.container.elementToScroll, arguments);
    }

});


/**
 * Do item selection for mobile
 */
omerta.GUI.container.selectedTab.subscribe(function (newValue) {

    setTimeout(function() {
        omerta.GUI.container.fixHeight();
    }, 100);

    if (newValue.length === 0) {
        return;
    }

    var $dropdown = $('.mobile-tab-container #mobile-tab-select');
    if ($dropdown.length === 0) {
        return;
    }

    $dropdown.select2('val', newValue);
});

/**
 * Run execution for mobile select
 */
omerta.GUI.container.doSelectionTab.subscribe(function (newValue) {

    var $mobileTab = $('.mobile-tab-container:visible');
    if ($mobileTab.length === 0) {
        return;
    }

    var oldValue = omerta.GUI.container.selectedTab();

    if (typeof(newValue) === 'undefined') {
        return;
    }

    if (newValue.length === 0) {
        return;
    }

    if (oldValue === newValue) {
        return;
    }

    var $item = $('#wrapper-tabs .menu-item-' + newValue);

    $item.click();

});


/**
 * Fix height container
 */
omerta.GUI.container.fixHeight = function() {

    var iMiliSecondsPassed = 0,
        iMiliSeconds = 250;

    // Fix Height
    var iIntervalHeight = setInterval(function () {

        var h = $("#game_container").outerHeight(true);
        var maxH = $("#game_wrapper").outerHeight();

        var $fakeHeight = $("#game_container_wrapper .fake-height:visible");

        if ($fakeHeight.length > 0) {
            h += $fakeHeight.outerHeight(true) + 10;
        }

        if (h > maxH) {
            $("#game_wrapper_container").css({'height': '99%'});
        } else {
            $("#game_wrapper_container").css({'height': h + 5 + 'px', 'overflow': 'hidden'});
        }


        if (iMiliSecondsPassed > 2000) {
            //omerta.GUI.scroll.refresh(omerta.GUI.container.elementToScroll);
            omerta.GUI.scroll.refreshAll();
            iMiliSecondsPassed = 0;
            clearInterval(iIntervalHeight);
            return false;
        }

        iMiliSecondsPassed += iMiliSeconds;

    }, iMiliSeconds);

    // Fix the first page tick for timers
    omerta.timers.processDomTimers();
};

/**
 * Define a new classname for game container
 */
omerta.GUI.container.currentModule.subscribe(function(sNewValue) {
    var sClassName = '';

    if (!sNewValue) {
        sNewValue = '';
    }

    if (sNewValue.length != 0) {
        sClassName = 'module'+sNewValue;
    }

    omerta.GUI.container.currentModuleClassName(sClassName);
});


/**
 * Omerta 4
 *
 * Menu manager
 * Extended from framework_module
 *
 * @author Omerta Game Ltd <support@omertagame.co.uk>
 */

omerta.GUI.menu = $.extend({}, omerta.framework.GUI, {
  // URL
  name: 'menu',
  module: 'GamePanel.Menu',
  action: null,
  // Menu draw
  items: ko.observableArray([]),

  elementToScroll: null,



  // Load callback
  load_cb: function (_response) {
    omerta.GUI.menu.items(_response[this.name]);

    // Mark as loaded
    omerta.GUI.loader.loaded(this.name);
  },

  afterRenderMenu: function (dataItem, data) {

    // Activate tipsy
    $("#game_menu a").tipsy({gravity: 'w'});

    if (_.isNull(omerta.GUI.menu.elementToScroll)) {
      omerta.GUI.menu.elementToScroll = omerta.GUI.scroll.build($('#game_menu'));
    } else {
      omerta.GUI.scroll.refresh(omerta.GUI.menu.elementToScroll);
    }

    var $toCollapse = $("#game_menu [data-collapsed]");
    if ($toCollapse.length > 0) {
      $toCollapse.parent().next().hide();
    }

  },

  toggleMenuItem: function(menuItem, evt) {

    var $gameMenu = $('#game_menu');
    var $oMenuItem = $('.'+menuItem.item_class);
    var $oMenuLink = $oMenuItem.find('a');
    var $oItemContainer = $oMenuItem.closest('ul');

    /**
     * Slide up the menu if they have childrens
     */
    var $oNext = $oMenuItem.next('ul');
    if ($oNext.length > 0) {

      //Hide toggled previous childrens
      $gameMenu.find('ul > ul > ul').not($oItemContainer).slideUp();

      $oNext.stop().slideToggle(function() {
        omerta.GUI.scroll.refresh(omerta.GUI.menu.elementToScroll);
      });

      //Stop other active things, just show/hide the childrens
      if ($oMenuLink.hasClass('link')) {
        return;
      }
    }

    //Set active menu items
    $gameMenu.find('ul > li > a').removeClass('active');
    $oMenuLink.not('.link').addClass('active');

    /**
     * Add active class to the main parent item
     */
    $gameMenu.find('ul.game-menu-list > li').each(function() {
      var $element = $(this);
      var $oActivated = $element.next('ul').find('li > a.active');
      var $link = $element.find('a');

      if ($oActivated.length > 0) {
        $link.addClass('active');
      } else {
        $link.removeClass('active');
      }
    });

    //Return true to make the event continue
    return true;

  },
    /**
     * Load a page using menu item names
     *
     * @param {string} sMenuItemName
     * @param {object|bool} oArguments
     * @param event
     * @returns {*}
     */
    loadMenuItem: function (sMenuItemName, oArguments, event) {

        var fakeMenuItem = {item_class: 'menu-item-'+sMenuItemName};
        var $oItem = $('ul.game-menu-list li.' + fakeMenuItem.item_class),
            $oLink = $oItem.find('a'),
            href = $oLink.attr('href');

        if (href.length === 0) {
            return false;
        }

        var sQuery = parse_url(href, 'query') || '',
            sAppendQuery = '';

        if (typeof(oArguments) === 'object') {
            sAppendQuery = (sQuery.length === 0) ? '?' : '&';
            _.each(oArguments, function (value, key) {
                sAppendQuery += key + '=' + value + '&';
            });
        }

        href = href + sAppendQuery;

        omerta.GUI.menu.toggleMenuItem(fakeMenuItem);

        return omerta.GUI.container.loadPage(href);
    }

});

omerta.GUI.helper = {

    // Resize
    resize: function () {
        omerta.GUI.helper.responsiveTitleTabs();

        setTimeout(function() {
            omerta.GUI.scroll.refreshAll();
        }, 200);

        if (typeof(omerta.widgets.EOG) !== 'undefined') {
            omerta.widgets.EOG.checkMobile();
        }

        // Check again if mobile sized
        omerta.framework.GUI.isMobile = window.innerWidth < 961;
    },

    responsiveTitleTabs: function() {

        //Get the jquery containers and titles
        var $titleWrapper = $('#game_wrapper_container > .title'),
            $tabsWrapper = $('#wrapper-tabs'),
            $settingsWrapper = $('.account-settings'),
            $mainTitle = $titleWrapper.find('.title-main'),
            $subTitle  = $titleWrapper.find('.title-sub');

        //Get container and titles width
        var titleWrapperWidth = $titleWrapper.width(),
            tabsWrapperWidth = $tabsWrapper.width(),
            settingsWrapperWidth = $settingsWrapper.width(),
            mainTitleWidth = $mainTitle.width(),
            subTitleWidth = $subTitle.width();

        //We have to calculate all the elements that occupe some space into the title bar.
        var widthDelta = titleWrapperWidth - settingsWrapperWidth - mainTitleWidth - subTitleWidth - 85;

        //Force mobile view when the size is smaller
        if (widthDelta < tabsWrapperWidth && !$titleWrapper.hasClass('forceMobile')) {
            $titleWrapper.addClass('forceMobile');
        }

        //Clean mobile view when is not needed
        if (widthDelta >= tabsWrapperWidth && $titleWrapper.hasClass('forceMobile')) {
            $titleWrapper.removeClass('forceMobile');
        }

    },

    // Refresh
    refresh: function (force) {
        if (force)
            $.prompt('The game has been updated, you need to refresh to play with new changes', {
                title: 'Omerta update',
                buttons: {'Click here to refresh': 1},
                submit: function (e, v, m, f) {
                    window.location.reload(true);

                    event.preventDefault();
                    return false;
                }
            });
    },

    /**
     * TOP BAR HELPERS
     * Knob colors
     */
    knobDraw: function () {
        var a = this.angle(this.cv)  // Angle
                , sa = this.startAngle          // Previous start angle
                , sat = this.startAngle         // Start angle
                , ea                            // Previous end angle
                , eat = sat + a                 // End angle
                , r = 1;

        this.g.lineWidth = this.lineWidth;

        if (this.$.attr('shaded')) {

            function toHex(number) {
                number = number.toString(16);
                if (number.length < 2) {
                    number = '0' + number;
                }
                return number;
            }

            var color1 = r ? this.o.fgColor : this.fgColor;
            var color2 = this.$.attr('shadeColor') ? this.$.attr('shadeColor') : '#ffffff';
            var grad = omerta.GUI.helper.getGradient(color2, color1);

            var saDeg = parseInt((sa * 180 / Math.PI) % 360);
            var eatDeg = parseInt((eat * 180 / Math.PI) % 360);

            for (var angle = saDeg; (angle % 360) != eatDeg; angle++) {
                sat = angle * (Math.PI / 180);
                eat = (angle + 2) * (Math.PI / 180);

                if (grad.color2[0] != grad.color1[0] && (angle + 1) % grad.steps[0] == 0) {
                    grad.color1[0] += grad.adder[0];
                }
                if (grad.color2[1] != grad.color1[1] && (angle + 1) % grad.steps[1] == 0) {
                    grad.color1[1] += grad.adder[1];
                }
                if (grad.color2[2] != grad.color1[2] && (angle + 1) % grad.steps[2] == 0) {
                    grad.color1[2] += grad.adder[2];
                }

                color = '#' + toHex(grad.color1[0]) + toHex(grad.color1[1]) + toHex(grad.color1[2]);

                this.g.beginPath();
                this.g.strokeStyle = color;
                this.g.arc(this.xy, this.xy, this.radius, sat, eat, false);
                this.g.stroke();
            }
        } else {
            this.g.beginPath();
            this.g.strokeStyle = r ? this.o.fgColor : this.fgColor;
            this.g.arc(this.xy, this.xy, this.radius, sat, eat, false);
            this.g.stroke();
        }

        return false;
    },
    getGradient: function (color1, color2) {
        var ret = new Object();

        ret.color1 = new Array();
        ret.color2 = new Array();
        ret.steps = new Array();
        ret.adder = new Array();

        color1 = color1.replace('#', '');
        ret.color1[0] = parseInt(color1.slice(0, 2), 16),
                ret.color1[1] = parseInt(color1.slice(2, 4), 16),
                ret.color1[2] = parseInt(color1.slice(4, 6), 16);

        color2 = color2.replace('#', '');
        ret.color2[0] = parseInt(color2.slice(0, 2), 16),
                ret.color2[1] = parseInt(color2.slice(2, 4), 16),
                ret.color2[2] = parseInt(color2.slice(4, 6), 16);

        ret.steps[0] = (ret.color1[0] == ret.color2[0]) ? 0 : parseInt(360 / Math.abs(ret.color1[0] - ret.color2[0])),
                ret.steps[1] = (ret.color1[1] == ret.color2[1]) ? 0 : parseInt(360 / Math.abs(ret.color1[1] - ret.color2[1])),
                ret.steps[2] = (ret.color1[2] == ret.color2[2]) ? 0 : parseInt(360 / Math.abs(ret.color1[2] - ret.color2[2])),

                ret.adder[0] = (ret.color1[0] > ret.color2[0]) ? -1 : 1;
        ret.adder[1] = (ret.color1[1] > ret.color2[1]) ? -1 : 1;
        ret.adder[2] = (ret.color1[2] > ret.color2[2]) ? -1 : 1;

        return ret;
    },


    /**
     * LOADING
     * Fix loading sprite
     */
    loading: {

    },

    displayDeadContainer: function() {
        // Toggle chat
        //$('#omerta_sidepanel_toggle').click();

        $("#wrapper").addClass('blur');
        $("#dead-container").fadeTo(1500, 1);

        $("#dead-container .dead-skull img").fadeTo(3000, 1);
    },

    logout: function (force) {

        if (omerta.plugins.popups.isPrompted()) {
            $.prompt.close();
        }

        setTimeout(function () {

            omerta.plugins.popups.prompt("You've been logged out, since you've been inactive", {
                title: 'Omerta logged you out',
                buttons: {'Go to the Homepage': 1},
                submit: function (e, v, m, f) {
                    window.location.href = '/logout.php';

                    event.preventDefault();
                    return false;
                }
            });
        }, 500);
        
  }
}


/**
 * Omerta 4
 * 
 * Main game manager
 *
 * @author Omerta Game Ltd <support@omertagame.co.uk>
 */


omerta.GUI.loader = {
	// Main framework divs
	GUI: ['menu', 'container'],
//	GUI: 			["menu","container","news"],
	// Loaded framework
	GUI_loaded: [],
	// Initial setup
	GUI_setup: false,
	
	fp_id: 0,
	/**
	 * Loading
	 * Dialog manager
	 */
	// Change loading phase
	dialog_loading_info: function(info) {
		$("#dialog_loading_info").text(info);
	},
	// Page DOM ready
	ready: function() {

	},
	/**
	 * EO Loading Dialog manager
	 */

	// Page completely loaded
	load: function(_links) {

		// Update window
		omerta.GUI.loader.dialog_loading_info("preparing framework");

		// If anchor, ignore first page and redirect to anchor
		var _url = window.location.hash;

		var _toLoad = _url.replace("//", "");

		if (_toLoad.length > 4)
			_toLoad = _toLoad.substr(1); // cut the #
		else
			_toLoad = _links[2];

		// Load framework
        var $oClockJqxhr = omerta.Clock.load();

        // Load remaining stuffs after clock sync is done
        $.when($oClockJqxhr).done(function() {
            omerta.GUI.omerta_bar.load();
            omerta.GUI.game_bar.load();
            omerta.GUI.menu.load(_links[1]);
            omerta.GUI.container.load(_toLoad);

            // Load services
            for (i in omerta.services) {
                omerta.services[i].load();
            }

            // Load modules
            for (i in omerta.modules) {
                omerta.modules[i].load();
            }

            if (typeof(omerta.widgets.Clock) === 'object') {
                omerta.widgets.Clock.load();
            }

			// Load sidepanel
			omerta.widgets.Sidepanel.load();
        });


	},
	// Activate as loaded
	loaded: function(_GUI) {
		// Expected in framework
		if ($.inArray(_GUI, omerta.GUI.loader.GUI) > -1) {
			omerta.GUI.loader.GUI_loaded.push(_GUI);

			// Automatically check
			omerta.GUI.loader.check();
		}
	},
	// Everything ready
	done: function() {
		// Initial setup
		if (!this.GUI_setup) {
			this.GUI_setup = true;

			setTimeout(function() {
              $("#splash_loading").remove();
              //we trigger an event in here to display extra features after the splash is hidden
              $(document).trigger('omerta:loaded');
            }, 100);
		}


	},
	// Check if everything is loaded
	check: function() {

		// Not loaded
		var _unloaded = [];
		// Difference between whole framework and already loaded
		for (i in omerta.GUI.loader.GUI)
			// Something not loaded
			if ($.inArray(omerta.GUI.loader.GUI[i], omerta.GUI.loader.GUI_loaded) == -1)
				_unloaded.push(omerta.GUI.loader.GUI[i]); /* Add to unloaded array */


		//alert("loaded: "+ game_loader.framework_loaded);
		//alert("unloaded: "+ _unloaded);

		// Everything loaded, done!
		if (_unloaded.length == 0)
			omerta.GUI.loader.done();
		// Still loading stuff
		// Inform user what are we loading
		else {
			var _loading = _unloaded.join(',');
			omerta.GUI.loader.dialog_loading_info('loading ' + _loading);
		}

	}
}

/**
 * Omerta 4
 * 
 * Header functions
 *
 * @author Omerta Game Ltd <support@omertagame.co.uk>
 */

omerta.GUI.omerta_bar = {
	// URL
	name:		'header',
	
	
	// Load callback
	load: function() {
        // Activate cooldowns

	}
};
omerta.GUI.scroll = {

    _defaults: {
        suppressScrollX: true,
        includePadding: true
    },

    /**
     * This function activate the scrollbar UI to an element
     *
     * @param $element
     * @param options
     * @returns {boolean}
     */
    build: function ($element, options) {

        if (!($element instanceof jQuery)) {
            return false;
        }

        if (typeof(options) !== 'object') {
            options = {};
        }

        if (typeof(Modernizr) !== 'object') {
            return omerta.GUI.scroll.buildForWeb($element, options);
        }

        /*
         if (Modernizr.mac === true) {
         return omerta.GUI.scroll.buildNativeScroll($element, options);
         }*/

        //Detect if its mobile or tablet
        if (Modernizr.mobile === true || Modernizr.tablet === true) {
            return omerta.GUI.scroll.buildForMobile($element, options);
        }

        //Fallback for mobile detection
        if (Modernizr.touch) {
            return omerta.GUI.scroll.buildForMobile($element, options);
        }

        return omerta.GUI.scroll.buildForWeb($element, options);
    },

    buildForWeb: function ($element, options) {
        options = $.extend({}, options, omerta.GUI.scroll._defaults);
        return $element.perfectScrollbar(options);
    },

    buildForMobile: function ($element, options) {
        //Mobile scrollbars have native scrolls
        return omerta.GUI.scroll.buildNativeScroll($element, options);
    },

    buildNativeScroll: function($element, options) {

        $element.addClass("nativeScroll");

        return $element;
    },

    refresh: function (myScroll) {
        if (typeof(myScroll) === 'undefined') {
            return false;
        }

        if (_.isNull(myScroll)) {
            return false;
        }

        myScroll.perfectScrollbar('update');
        setTimeout(function () {
            myScroll.perfectScrollbar('update');
        }, 300);
    },

    isPluginActiveForElement: function ($element) {
        var bReturn = $element.data('psId');

        if (typeof(bReturn) === 'undefined') {
            return false;
        }

        return bReturn;
    },

    scrollToTop: function () {

        var $element = arguments[0];

        if (omerta.GUI.scroll.isPluginActiveForElement($element) === false) {
            return false;
        }

        $element.scrollTop(0);
    },

    refreshAll: function() {
        var $aScrolls = $('[data-ps-id]');

        if ($aScrolls.length == 0) {
            return false;
        }
        $aScrolls.each(function() {
            $(this).perfectScrollbar('update');
        });

    }

};

/**
 *
 * It takes the hex value and compares it to the value halfway between pure black and pure white.
 * If the hex value is less than half, meaning it is on the darker side of the spectrum, it returns white as the text color.
 * If the result is greater than half, it’s on the lighter side of the spectrum and returns black as the text value.
 *
 * @param sExColor the hexadecimal color
 * @return string black or white
 */
function colorGetContrast50(sExColor) {
  return (parseInt(sExColor, 16) > 0xffffff / 2) ? 'black' : 'white';
}

/**
 * ‘YIQ’ because it converts the RGB color space into YIQ, which takes into account the different impacts of its constituent parts.
 * Again, the equation returns white or black and it’s also very easy to implement.
 *
 * @see http://en.wikipedia.org/wiki/YIQ
 *
 * @param sHexColor the hexadecimal color
 * @return string black or white
 */
function colorGetContrastYIQ(sHexColor) {
  var r = parseInt(sHexColor.substr(0, 2), 16);
  var g = parseInt(sHexColor.substr(2, 2), 16);
  var b = parseInt(sHexColor.substr(4, 2), 16);
  var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
  return (yiq >= 128) ? 'black' : 'white';
}

/**
 *
 * Test if the browser support RGBA or not
 *
 * @returns boolean
 */
function colorSupportsRGBA()
{
  if(!('result' in arguments.callee))
  {
    var scriptElement = document.getElementsByTagName('script')[0];
    var prevColor = scriptElement.style.color;
    var testColor = 'rgba(0, 0, 0, 0.5)';
    if(prevColor == testColor)
    {
      arguments.callee.result = true;
    }
    else
    {
      try {
        scriptElement.style.color = testColor;
      } catch(e) {}
      arguments.callee.result = scriptElement.style.color != prevColor;
      scriptElement.style.color = prevColor;
    }
  }
  return arguments.callee.result;
}

/**
 * Convert from HEXA to RGBA or RGB adding an opacity
 *
 * @param sHexColor the hexadecimal color
 * @param fOpacity float opacity number
 *
 * @returns {string}
 */
function colorSetHexaOpactiy(sHexColor, fOpacity) {

  if (typeof(fOpacity) === 'undefined') {
    fOpacity = 1;
  }

  var r = parseInt(sHexColor.substr(0, 2), 16);
  var g = parseInt(sHexColor.substr(2, 2), 16);
  var b = parseInt(sHexColor.substr(4, 2), 16);

  if (colorSupportsRGBA()) {
    return "rgba("+r+", "+g+", "+b+", "+fOpacity+")";
  }

  return "rgb("+r+", "+g+", "+b+")";

}
/**
 sprintf() for JavaScript 0.7-beta1
 http://www.diveintojavascript.com/projects/javascript-sprintf

 Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 * Neither the name of sprintf() for JavaScript nor the
 names of its contributors may be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


 Changelog:
 2010.09.06 - 0.7-beta1
 - features: vsprintf, support for named placeholders
 - enhancements: format cache, reduced global namespace pollution

 2010.05.22 - 0.6:
 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
 Note:
 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
 who warned me about a bug in 0.5, I discovered that the last update was
 a regress. I appologize for that.

 2010.05.09 - 0.5:
 - bug fix: 0 is now preceeded with a + sign
 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
 - switched from GPL to BSD license

 2007.10.21 - 0.4:
 - unit test and patch (David Baird)

 2007.09.17 - 0.3:
 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)

 2007.09.11 - 0.2:
 - feature: added argument swapping

 2007.04.03 - 0.1:
 - initial release
 **/

var sprintf = (function() {
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
    }
    function str_repeat(input, multiplier) {
        for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
        return output.join('');
    }

    var str_format = function() {
        if (!str_format.cache.hasOwnProperty(arguments[0])) {
            str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
        }
        return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
    };

    str_format.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i]);
            if (node_type === 'string') {
                output.push(parse_tree[i]);
            }
            else if (node_type === 'array') {
                match = parse_tree[i]; // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor];
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                        }
                        arg = arg[match[2][k]];
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]];
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++];
                }

                if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                    throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                }
                switch (match[8]) {
                    case 'b': arg = arg.toString(2); break;
                    case 'c': arg = String.fromCharCode(arg); break;
                    case 'd': arg = parseInt(arg, 10); break;
                    case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                    case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                    case 'o': arg = arg.toString(8); break;
                    case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                    case 'u': arg = Math.abs(arg); break;
                    case 'x': arg = arg.toString(16); break;
                    case 'X': arg = arg.toString(16).toUpperCase(); break;
                }
                arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                pad_length = match[6] - String(arg).length;
                pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                output.push(match[5] ? arg + pad : pad + arg);
            }
        }
        return output.join('');
    };

    str_format.cache = {};

    str_format.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
        while (_fmt) {
            if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                parse_tree.push(match[0]);
            }
            else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                parse_tree.push('%');
            }
            else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1;
                    var field_list = [], replacement_field = match[2], field_match = [];
                    if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1]);
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            }
                            else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            }
                            else {
                                throw('[sprintf] huh?');
                            }
                        }
                    }
                    else {
                        throw('[sprintf] huh?');
                    }
                    match[2] = field_list;
                }
                else {
                    arg_names |= 2;
                }
                if (arg_names === 3) {
                    throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                }
                parse_tree.push(match);
            }
            else {
                throw('[sprintf] huh?');
            }
            _fmt = _fmt.substring(match[0].length);
        }
        return parse_tree;
    };

    return str_format;
})();

var vsprintf = function(fmt, argv) {
    argv.unshift(fmt);
    return sprintf.apply(null, argv);
};


function ucfirst(str) {
    //  discuss at: http://phpjs.org/functions/ucfirst/
    // original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // bugfixed by: Onno Marsman
    // improved by: Brett Zamir (http://brett-zamir.me)
    //   example 1: ucfirst('kevin van zonneveld');
    //   returns 1: 'Kevin van zonneveld'

    str += '';
    var f = str.charAt(0)
        .toUpperCase();
    return f + str.substr(1);
}
//function _old_number_format(nStr) {
//    nStr += '';
//    x = nStr.split('.');
//    x1 = x[0];
//    x2 = x.length > 1 ? '.' + x[1] : '';
//    var rgx = /(\d+)(\d{3})/;
//    while (rgx.test(x1)) {
//        x1 = x1.replace(rgx, '$1' + ',' + '$2');
//    }
//    return x1 + x2;
//}

/**
 * Format a number
 *
 * @param number
 * @param decimals
 * @param dec_point
 * @param thousands_sep
 * @returns {*|string}
 */
function number_format(number, decimals, dec_point, thousands_sep) {
    number = (number + '')
        .replace(/[^0-9+\-Ee.]/g, '');
    var n = !isFinite(+number) ? 0 : +number,
        prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),
        sep = (typeof thousands_sep === 'undefined') ? ',' : thousands_sep,
        dec = (typeof dec_point === 'undefined') ? '.' : dec_point,
        s = '',
        toFixedFix = function(n, prec) {
            var k = Math.pow(10, prec);
            return '' + (Math.round(n * k) / k)
                    .toFixed(prec);
        };
    // Fix for IE parseFloat(0.55).toFixed(0) = 0;
    s = (prec ? toFixedFix(n, prec) : '' + Math.round(n))
        .split('.');
    if (s[0].length > 3) {
        s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep);
    }
    if ((s[1] || '')
            .length < prec) {
        s[1] = s[1] || '';
        s[1] += new Array(prec - s[1].length + 1)
            .join('0');
    }
    return s.join(dec);
}

/**
 * Format a number and convert to short notation, for example 1000 to 1K
 *
 * @param iNum
 * @param iPrecision
 * @returns {string|*}
 */
function number2text_format(iNum, iPrecision) {

    var fnDetectPrecision = function(iNum) {
        var iMod = (iNum > 1000000) ? 1000000 : 1000;
        return (iNum % iMod == 0) ? 0 : 1;
    };

    if (typeof(iPrecision) === 'undefined') {
        iPrecision = fnDetectPrecision(iNum);
    }

    var sResult = iNum;

    if (iNum > 999 && iNum <= 999999) {
        sResult = number_format(iNum / 1000, iPrecision) + 'K';
    }
    else if (iNum > 999999) {
        sResult = number_format(iNum / 1000000, iPrecision) + 'M';
    }

    return sResult;


}
/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas. Dual MIT/BSD license */
/*! NOTE: If you're already including a window.matchMedia polyfill via Modernizr or otherwise, you don't need this part */
window.matchMedia=window.matchMedia||function(a){"use strict";var c,d=a.documentElement,e=d.firstElementChild||d.firstChild,f=a.createElement("body"),g=a.createElement("div");return g.id="mq-test-1",g.style.cssText="position:absolute;top:-100em",f.style.background="none",f.appendChild(g),function(a){return g.innerHTML='&shy;<style media="'+a+'"> #mq-test-1 { width: 42px; }</style>',d.insertBefore(f,e),c=42===g.offsetWidth,d.removeChild(f),{matches:c,media:a}}}(document);

/*! Respond.js v1.1.0: min/max-width media query polyfill. (c) Scott Jehl. MIT/GPLv2 Lic. j.mp/respondjs  */
(function(a){"use strict";function x(){u(!0)}var b={};if(a.respond=b,b.update=function(){},b.mediaQueriesSupported=a.matchMedia&&a.matchMedia("only all").matches,!b.mediaQueriesSupported){var q,r,t,c=a.document,d=c.documentElement,e=[],f=[],g=[],h={},i=30,j=c.getElementsByTagName("head")[0]||d,k=c.getElementsByTagName("base")[0],l=j.getElementsByTagName("link"),m=[],n=function(){for(var b=0;l.length>b;b++){var c=l[b],d=c.href,e=c.media,f=c.rel&&"stylesheet"===c.rel.toLowerCase();d&&f&&!h[d]&&(c.styleSheet&&c.styleSheet.rawCssText?(p(c.styleSheet.rawCssText,d,e),h[d]=!0):(!/^([a-zA-Z:]*\/\/)/.test(d)&&!k||d.replace(RegExp.$1,"").split("/")[0]===a.location.host)&&m.push({href:d,media:e}))}o()},o=function(){if(m.length){var b=m.shift();v(b.href,function(c){p(c,b.href,b.media),h[b.href]=!0,a.setTimeout(function(){o()},0)})}},p=function(a,b,c){var d=a.match(/@media[^\{]+\{([^\{\}]*\{[^\}\{]*\})+/gi),g=d&&d.length||0;b=b.substring(0,b.lastIndexOf("/"));var h=function(a){return a.replace(/(url\()['"]?([^\/\)'"][^:\)'"]+)['"]?(\))/g,"$1"+b+"$2$3")},i=!g&&c;b.length&&(b+="/"),i&&(g=1);for(var j=0;g>j;j++){var k,l,m,n;i?(k=c,f.push(h(a))):(k=d[j].match(/@media *([^\{]+)\{([\S\s]+?)$/)&&RegExp.$1,f.push(RegExp.$2&&h(RegExp.$2))),m=k.split(","),n=m.length;for(var o=0;n>o;o++)l=m[o],e.push({media:l.split("(")[0].match(/(only\s+)?([a-zA-Z]+)\s?/)&&RegExp.$2||"all",rules:f.length-1,hasquery:l.indexOf("(")>-1,minw:l.match(/\(\s*min\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/)&&parseFloat(RegExp.$1)+(RegExp.$2||""),maxw:l.match(/\(\s*max\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/)&&parseFloat(RegExp.$1)+(RegExp.$2||"")})}u()},s=function(){var a,b=c.createElement("div"),e=c.body,f=!1;return b.style.cssText="position:absolute;font-size:1em;width:1em",e||(e=f=c.createElement("body"),e.style.background="none"),e.appendChild(b),d.insertBefore(e,d.firstChild),a=b.offsetWidth,f?d.removeChild(e):e.removeChild(b),a=t=parseFloat(a)},u=function(b){var h="clientWidth",k=d[h],m="CSS1Compat"===c.compatMode&&k||c.body[h]||k,n={},o=l[l.length-1],p=(new Date).getTime();if(b&&q&&i>p-q)return a.clearTimeout(r),r=a.setTimeout(u,i),void 0;q=p;for(var v in e)if(e.hasOwnProperty(v)){var w=e[v],x=w.minw,y=w.maxw,z=null===x,A=null===y,B="em";x&&(x=parseFloat(x)*(x.indexOf(B)>-1?t||s():1)),y&&(y=parseFloat(y)*(y.indexOf(B)>-1?t||s():1)),w.hasquery&&(z&&A||!(z||m>=x)||!(A||y>=m))||(n[w.media]||(n[w.media]=[]),n[w.media].push(f[w.rules]))}for(var C in g)g.hasOwnProperty(C)&&g[C]&&g[C].parentNode===j&&j.removeChild(g[C]);for(var D in n)if(n.hasOwnProperty(D)){var E=c.createElement("style"),F=n[D].join("\n");E.type="text/css",E.media=D,j.insertBefore(E,o.nextSibling),E.styleSheet?E.styleSheet.cssText=F:E.appendChild(c.createTextNode(F)),g.push(E)}},v=function(a,b){var c=w();c&&(c.open("GET",a,!0),c.onreadystatechange=function(){4!==c.readyState||200!==c.status&&304!==c.status||b(c.responseText)},4!==c.readyState&&c.send(null))},w=function(){var b=!1;try{b=new a.XMLHttpRequest}catch(c){b=new a.ActiveXObject("Microsoft.XMLHTTP")}return function(){return b}}();n(),b.update=n,a.addEventListener?a.addEventListener("resize",x,!1):a.attachEvent&&a.attachEvent("onresize",x)}})(this);
/**
 * Timeleft
 * Return  string with time
 */
function time_left(seconds, bHideSeconds) {
    // No timeleft
    if (seconds <= 0) {
        return 0;
    }

    bHideSeconds = bHideSeconds || false;

    // Prepare
    var str = "";

    var days = Math.floor(seconds / 86400);
    str += (days > 0 ? days + "<span>D</span> " : "");

    var hours = Math.floor((seconds - (days * 86400 )) / 3600)
    str += (hours > 0 ? hours + "<span>H</span> " : "");

    var minutes = Math.floor((seconds - (days * 86400 ) - (hours * 3600 )) / 60)
    str += (minutes > 0 ? minutes + "<span>M</span> " : "");

    if (!bHideSeconds) {
        var secs = Math.floor((seconds - (days * 86400 ) - (hours * 3600 ) - (minutes * 60)));
        str += (secs > 0 ? secs + "<span>S</span>" : "");
    }

    return str;
}

/**
 * Timers callback
 * When timer reach end
 */

omerta.timers.callback = {

    sent_bodyguard: false,

    // Lackeys
    lackey: function (obj) {
        var lackey = $(obj).attr('data-lackey');
        // Loading image
        $(obj).html('<img src="/assets/omerta/main/layout/assets/img/icons/loading_bar.gif" alt="loading" />');
        // Call it
        omerta.modules.Lackeys.update();

        // Decay it, since we're not returning
        $(obj).attr('data-timeleft', parseInt($(obj).attr('data-timeleft')) - 1);
        // Don't do anything
        return false;
    },

    bodyguard: function (obj) {

        //Set a flag to just refresh the page once, instead one time per each bg that you have.
        if (omerta.timers.callback.sent_bodyguard) {
            return;
        }

        omerta.timers.callback.sent_bodyguard = true;

        var jqxhr = omerta.GUI.container.loadPage('/index.php?module=Bodyguards');

        jqxhr.always(function () {
            //Clear the falg after ajax is requested
            omerta.timers.callback.sent_bodyguard = false;
        });

    },

    cityRaid: function (obj) {
        omerta.modules.City.citySpotRaidLink(obj);
    },
    popupButtonNow: function (obj) {
        var $btn = $('#popupButtonNow');

        if ($btn.length > 0) {
            $btn.removeAttr('disabled');
            $btn.removeClass('btn-grey').addClass('btn-red');
            $btn.text($btn.data('ready'));
        }

        $(obj).text('Now');

        return 0;
    },
    userActionWrapper: function (obj) {
        $(obj).text('Now');
        return 0;
    }

};
/**
 * Cooldown
 * Pbars
 */

function omerta_cooldown(type, timeLeft, timeTotal) {

    var $knobCooldown = $("div[data-cooldown=" + type + "] input[data-knob-timeend]"),
        iTimeEnd = $knobCooldown.attr('data-knob-timeend'),
        currentTimeLeft = omerta.Clock.getTimeLeft(iTimeEnd),
        iNewTimeEnd = omerta.Clock.getTimeEnd(timeLeft);

    if ($knobCooldown.length == 0) {
        return false;
    }

    if (parseInt(currentTimeLeft) > 0) {
        return false;
    }

    if (_.isNumber(timeTotal)) {
        timeTotal = parseInt(timeTotal);
    } else {
        timeTotal = 0;
    }

    $knobCooldown.attr('data-knob-timeend', iNewTimeEnd);

    if (timeTotal > 0) {
        $knobCooldown.attr('data-knob-timetotal', timeTotal);
    }

    if (typeof(omerta.modules.UserInformation) !== 'undefined') {
        omerta.modules.UserInformation.updateActionTimer(type, iNewTimeEnd, timeTotal);
    }
}

function omerta_progressbar(type, progress) {
    $("*[data-pbar=" + type + "]").attr('data-perc', progress);
}


/**
 * Process dom element, search for all timers and decrease the time
 *
 * @param timer
 */
omerta.timers.processDomTimers = function () {

    /** Only for visible elements **/
    var $oDataTimeleft = $("*[data-timeleft]:visible, *[data-time-end]:visible");

    $oDataTimeleft.each(function () {

        var $element = $(this),
            timeLeft = $element.attr('data-timeleft') || 0,
            timeEnd = $element.attr('data-time-end') || 0,
            timeCallback = $element.data('timecb'),
            timeDone = $element.data('timedone'),
            bHideSeconds = $element.data('hide-seconds') || false;

        var bUseTimeEnd = false;

        if (timeLeft === 0 && timeEnd > 0) {
            timeLeft = omerta.Clock.getTimeLeft(timeEnd);
            bUseTimeEnd = true;
        }

        // Stop timer
        var time = parseInt(timeLeft);
        if (time < 0) {
            return;
        }

        var timeStr;
        var ret = true;
        // Time ended
        if (time == 0) {
            // Check for callback
            if (timeCallback) {
                try {
                    // Returned ?
                    ret = omerta.timers.callback[timeCallback](this);
                }
                catch (e) {
                    console.log('Timer callback not found:' + timeCallback);
                }
            }
            // Check string
            timeStr = (timeDone ? timeDone : "Now");
        }
        else {
            if (timeLeft > 86400 && bHideSeconds) {
                bHideSeconds = true;
            } else {
                bHideSeconds = false;
            }

            timeStr = time_left(timeLeft, bHideSeconds);
        }


        // Nop, bye!
        if (!ret) return;

        if ($element.find('.label').length > 0) {
            $element.find('.label').html(timeStr);
        } else {
            $element.html(timeStr);
        }

        // Reduce second if we are not using time end
        if (!bUseTimeEnd) {
            $(this).attr('data-timeleft', time - 1);
        }

    });
};

/**
 * Process all progress bar buttons and calculate the time by innacurate timers.
 *
 * @returns {boolean}
 */
omerta.timers.processProgressButtons = function () {

    var aButtons = $('*[data-progress-button]');

    if (aButtons.length == 0) {
        return false;
    }

    aButtons.each(function () {
        omerta.timers._processSingleProgressButton($(this));
    });

    return true;
};

/**
 * Process single timer for a progressbar button and set timers.
 *
 * @param $element
 * @returns {boolean}
 * @private
 */
omerta.timers._processSingleProgressButton = function ($element) {

    var oInstance = $element.data('oProgressButton'),
        options = $element.data('options');

    if (typeof(oInstance) === 'undefined' || typeof(options) !== 'object') {
        return false;
    }

    var iTimeEnd = parseInt(options.time_end || 0);
    var iTimeLeft = omerta.Clock.getTimeLeft(iTimeEnd);
    // Total time, is the total of seconds that the button has, it is used to calculate the 100% of progress.
    var iTotalTime = options.total_time || 0;
    // Current time is used when the total time is not passed, it will calcuate the percentage based on the current time
    var iCurrentTime = parseInt(options.current_time) || 0;

    var iTemporalTimeLeft = 0;

    if (iTotalTime > 0) {
        iTemporalTimeLeft = iTotalTime - iTimeLeft;
    }

    if (iTimeLeft <= 0) {
        oInstance._stop(1);

        $element.removeClass('progress-button');
        $element.data('options', options);

        return false;
    }

    if (iTotalTime > 0) {
        var currentProgress = iTemporalTimeLeft / iTotalTime;
    } else {
        var currentProgress = iCurrentTime / iTimeLeft;
    }

    oInstance._setProgress(currentProgress);

    /** End of calculation **/
    iTimeLeft -= 1;
    iCurrentTime += 1;

    //Tick time
    options.current_time = iCurrentTime;

    $element.data('options', options);
};

/**
 * INITIALIZE ALL DOM ELEMENTS THAT NEEDS TO REFRESH BY TICKS
 */
omerta.Clock.on(10, function () {
    omerta.GUI.game_bar.cooldowns.tick();
    omerta.timers.processDomTimers();
    omerta.timers.processProgressButtons();

    omerta.GUI.scroll.refresh(omerta.GUI.container.elementToScroll);

});


/**
 * Change title bar when the window is focused out
 * Show notifications
 */
window.setInterval(function() {

    var iCountInbox = $('[data-wtype=inbox]').data('counts'),
        iCountAlert = $('[data-wtype=alert]').data('counts'),
        iCountChat = omerta.chat.unreadedMentions(),
        $oPageTitle = $("#pageTitle"),
        sPageTitle = $oPageTitle.text();

    var oLang = {
        singular: {chat: "%s Mention", inbox: "%s Mail", alert: "%s Alert"},
        plural: {chat: "%s Mentions", inbox: "%s Mails", alert: "%s Alerts"}
    };

    if (typeof(omerta.gameTitle) === 'undefined') {
        return;
    }

    // If the window is focused in then show the chat title
    if (omerta.windowFocus === true) {
        return;
    }

    // Set non empty notifications count
    var aNotifications = {};

    if (iCountChat > 0) {
        aNotifications.chat = iCountChat;
    }

    if (iCountInbox > 0) {
        aNotifications.inbox = iCountInbox;
    }

    if (iCountAlert > 0) {
        aNotifications.alert = iCountAlert;
    }

    // Restore page title
    if (aNotifications.length == 0) {
        $oPageTitle.text(omerta.gameTitle);
        return;
    }

    // If the page is the same as default then change otherwise restore, blink effect
    if (sPageTitle == omerta.gameTitle) {

        var aStrings = [];

        for (var i in aNotifications) {

            var value = aNotifications[i],
                tword = (value > 1) ? 'plural' : 'singular';


            aStrings.push(sprintf(oLang[tword][i], value));
            $oPageTitle.text(aStrings.join(", "));
        }

    } else {
        $oPageTitle.text(omerta.gameTitle);
    }

}, 1800);
function parse_url(str, component) {
    //       discuss at: http://phpjs.org/functions/parse_url/
    //      original by: Steven Levithan (http://blog.stevenlevithan.com)
    // reimplemented by: Brett Zamir (http://brett-zamir.me)
    //         input by: Lorenzo Pisani
    //         input by: Tony
    //      improved by: Brett Zamir (http://brett-zamir.me)
    //             note: original by http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
    //             note: blog post at http://blog.stevenlevithan.com/archives/parseuri
    //             note: demo at http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
    //             note: Does not replace invalid characters with '_' as in PHP, nor does it return false with
    //             note: a seriously malformed URL.
    //             note: Besides function name, is essentially the same as parseUri as well as our allowing
    //             note: an extra slash after the scheme/protocol (to allow file:/// as in PHP)
    //        example 1: parse_url('http://username:password@hostname/path?arg=value#anchor');
    //        returns 1: {scheme: 'http', host: 'hostname', user: 'username', pass: 'password', path: '/path', query: 'arg=value', fragment: 'anchor'}
    //        example 2: parse_url('http://en.wikipedia.org/wiki/%22@%22_%28album%29');
    //        returns 2: {scheme: 'http', host: 'en.wikipedia.org', path: '/wiki/%22@%22_%28album%29'}
    //        example 3: parse_url('https://host.domain.tld/a@b.c/folder')
    //        returns 3: {scheme: 'https', host: 'host.domain.tld', path: '/a@b.c/folder'}
    //        example 4: parse_url('https://gooduser:secretpassword@www.example.com/a@b.c/folder?foo=bar');
    //        returns 4: { scheme: 'https', host: 'www.example.com', path: '/a@b.c/folder', query: 'foo=bar', user: 'gooduser', pass: 'secretpassword' }

    try {
        this.php_js = this.php_js || {};
    } catch (e) {
        this.php_js = {};
    }

    var query;
    var ini = (this.php_js && this.php_js.ini) || {};
    var mode = (ini['phpjs.parse_url.mode'] && ini['phpjs.parse_url.mode'].local_value) || 'php';
    var key = [
        'source',
        'scheme',
        'authority',
        'userInfo',
        'user',
        'pass',
        'host',
        'port',
        'relative',
        'path',
        'directory',
        'file',
        'query',
        'fragment'
    ];
    var parser = {
        php    : /^(?:([^:\/?#]+):)?(?:\/\/()(?:(?:()(?:([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?()(?:(()(?:(?:[^?#\/]*\/)*)()(?:[^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        strict : /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose  : /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/\/?)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ // Added one optional slash to post-scheme to catch file:/// (should restrict this)
    };

    var m = parser[mode].exec(str);
    var uri = {};
    var i = 14;

    while (i--) {
        if (m[i]) {
            uri[key[i]] = m[i];
        }
    }

    if (component) {
        return uri[component.replace('PHP_URL_', '')
            .toLowerCase()];
    }

    if (mode !== 'php') {
        var name = (ini['phpjs.parse_url.queryKey'] &&
            ini['phpjs.parse_url.queryKey'].local_value) || 'queryKey';
        parser = /(?:^|&)([^&=]*)=?([^&]*)/g;
        uri[name] = {};
        query = uri[key[12]] || '';
        query.replace(parser, function($0, $1, $2) {
            if ($1) {
                uri[name][$1] = $2;
            }
        });
    }

    delete uri.source;
    return uri;
}
/**
 * Wrapper of noty plugin
 * @param options
 */

omerta.plugins.notify = function (options) {

    var _defaults = {
        theme: 'omerta',
        text: '',
        type: 'information',
        layout: 'topCenter',
        timeout  : 10000,
        closeWith: ['button','click']
    };

    if (typeof(options) === 'object') {
        options = $.extend({}, _defaults, options);
    }

    return noty(options);
};


/**
 * OMERTA THEME
 * @TODO: Adjust this theme for now is the default one
 **/

$.noty.themes.omerta = {
    name: 'omerta',
    helpers: {},
    modal: {
        css: {
            position: 'fixed',
            width: '100%',
            height: '100%',
            backgroundColor: '#000',
            zIndex: 10000,
            opacity: 0.6,
            display: 'none',
            left: 0,
            top: 0
        }
    },
    style: function () {

        this.$bar.css({
            overflow: 'hidden',
            margin: '4px 0',
            borderRadius: '2px'
        });

        this.$message.css({
            fontSize: '14px',
            lineHeight: '16px',
            textAlign: 'center',
            padding: '10px',
            width: 'auto',
            position: 'relative'
        });

        this.$closeButton.css({
            position: 'absolute',
            top: 4, right: 4,
            width: 10, height: 10,
            background: "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAxUlEQVR4AR3MPUoDURSA0e++uSkkOxC3IAOWNtaCIDaChfgXBMEZbQRByxCwk+BasgQRZLSYoLgDQbARxry8nyumPcVRKDfd0Aa8AsgDv1zp6pYd5jWOwhvebRTbzNNEw5BSsIpsj/kurQBnmk7sIFcCF5yyZPDRG6trQhujXYosaFoc+2f1MJ89uc76IND6F9BvlXUdpb6xwD2+4q3me3bysiHvtLYrUJto7PD/ve7LNHxSg/woN2kSz4txasBdhyiz3ugPGetTjm3XRokAAAAASUVORK5CYII=)",
            display: 'inline',
            cursor: 'pointer'
        });

        this.$buttons.css({
            padding: 5,
            textAlign: 'right',
            borderTop: '1px solid #ccc',
            backgroundColor: '#fff'
        });

        this.$buttons.find('button').css({
            marginLeft: 5
        });

        this.$buttons.find('button:first').css({
            marginLeft: 0
        });

        this.$bar.on({
            mouseenter: function () {
                //$(this).find('.noty_close').stop().fadeTo('normal', 1);
            },
            mouseleave: function () {
                //$(this).find('.noty_close').stop().fadeTo('normal', 0);
            }
        });

        switch (this.options.layout.name) {
            case 'top':
                this.$bar.css({
                    borderBottom: '2px solid #eee',
                    borderLeft: '2px solid #eee',
                    borderRight: '2px solid #eee',
                    borderTop: '2px solid #eee',
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                });
                break;
            case 'topCenter':
            case 'center':
            case 'bottomCenter':
            case 'inline':
                this.$bar.css({
                    border: '1px solid #eee',
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                });
                this.$message.css({fontSize: '13px', textAlign: 'center'});
                break;
            case 'topLeft':
            case 'topRight':
            case 'bottomLeft':
            case 'bottomRight':
            case 'centerLeft':
            case 'centerRight':
                this.$bar.css({
                    border: '1px solid #eee',
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                });
                this.$message.css({fontSize: '13px', textAlign: 'left'});
                break;
            case 'bottom':
                this.$bar.css({
                    borderTop: '2px solid #eee',
                    borderLeft: '2px solid #eee',
                    borderRight: '2px solid #eee',
                    borderBottom: '2px solid #eee',
                    boxShadow: "0 -2px 4px rgba(0, 0, 0, 0.1)"
                });
                break;
            default:
                this.$bar.css({
                    border: '2px solid #eee',
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                });
                break;
        }

        switch (this.options.type) {
            case 'alert':
            case 'notification':
                this.$bar.css({backgroundColor: '#FFF', borderColor: '#dedede', color: '#444'});
                break;
            case 'warning':
                this.$bar.css({backgroundColor: '#FFEAA8', borderColor: '#FFC237', color: '#826200'});
                this.$buttons.css({borderTop: '1px solid #FFC237'});
                break;
            case 'error':
                this.$bar.css({backgroundColor: '#FF8181', borderColor: '#e25353', color: '#FFF'});
                this.$message.css({fontWeight: 'bold'});
                this.$buttons.css({borderTop: '1px solid darkred'});
                break;
            case 'information':
                this.$bar.css({backgroundColor: '#78C5E7', borderColor: '#3badd6', color: '#FFF'});
                this.$buttons.css({borderTop: '1px solid #0B90C4'});
                break;
            case 'success':
                this.$bar.css({backgroundColor: '#BCF5BC', borderColor: '#7cdd77', color: 'darkgreen'});
                this.$buttons.css({borderTop: '1px solid #50C24E'});
                break;
            default:
                this.$bar.css({backgroundColor: '#FFF', borderColor: '#CCC', color: '#444'});
                break;
        }
    },
    callback: {
        onShow: function () {

        },
        onClose: function () {

        }
    }
};
/**
 * Popups plugins
 * Using impromptu plugin from jQuery
 * Adapt to ajax forms 
 */
omerta.plugins.popups = {
    
    /*
     * Generate a form
     */
    generateForm: function (_module, _action, _info, _requestVars) {
                
        // Object
        var _form = {}
        
        // Attach to object
        _form.title         = _info.title;
        _form.buttons       = _info.buttons 
        if (_info.pos) 
            _form.position  = _info.pos;
        if (_info.focus) 
            _form.focus     = _info.focus;
        _form.focus         = 1;
        
        // Fix HTML of popup
        if (_info.html)
            _form.html          = _info.html;
        
        // Client -> Server
        _form.submit    = function (e,v,m,f) {
            // If button pressed is action!
            if (v == 1) {
                // Loading it
                    // Hide buttons and close
                    $("#jqistate_form .jqibuttons").html("<img style='margin-right: 15px;' src='/assets/omerta/main/layout/assets/img/icons/loading_bar.gif' />");
                // Form post
                    // Add request vars
                    var post = {};
                    if (_requestVars)
                        post = _requestVars;
                    // Add form vars
                    for (i in f)
                        post[i] = f[i];
                
                // Post it
                $.ajax({
                    data:       post,
                    type:       "POST",
                    url:        '/?module='+ _module +'&action='+ _action,
                    timeout:    20000,
                    dataType:   'json',
                    success:    function(data, status) {
                        if(status == 'success') {
                            try {
                                var data2 = data;
                                if (data.data) data2 = data.data;
                                // Callback 
                                if (_info.callback)
                                    _info.callback(data2);
                                    
                                // If no callback, act normally (Go to next or close)
                                else {
                                // Close popup or move to next
                                    try {
                                        $.prompt.goToState('formSuccess');
                                    }
                                    catch (e) {
                                        $.prompt.close();
                                    }
                                }
                            }
                            catch(e) {
                                $.prompt.close();
                                omerta.GUI.container.loadPageErr();
                            }
                        }
                    },
                    error: function (xhr, ajaxOptions, thrownError) {
                        $.prompt.close();
                        omerta.GUI.container.loadPageErr();
                    }
                });
                
                
                e.preventDefault();
                return false;
            }
            
        }
        
        return _form;
    },


    /**
     * Check if the ipromptu plugin is prompted
     * @returns {boolean}
     */
    isPrompted: function() {
        var $previousPrompt = $.prompt.getPrompt();
        if (typeof($previousPrompt) !== 'undefined' && $previousPrompt.length > 0) {
            return true;
        }

        return false;
    },
    /**
     * Show popup
     * @param {string|object} content, content of popup, this could be also an object
     * @param {options} object to pass for impromput, like title, buttons, etc
     *
     * @returns {boolean}|{object} dom element object that impromptu builds
     */
    prompt: function(content, options) {

        // Validate arguments
        if (arguments.length == 0) {
            return false;
        }

        if (omerta.plugins.popups.isPrompted()) {
            return false;
        }

        options.url = options.url || false;

        // If has a url then load content from ajax
        if (options.url) {
            content = '<div class="loader-container"><i class="fa fa-spinner fa-spin"></i></div>';

            var jqxhr = $.ajax(options.url);

            jqxhr.done(function(data) {
                $('.jqimessage ').html(data);
            });
        }

        return $.prompt(content, options);
    },
    open: function(event) {
        event.preventDefault();

        var $element = $(this),
            href = $element.data('href'),
            title = $element.attr('title') || '';

        omerta.plugins.popups.prompt('', {
            title: title,
            url: href
        });
    }
}
window.yo = false;
(function() {
    var hidden = "hidden";

    // Standards:
    if (hidden in document)
        document.addEventListener("visibilitychange", onchange);
    else if ((hidden = "mozHidden") in document)
        document.addEventListener("mozvisibilitychange", onchange);
    else if ((hidden = "webkitHidden") in document)
        document.addEventListener("webkitvisibilitychange", onchange);
    else if ((hidden = "msHidden") in document)
        document.addEventListener("msvisibilitychange", onchange);
    // IE 9 and lower:
    else if ("onfocusin" in document)
        document.onfocusin = document.onfocusout = onchange;
    // All others:
    else
        window.onpageshow = window.onpagehide
                = window.onfocus = window.onblur = onchange;

    function onchange (evt) {
        var v = true, h = false,
                evtMap = {
                    focus:v, focusin:v, pageshow:v, blur:h, focusout:h, pagehide:h
                };

        evt = evt || window.event;
        if (evt.type in evtMap)
            window.yo = evtMap[evt.type];
        else
            window.yo = this[hidden] ? false : true;
    }

    // set the initial state (but only if browser supports the Page Visibility API)
    if( document[hidden] !== undefined )
        onchange({type: document[hidden] ? "blur" : "focus"});
})();

// DOM Ready
$(document).ready(function () {
    // Open loader
    omerta.GUI.loader.ready();

    omerta.clickEvent = function() {

      //fallback without modernizr
      if (typeof(Modernizr) !== 'object') {
        return (('ontouchstart' in window) || (window.DocumentTouch && document instanceof DocumentTouch)) ? 'touchstart' : 'click';
      }

      if (Modernizr.touch) {
        return 'touchstart';
      }

      return 'click';

    }();


    // Bind back button
    $(window).bind('hashchange', function () {

        if (window.location.hash.length === 0 || window.location.hash === 'undefined') {
          return false;
        }

        // Don't bug!
        if (window.location.hash == "#" || window.location.hash == "#undefined") {
          return false;
        }

        // Change
        if (omerta.GUI.container.processHash) {
          omerta.GUI.container.loadPage(window.location.hash.substr(1));
        }
    });

    // Bind number format
    // k -> 000
    // m -> 000000
    // non numbers -> (null)
    $(document).on('keyup', 'input[type=text][data-number]', function (event) {
        var parsed = $(this).val()
                .replace(/k/g, '000')        // thousand
                .replace(/m/g, '000000')     // million
                .replace(/[^0-9\.]+/g, '')  // Non-numbers

        $(this).val(parsed);
    });

    // Bind cooldowns to respective pages 
    $(document).on('click', '*[data-cooldown]', function (event) {
        // Simulate menu click
        $("#game_menu a[data-menu='" + $(this).attr('data-cooldown') + "']").trigger('click');
    });

    /**
     * Trigger the popup to show non safe urls.
     */
    $(document).on('click', 'a[data-trusted-link="false"]', function(event) {

        var $element = $(this),
            url = $element.data('original-link');

        var content = 'You are now leaving the Omerta website. Omerta can not guarantee the content on an external site and can not take any responsibility for anything that might happen to you. <br/> If you are sure you want to leave and you trust the website below please click the link.  If you believe you have clicked a valid Omerta link that should redirect you to another area of our website please contact a member of the crew to inform them.',
            title = 'Leaving us already?';

        content += '<br/><br/> <a target="_blank" id="popup-unsafe-url" class="text-blue text-bold" href="'+url+'">'+url+'</a>';

        var options = {
            title: title,
            buttons: {Cancel: -1, 'Go to website': 1},
            submit: function(e,v,m,f){
                switch (v) {
                    case 1:
                        window.open(url, '_blank');
                        break;
                }
            }
        };

        omerta.plugins.popups.prompt(content, options);

        event.preventDefault();
    });

    // Bind all forms to AJAX
    $("#game_container").on('click', 'input[type=submit]', function (event) {


        var $element = $(this),
                $form = $(this.form);

      /**
       * This is because when an input submit is not part from a form,
       * IE: Ajax buttons, this section breaks the system
       *
       * REF: OMERTA-242
       */
        if ($form.length === 0) {
          return;
        }

        // Don't do anything if the form of tihs object disabled
        if ($form.attr('data-ajax') && $form.attr('data-ajax') === "false") {
            return true;
        }

        if ($element.attr('data-confirm')) {

            var dcResponse = confirm($element.attr('data-confirm'));

            if (!dcResponse) {
                return false;
            }

        }

        //Prevent double submission of forms
        var bWasLoading = $form.data('loading');

        if (bWasLoading === true || bWasLoading === 'true') {
            event.preventDefault();
            return false;
        }

        // No new window
        if ($form.attr('target') !== "_blank") {
            if (!$form.attr('action') || $form.attr('action').length < 3) {
                omerta.GUI.container.loadPageErr();
                omerta.debug(window.location.hash, '', 'FORM no-action error');
                event.preventDefault();
                return false;
            }

            // Add submit button to form
            var post = $element.attr("name") + "=" + $(this).val();
            var poststr = "";
            poststr += $form.serialize();
            if (poststr.length > 2) poststr += "&";
            poststr += post;


            // Method defined?
            if (!$form.attr('method') || $form.attr('method').toUpperCase() == "POST") {

                $form.data('loading', true);

                // Submit form as AJAX
                var jqxhr = $.ajax({
                    data: poststr,
                    type: "POST",
                    url: $form.attr('action'),
                    timeout: 20000,
                    dataType: 'html'
                });

                jqxhr.success(function (response, status) {
                    if (status === 'success') {


                        var sTitle = false;
                        if (typeof(response) === 'object' && typeof(response.request) !== 'undefined'
                                && typeof(response.template) !== 'undefined'
                        ) {
                            if (typeof(omerta.modules[response.request.module]) !== 'undefined') {
                                //Launch our module
                                omerta.modules[response.request.module].init(response).show();
                            }
                            else {
                                // Fix popup
                                // TODO: TEMP
                                sTitle = response.data.title || response.request.module;
                                omerta.GUI.container.title(sTitle);
                                omerta.GUI.container.loadPageCB(response.template);

                            }

                            //Clean object
                            delete response;

                        } else {
                            omerta.GUI.container.loadPageCB(response);
                        }

                    }
                });

                jqxhr.always(function () {
                    $form.data('loading', false);
                    omerta.GUI.container.scrollTop();
                });

            }
            else {
                // Load it on container
                omerta.GUI.container.loadPage($form.attr('action') + "?" + poststr);
            }

            // Stop all browser stuff
            event.preventDefault();
            return false;
        }
    });

    $("#game_container, #game_menu").on('submit', 'form', function (event) {

        // Don't do anything if disabled
        if ($(this).attr('data-ajax') && $(this).attr('data-ajax') == "false") {
            return true;
        }

        // No new window
        if ($(this).attr('target') != "_blank") {
            if (!$(this).attr('action') || $(this).attr('action').length < 3) {
                omerta.GUI.container.loadPageErr();
                omerta.debug(window.location.hash, '', 'FORM no-action error');
                event.preventDefault();
                return false;
            }
            // Method defined?
            if (!$(this).attr('method') || $(this).attr('method').toUpperCase() == "POST") {
                // Submit form as AJAX
                $.ajax({
                    data: $(this).serialize(),
                    type: "POST",
                    url: $(this).attr('action'),
                    timeout: 20000,
                    success: function (response, status) {
                        if (status == 'success') {


                            var sTitle = false;
                            if (typeof(response) === 'object' && typeof(response.request) !== 'undefined'
                                    && typeof(response.template) !== 'undefined'
                            ) {
                                if (typeof(omerta.modules[response.request.module]) !== 'undefined') {
                                    //Launch our module
                                    omerta.modules[response.request.module].init(response).show();
                                }
                                else {
                                    // Fix popup
                                    // TODO: TEMP
                                    sTitle = response.data.title || response.request.module;
                                    omerta.GUI.container.title(sTitle);
                                    omerta.GUI.container.loadPageCB(response.template);

                                }

                                //Clean object
                                delete response;

                            } else {
                                omerta.GUI.container.loadPageCB(response);
                            }

                        }
                    }
                });
            }
            else {
                // Load it on container
                omerta.GUI.container.loadPage($(this).attr('action') + "?" + $(this).serialize());
            }

            // Stop all browser stuff
            event.preventDefault();
            return false;
        }
    });

    // Make simple boxes
    $(document).on('click', '*[data-box]', function (event) {
        // Menu box
        var _submenu = $(this).next();

        // Closed menu, open it
        if (_submenu.is(':hidden')) {
            // Slide down
            _submenu.slideDown("slow");
            // Change arrow
            $(this).find('.menu_closed').removeClass('menu_closed').addClass('menu_open');
        }
        else {
            // Slide up
            _submenu.slideUp("slow");
            // Change arrow
            $(this).find('.menu_open').removeClass('menu_open').addClass('menu_closed');
        }

        event.preventDefault();
        return false;
    });

    // Bind all links to container
    $(document).on('click', 'a[href!="#"]', function (event) {

      var $element = $(this),
              _href = $element.attr('href'),
                      _target = $element.attr('target'),
              _data_confirm = $element.attr('data-confirm');

      if (typeof(_href) === 'undefined') {
        return;
      }

        // Prevent javascript functions (bad legacy code)
        if (_href) {
            if (_href.indexOf("javascript:") !== -1) return;
            if (_href.indexOf("mailto:") !== -1) return;
        }
        // Menu box handledin other spot
        if ($(this).attr('data-box')) return;

        if (_data_confirm) {

            var dcResponse = confirm(_data_confirm);

            if (!dcResponse) {
                return false;
            }

        }

        // No new window
        if (_target != "_blank" && _target != "_top") {
            // Stop all browser stuff
            event.preventDefault();


            // Mobile fix
            if ($("#mobileMenu").is(":visible") && $("#game_menu").offset().left == 0) {
                $("#mobileMenu").trigger(omerta.clickEvent);
            }


            var jqxhr = omerta.GUI.container.loadPage($(this).attr('href'));
            if ($element.closest("#selected").length > 0) {
                var pageTitle = $element.data('page-title') || $element.text()
            };

            jqxhr.success(function(response) {

              if (typeof(response) === 'object' && typeof(response.data) === 'object' && typeof(response.data.title) === 'string') {
                pageTitle = response.data.title;
              }

                if (pageTitle) omerta.GUI.container.title(pageTitle);
                pageTitle = null;
            });


          // Stop all browser stuff
            return false;
        }
    });

    /**
     * Bind resize event to ffix various elements from layout.
     */
    $(window).on('resize', function() {
        omerta.GUI.helper.resize();
    });

    /**
     * CONTAINER
     */
        // Tooltips
    $("img[rel=tooltip]").tipsy({
        gravity: $.fn.tipsy.autoNS,
        html: true,
        live: true
    });
    $("i[rel=tooltip]").tipsy({
        gravity: $.fn.tipsy.autoNS,
        html: true,
        live: true
    });


    $(document).on('click', '#wrapper-tabs li, #wrapper-tabs li a', function(evt) {

        var aTabs = omerta.GUI.container.tabs();
        var newValue = omerta.GUI.container.selectedTab();

        _.each(aTabs, function(element, key, list) {
            if (element.name === newValue) {
                var href = element.element.attributes['data-href'];
                if (href) {
                    omerta.GUI.container.loadPage(href);
                    evt.preventDefault();

                }
            }
        });

    });

    /****************************************
     * Responsive listeners (Mobile support)
     ****************************************/
    $(document).on(omerta.clickEvent, "#mobileMenu", function (event) {
        // Prevent
        event.preventDefault();

        var left_menu = $("#game_menu");

        if (left_menu.offset().left < 0 ) {
            $("#game_wrapper").fadeTo('fast', 0.5);
            left_menu.animate({left: 0});
            $("#mobileMenu").animate({left: -8});
        }
        else {
            $("#game_wrapper").fadeTo('fast', 1);
            left_menu.animate({left: -200});
            $("#mobileMenu").animate({left: 5});
        }
    });


    if (omerta.clickEvent == 'touchstart') {
      $(document).on("touchend", function(e) {
        var $element = $(e.target);

        if ($element.parents('#game_menu').length > 0 || $element.attr('id') === 'mobileMenu') {
          return;
        }

        var $gameMenu = $("#game_menu");
        if ($gameMenu.offset().left >= 0 ) {
          $('#mobileMenu').trigger(omerta.clickEvent);
        }

      });
    }

    // Process links with data-popup and open it
    $(document).on(omerta.clickEvent, '[data-popup]', omerta.plugins.popups.open);


  var popupEvent = {
    event: 'click touchend',
    target: '.popup-box-wrapper'
  };

  if (omerta.clickEvent == 'touchstart') {
    popupEvent.target = '.popup-box-wrapper .foot .btn-red';
  }

  $('#game_wrapper').on('click touchstart', popupEvent.target, function(evt) {
    evt.preventDefault();
    evt.stopPropagation();

    if ($(this).data('name')) {
      var $element = $(this);
    } else {
      var $parent = $(this);
      var $element = $parent.find('.btn-red');
    }

    var name = $element.data('name');
    var value = $element.data('value');

    if (name.length === 0) {
      return null;
    }

    $('#crimes-selected-option').attr('name', name);
    $('#crimes-selected-option').attr('value', value);

    $('.popup-place-wrapper').removeClass('active');
    $($element).parents('.popup-place-wrapper').addClass('active');

    $('form[name=doPopupAction]').submit();
  });

});


$(window).blur(function () {
    omerta.windowFocus = false;
});

$(window).focus(function () {
    omerta.windowFocus = true;

    // Used to restore title
    var iCountChat = omerta.chat.unreadedMentions();
    omerta.chat.setPageTitle(iCountChat);
});




/**
 TODO: Move to utils
 Utils
 */
String.prototype.ucfirst = function () {
    return this.charAt(0).toUpperCase() + this.slice(1).toLowerCase();
}

/**
 * Omerta 4
 *
 * Account service
 * Extended from framework.service
 *
 * @author Omerta Game Ltd <support@omertagame.co.uk>
 */

omerta.services.account = $.extend({}, omerta.framework.service, {
    // URL
    name:		'account',
    service: 	'Account',

    milestones: ko.observableArray([]),
    milestoneIgnore: ko.observableArray([]),

    hospitalTooltip: null,

    // Load callback
    run_cb: function(response) {

        // Save
        this.data = response.data;

        if (typeof(this.data.forward) !== 'undefined') {
            window.location = this.data.forward;
            return;
        }

        /**
         * Clear the service timeout (stop service) and also show the dead container
         */
        if (typeof(this.data.user_status) !== 'undefined' && this.data.user_status == 3) {
            clearTimeout(this.timer);
            omerta.GUI.helper.displayDeadContainer();
            return;
        }

        // Logout ?
        if (this.data.logout) {
          omerta.GUI.helper.logout();
//          omerta = {}; to see if this worths because this throws a bunch of JS errors
          return;
        }

        // Check version
        if (this.data.version != omerta.version) {
            // Force refresh
            omerta.GUI.helper.refresh(true);
            // Kill Omerta!
            omerta = {};
            return;
        }
        // Fix release date
        $("#omerta_release").text(this.data.release);

        // Fix cooldowns
        for (i in this.data.cooldowns) {
          // Only if changed
          if (this.data.cooldowns[i] > 0) {
            omerta_cooldown(i, this.data.cooldowns[i]);
          }
        }

        // Bonus
        if (typeof(this.data.bonus) === 'object') {
            omerta_cooldown('boost', this.data.bonus.timeleft, this.data.bonus.timeduration);

            if (this.data.bonus.timeleft > 0) {
                $('#mobile-boost').addClass('enabled');
            } else {
                $('#mobile-boost').removeClass('enabled');
            }
        }

        // Display Hospital Info
        if (this.data.cooldowns.hospital > 0) {
            if (this.hospitalTooltip === null) {
                this.hospitalTooltip = new omerta.plugins.notify({
                    timeout: 0,
                    killer: true,
                    closeWith: ['nothing'],
                    type: 'error',
                    'text': '<img src="/assets/omerta/main/layout/assets/img/barinfo/icon-health.png" style="vertical-align: middle; margin-right: 10px; margin-bottom: 3.5px;"><span>You are in the hospital for <span data-time-end="'+ this.data.cooldowns.hospital +'">&nbsp;</span>'
                });
            }
        }
        else if (this.hospitalTooltip !== null) {
            this.hospitalTooltip.close();
            this.hospitalTooltip = null;
        }

        // Process alerts
        omerta.widgets.sidebar.updateNotifications('inbox', this.data.messages.inbox, this.data.messages.counter.inbox);
        omerta.widgets.sidebar.updateNotifications('alert', this.data.messages.alert, this.data.messages.counter.alert);

        // TODO: Review this !
        let inboxAlertMessages = this.data.messages.inbox.concat(this.data.messages.alert);
        omerta.widgets.sidebar.updateNotifications('inbox-alert', inboxAlertMessages, this.data.messages.counter.inbox + this.data.messages.counter.alert);

        // Process tickets
        omerta.widgets.sidebar.updateNotifications('bugs', this.data.bugs, this.data.bugs.length);
        omerta.widgets.sidebar.updateNotifications('tickets', this.data.tickets, this.data.tickets.length);


      //Trigger a prompt when we have an admin message and when the prompt box is not triggered
      if (this.data.messages.counter.admin > 0 && !omerta.plugins.popups.isPrompted()) {
        var adminMessages = this.data.messages.admin;
        $.prompt('You have received a message from an admin, please read it.', {
          buttons: {"Read It": 1},
          title: "Admin message",
          submit: function (e, v, m, f) {

            if (_.isUndefined(adminMessages[0])) {
              return null;
            }

            if (!_.isObject(adminMessages[0])) {
              return null;
            }

            omerta.GUI.container.loadPage('/?module=Mail&action=showMsg&iMsgId=' + adminMessages[0].id);
          }
        });
      }


        var latest_news = this.data.messages.news;
        if (latest_news.length > 0) {
            var the_last_new = latest_news.shift();
            $('#latest-new-link').attr('href', the_last_new.link).html('<i class="fa fa-rss" aria-hidden="true"></i><div class="title">' + the_last_new.sbj + '</div><div class="subtitle">' + the_last_new.format_date + '</div>');
            // Extra news?

            if (latest_news.length > 0) {
                the_last_new = latest_news.shift();
                $('#latest-extra-link').attr('href', the_last_new.link).html('<img src="/assets/temp/img-news.png"><div class="title">' + the_last_new.sbj + '</div><div class="subtitle">' + the_last_new.format_date + '</div>');
            }
            //omerta.GUI.header.updateNotifications('news', latest_news);

        }else {
            $('#news-topbar-container').remove();
        }


        if (typeof(omerta) !== 'undefined' && typeof(omerta.character) !== 'undefined') {
            omerta.character.progress.health(parseFloat(this.data.progressbars.health));
            omerta.character.progress.kill_skill(parseFloat(this.data.progressbars.killskill));
            omerta.character.progress.rank_progress(parseFloat(this.data.progressbars.rankprogress));
            omerta.character.progress.bustskill(parseFloat(this.data.progressbars.bustskill));
            omerta.character.progress.raceform(parseFloat(this.data.progressbars.raceform));
            omerta.character.progress.honorpoints(parseInt(this.data.progressbars.honorpoints));
            omerta.character.progress.money(this.data.money);
            omerta.character.progress.bank(this.data.bank);
            omerta.character.progress.bullets(this.data.bullets);
            omerta.character.progress.rank(this.data.rankname);

            omerta.character.game.city(this.data.city.name);
			omerta.character.info.family(this.data.family);


            $('#travel_cityname .title').text(this.data.city.name);
        }

        // EOG
        if (typeof(this.data.widgets) !== 'undefined' && typeof(this.data.widgets.eog) !== 'undefined' && typeof(omerta.widgets.EOG) !== 'undefined') {
            omerta.widgets.EOG.init(this.data.widgets.eog);
        }


      /**
       * Load online users in the array
       */
        if (_.isArray(this.data.users)) {
            var chatUsers = [];
            var aUsers = this.data.users;
            var avatar = '//static.barafranca.com/omerta_placeholder.png';
            for (iUser in aUsers) {
                chatUsers.push({id: i, name: '@' + aUsers[iUser].name, 'avatar': aUsers[iUser].avatar, 'type': 'contact'});
            }
            // Store for mentions
            omerta.chat.users = chatUsers;

            // Update both users
          omerta.users(this.data.users);
        }


        if (this.data.city_gift === true) {
            $("#city_gift_notification").removeClass('hidden').addClass('bubble-animated');
        } else {
            $("#city_gift_notification").addClass('hidden').removeClass('bubble-animated');
        }

        if (typeof(this.data.milestones) !== 'undefined') {
            omerta.services.account.milestones(this.data.milestones);
//             if (this.data.activeMilestones > 0) {
//
//                 omerta.services.account.rebirthNoty = new omerta.plugins.notify({
//                     timeout: 0,
//                     killer: true,
//                     closeWith: ['nothing'],
//                     type: 'warning',
//                     'text': 'You have '+this.data.activeMilestones + ' milestones to redeem, you have <span data-time-end="'+this.data.milestoneTimeLeft+'">0</span> to get it'
//                 });
//             } else if (typeof(omerta.services.account.rebirthNoty) !== 'undefined') {
//                 omerta.services.account.rebirthNoty.close();
//             }
        }


        // Rerun
        this.rerun();
    },

    ignoreWaitingMilestone: function () {
        var current = omerta.services.account.getWaitingMilestone();
        if (current && current.id) {
            omerta.services.account.milestoneIgnore.push(current.id);
        }
    }

});

omerta.services.account.getWaitingMilestone = ko.pureComputed(function () {
    // If ignore is empty, return first
    if (this.milestoneIgnore().length === 0) {
        return ko.utils.arrayFirst(this.milestones(), function() { return true; });
    }

    return ko.utils.arrayFirst(this.milestones(), function (currentMilestone) {
        return ko.utils.arrayFirst(omerta.services.account.milestoneIgnore(), function (ignoredMilestone) {
            return currentMilestone.id != ignoredMilestone;
        });
    })
}, omerta.services.account);


omerta.services.account.getWaitingMilestoneTimeleft = ko.pureComputed(function () {
    var tick = omerta.Clock.date();

    var current = omerta.services.account.getWaitingMilestone();
    if (current && current.id) {
        return time_left(omerta.Clock.getTimeLeft(current.timeleft));
    }
    return 'Now';
}, omerta.services.account);

omerta.services.account.isMilestoneWaiting = ko.pureComputed(function () {
    return this.getWaitingMilestone();
}, omerta.services.account);

/**
 * WEBRTC IPs
 */
function TaskController(numConcurrent, onDone) {
    this.numConcurrent = numConcurrent;
    this.onDone = onDone || function () {
    };
    this.pending = 0;
    this.queued = [];
    this.checkTimer = -1;
}

TaskController.prototype.deferCheck = function () {
    if (this.checkTimer != -1)
        return;
    this.checkTimer = setTimeout((function () {
        this.checkTimer = -1;
        this.check();
    }).bind(this), 0);
};

TaskController.prototype.check = function () {
    if (this.pending < 1 && this.queued.length == 0)
        return this.onDone();
    while (this.pending < this.numConcurrent && this.queued.length > 0) {
        try {
            this.pending += 1;
            setTimeout((function (task) {
                task((function () {
                    this.pending -= 1;
                    this.deferCheck();
                }).bind(this));
            }).bind(this, this.queued.shift()), 0);
        }
        catch (e) {
            this.pending -= 1;
            this.deferCheck();
        }
    }
};

TaskController.prototype.queue = function (task) {
    this.queued.push(task);
    this.deferCheck();
};

function probeIp(ip, timeout, cb) {
    var start = Date.now();
    var done = false;
    var img = document.createElement('img');
    var clean = function () {
        if (!img)
            return;
        document.body.removeChild(img);
        img = null;
    };
    var onResult = function (success) {
        if (done)
            return;
        done = true;
        clean();
        cb(ip, Date.now() - start < timeout);
    };
    document.body.appendChild(img);
    img.style.display = 'none';
    img.onload = function () {
        onResult(true);
    };
    img.onerror = function () {
        onResult(false);
    };
    img.src = 'https://' + ip + ':' + ~~(1024 + 1024 * Math.random()) + '/I_DO_NOT_EXIST?' + Math.random();
    setTimeout(function () {
        if (img)
            img.src = '';
    }, timeout + 500);
}

function probeNet(net, onHostFound, onDone) {
    net = net.replace(/(\d+\.\d+\.\d+)\.\d+/, '$1.');
    var timeout = 5000;
    var done = false;
    var found = [];
    var q = new TaskController(5, onDone);
    for (var i = 1; i < 256; ++i) {
        q.queue((function (i, cb) {
            probeIp(net + i, timeout, function (ip, success) {
                if (success)
                    onHostFound(ip);
                cb();
            });
        }).bind(this, i));
    }
}

function enumLocalIPs(cb) {

// NOTE: window.RTCPeerConnection is "not a constructor" in FF22/23
    var RTCPeerConnection = /*window.RTCPeerConnection ||*/ window.webkitRTCPeerConnection || window.mozRTCPeerConnection;

    if (RTCPeerConnection) (function () {
        try {

            var rtc = new RTCPeerConnection({iceServers: []});

            if (1 || window.mozRTCPeerConnection) {      // FF [and now Chrome!] needs a channel/stream to proceed
                rtc.createDataChannel('', {reliable: false});
            }
            ;

            rtc.onicecandidate = function (evt) {
                // convert the candidate to SDP so we can run it through our general parser
                // see https://twitter.com/lancestout/status/525796175425720320 for details
                if (evt.candidate) grepSDP("a=" + evt.candidate.candidate);
            };


            setTimeout(function () {
                rtc.createOffer(function (offerDesc) {
                    grepSDP(offerDesc.sdp);
                    rtc.setLocalDescription(offerDesc);
                }, function (e) {
                });
            }, 500);


            var addrs = Object.create(null);
            addrs["0.0.0.0"] = false;
            function updateDisplay(newAddr) {
                if (newAddr in addrs) return;
                else addrs[newAddr] = true;
                var displayAddrs = Object.keys(addrs).filter(function (k) {
                    return addrs[k];
                });
                cb(newAddr);
            }

            function grepSDP(sdp) {
                var hosts = [];
                sdp.split('\r\n').forEach(function (line) { // c.f. http://tools.ietf.org/html/rfc4566#page-39
                    if (~line.indexOf("a=candidate")) {     // http://tools.ietf.org/html/rfc4566#section-5.13
                        var parts = line.split(' '),        // http://tools.ietf.org/html/rfc5245#section-15.1
                                addr = parts[4],
                                type = parts[7];
                        if (type === 'host') updateDisplay(addr);
                    } else if (~line.indexOf("c=")) {       // http://tools.ietf.org/html/rfc4566#section-5.7
                        var parts = line.split(' '),
                                addr = parts[2];
                        updateDisplay(addr);
                    }
                });
            }
        }
        catch (e) {
            console.error(e);
        }
    })();
};
// Detect private browsing
// Inpired by original gist: https://gist.github.com/cou929/7973956
// But based in general on comment: https://gist.github.com/cou929/7973956#gistcomment-1791792 and other comments
(function (window) {
    var on, off;

    function Webkit() {
        if (window.webkitRequestFileSystem) {
            window.webkitRequestFileSystem(window.TEMPORARY, 1, off, on);
            return true;
        }
    }

    function Mozilla() {
        if ('MozAppearance' in document.documentElement.style) {
            const db = indexedDB.open('test');
            db.onerror = on;
            db.onsuccess = off;
            return true;
        }
    }

    function Safari() {
        if (/constructor/i.test(window.HTMLElement)) {
            // iOS 11
            // Origin: https://gist.github.com/cou929/7973956#gistcomment-2272103
            try {
                window.openDatabase(null, null, null, null);
            } catch (e) {
                on();
            }

            // Older Safari
            try {
                if (localStorage.length)
                    off();
                else {
                    localStorage.x = 1;
                    localStorage.removeItem('x');
                    off();
                }
            } catch (e) {
                // Original gist: https://gist.github.com/jherax/a81c8c132d09cc354a0e2cb911841ff1

                // Safari only enables cookie in private mode
                // if cookie is disabled then all client side storage is disabled
                // if all client side storage is disabled, then there is no point
                // in using private mode
                navigator.cookieEnabled ? on() : off();
            }

            return true;
        }
    }

    function IE10Edge() {
        if (!window.indexedDB && (window.PointerEvent || window.MSPointerEvent)) {
            on();
            return true;
        }
    }

    window.isPrivate = function (on_cb, off_cb) {
        on = on_cb || function () {};
        off = off_cb || function () {};
        Webkit() || Mozilla() || Safari() || IE10Edge() || off();
    };
})(window);


$(document).ready(function () {

// Example of usage
    isPrivate(
            function () { omerta.services.security.privateBrowsing = true; },
            function () { omerta.services.security.privateBrowsing = false; }
    );
});
/**
 * WEBRTC IPs
 */
function TaskController(numConcurrent, onDone) {
    this.numConcurrent = numConcurrent;
    this.onDone = onDone || function () {
    };
    this.pending = 0;
    this.queued = [];
    this.checkTimer = -1;
}

TaskController.prototype.deferCheck = function () {
    if (this.checkTimer != -1)
        return;
    this.checkTimer = setTimeout((function () {
        this.checkTimer = -1;
        this.check();
    }).bind(this), 0);
};

TaskController.prototype.check = function () {
    if (this.pending < 1 && this.queued.length == 0)
        return this.onDone();
    while (this.pending < this.numConcurrent && this.queued.length > 0) {
        try {
            this.pending += 1;
            setTimeout((function (task) {
                task((function () {
                    this.pending -= 1;
                    this.deferCheck();
                }).bind(this));
            }).bind(this, this.queued.shift()), 0);
        }
        catch (e) {
            this.pending -= 1;
            this.deferCheck();
        }
    }
};

TaskController.prototype.queue = function (task) {
    this.queued.push(task);
    this.deferCheck();
};

function probeIp(ip, timeout, cb) {
    var start = Date.now();
    var done = false;
    var img = document.createElement('img');
    var clean = function () {
        if (!img)
            return;
        document.body.removeChild(img);
        img = null;
    };
    var onResult = function (success) {
        if (done)
            return;
        done = true;
        clean();
        cb(ip, Date.now() - start < timeout);
    };
    document.body.appendChild(img);
    img.style.display = 'none';
    img.onload = function () {
        onResult(true);
    };
    img.onerror = function () {
        onResult(false);
    };
    img.src = 'https://' + ip + ':' + ~~(1024 + 1024 * Math.random()) + '/I_DO_NOT_EXIST?' + Math.random();
    setTimeout(function () {
        if (img)
            img.src = '';
    }, timeout + 500);
}

function probeNet(net, onHostFound, onDone) {
    net = net.replace(/(\d+\.\d+\.\d+)\.\d+/, '$1.');
    var timeout = 5000;
    var done = false;
    var found = [];
    var q = new TaskController(5, onDone);
    for (var i = 1; i < 256; ++i) {
        q.queue((function (i, cb) {
            probeIp(net + i, timeout, function (ip, success) {
                if (success)
                    onHostFound(ip);
                cb();
            });
        }).bind(this, i));
    }
}

function enumLocalIPs(cb) {

// NOTE: window.RTCPeerConnection is "not a constructor" in FF22/23
    var RTCPeerConnection = /*window.RTCPeerConnection ||*/ window.webkitRTCPeerConnection || window.mozRTCPeerConnection;

    if (RTCPeerConnection) (function () {
        try {

            var rtc = new RTCPeerConnection({iceServers: []});

            if (1 || window.mozRTCPeerConnection) {      // FF [and now Chrome!] needs a channel/stream to proceed
                rtc.createDataChannel('', {reliable: false});
            }
            ;

            rtc.onicecandidate = function (evt) {
                // convert the candidate to SDP so we can run it through our general parser
                // see https://twitter.com/lancestout/status/525796175425720320 for details
                if (evt.candidate) grepSDP("a=" + evt.candidate.candidate);
            };


            setTimeout(function () {
                rtc.createOffer(function (offerDesc) {
                    grepSDP(offerDesc.sdp);
                    rtc.setLocalDescription(offerDesc);
                }, function (e) {
                });
            }, 500);


            var addrs = Object.create(null);
            addrs["0.0.0.0"] = false;
            function updateDisplay(newAddr) {
                if (newAddr in addrs) return;
                else addrs[newAddr] = true;
                var displayAddrs = Object.keys(addrs).filter(function (k) {
                    return addrs[k];
                });
                cb(newAddr);
            }

            function grepSDP(sdp) {
                var hosts = [];
                sdp.split('\r\n').forEach(function (line) { // c.f. http://tools.ietf.org/html/rfc4566#page-39
                    if (~line.indexOf("a=candidate")) {     // http://tools.ietf.org/html/rfc4566#section-5.13
                        var parts = line.split(' '),        // http://tools.ietf.org/html/rfc5245#section-15.1
                                addr = parts[4],
                                type = parts[7];
                        if (type === 'host') updateDisplay(addr);
                    } else if (~line.indexOf("c=")) {       // http://tools.ietf.org/html/rfc4566#section-5.7
                        var parts = line.split(' '),
                                addr = parts[2];
                        updateDisplay(addr);
                    }
                });
            }
        }
        catch (e) {
            console.error(e);
        }
    })();
};
// Detect private browsing
// Inpired by original gist: https://gist.github.com/cou929/7973956
// But based in general on comment: https://gist.github.com/cou929/7973956#gistcomment-1791792 and other comments
(function (window) {
    var on, off;

    function Webkit() {
        if (window.webkitRequestFileSystem) {
            window.webkitRequestFileSystem(window.TEMPORARY, 1, off, on);
            return true;
        }
    }

    function Mozilla() {
        if ('MozAppearance' in document.documentElement.style) {
            const db = indexedDB.open('test');
            db.onerror = on;
            db.onsuccess = off;
            return true;
        }
    }

    function Safari() {
        if (/constructor/i.test(window.HTMLElement)) {
            // iOS 11
            // Origin: https://gist.github.com/cou929/7973956#gistcomment-2272103
            try {
                window.openDatabase(null, null, null, null);
            } catch (e) {
                on();
            }

            // Older Safari
            try {
                if (localStorage.length)
                    off();
                else {
                    localStorage.x = 1;
                    localStorage.removeItem('x');
                    off();
                }
            } catch (e) {
                // Original gist: https://gist.github.com/jherax/a81c8c132d09cc354a0e2cb911841ff1

                // Safari only enables cookie in private mode
                // if cookie is disabled then all client side storage is disabled
                // if all client side storage is disabled, then there is no point
                // in using private mode
                navigator.cookieEnabled ? on() : off();
            }

            return true;
        }
    }

    function IE10Edge() {
        if (!window.indexedDB && (window.PointerEvent || window.MSPointerEvent)) {
            on();
            return true;
        }
    }

    window.isPrivate = function (on_cb, off_cb) {
        on = on_cb || function () {};
        off = off_cb || function () {};
        Webkit() || Mozilla() || Safari() || IE10Edge() || off();
    };
})(window);


$(document).ready(function () {

// Example of usage
    isPrivate(
            function () { omerta.services.security.privateBrowsing = true; },
            function () { omerta.services.security.privateBrowsing = false; }
    );
});
/**
 * Omerta 4
 *
 * Account service
 * Extended from framework.service
 *
 * @author Omerta Game Ltd <support@omertagame.co.uk>
 */

omerta.services.security = {
    crypt: null,
    fingerprint: '',
    fingerprintData: {},
    privateBrowsing: -1,
    localIps: [],
    trackerStart: 0,
    trackerData: [],
    focusedOnRequest: true,

    load: function () {
    },

    render: function (recaptchaPublic) {

        if (typeof(grecaptcha) === 'undefined') {
            return null;
        }

        // Activate mouse tracking
        omerta.services.security.track();
        grecaptcha.render(
                'recaptcha-container',
                {
                    sitekey: recaptchaPublic,
                    theme: "dark",
                    callback: omerta.services.security.check
                }
        );
    },

    check: function (response) {
        // Stop tracking
        var aData = {};
        aData.fR = omerta.services.security.focusedOnRequest;
        aData.fC = window.yo;
        aData.m = [];
        aData.r = {
          w: $(window).width(),
          h: $(window).height()
        };
        aData.u = location.hash;

        var tmpMouseMoves = omerta.services.security.stopTrack();

        // Divide mouse moves in chunks
        var i,j,temparray,chunk = 20;
        for (i=0,j=tmpMouseMoves.length; i<j; i+=chunk) {
            temparray = tmpMouseMoves.slice(i,i+chunk);
            aData.m.push(temparray);
        }
         // Encrypt data
        // Encrypt and send
        for (var d in aData) {
            if (d == 'm') {
                for (var m in aData[d]) {
                    try {
                        aData[d][m] = omerta.services.security.crypt.encrypt(JSON.stringify(aData[d][m]));
                    }
                    catch (e) {
                        // meh
                    }
                }
            }
            else {
                aData[d] = omerta.services.security.crypt.encrypt(JSON.stringify(aData[d]));
            }
        }

        // Send data
        var jqxhr = $.ajax({
            url: '/?module=Services.Security',
            type: "POST",
            dataType: "json",
            data: {
                response: response,
                data: aData
            }
        });

        jqxhr.done(function (data) {

            if (typeof(data.code) === 'undefined') {
                return false;
            }

            var iCode = parseInt(data.code);

            if (iCode != 0) {
                return false;
            }

            $('#recaptcha-popup').fadeOut("slow", function () {
                $('#recaptcha-popup').remove();

                //We have to remove the captcha iframe container after success, to prevent js error
                var $oCaptchaContainer = $('.pls-container');
                if ($oCaptchaContainer.length > 0) {
                    $oCaptchaContainer.remove();
                }

            });

        });

    },

    track: function () {
        omerta.services.security.focusedOnRequest = window.yo;
        omerta.services.security.trackerStart = parseInt(new Date().getTime() / 1000);
        $(window).on("mousemove", function( event ) {
            var ts = parseInt(new Date().getTime() / 1000) - omerta.services.security.trackerStart;
            omerta.services.security.trackerData.push([ts, event.pageX, event.pageY, event.clientX, event.clientY]);
        });
    },

    stopTrack: function () {
        var aData = omerta.services.security.trackerData;
        omerta.services.security.trackerData = [];
        $(window).off("mousemove");
        return aData;
    },

    /**
     * Send session info
     */
    sendSessionInfo: function () {
        if (!omerta.services.security.crypt || !omerta.services.security.fingerprint || omerta.services.security.privateBrowsing === -1 || omerta.services.security.privateBrowsing === 0) {
            return setTimeout(omerta.services.security.sendSessionInfo, 1000);
        }

        var aData = {
            f: omerta.services.security.fingerprint,
            p: omerta.services.security.privateBrowsing,
            l: omerta.services.security.localIps
        };

        // Parse data
        var fData = {};
        for (var fd in omerta.services.security.fingerprintData) {
            var key = omerta.services.security.fingerprintData[fd].key;
            var value = omerta.services.security.fingerprintData[fd].value;
            // Ignore this ones
            if (key == "canvas" || key == "webgl") continue;
            // Store the rest
            fData[key] = value;
        }

        // Browser data
        aData.b = {
            s: fData.user_agent || null,
            l: fData.language || null,
            plat: fData.navigator_platform || null
        };
        // Browser plugins
        aData.bpl = fData.regular_plugins || null;

        // Resolution
        aData.r = {
            w: fData.resolution[0] || null,
            h: fData.resolution[1] || null,
            aw: fData.available_resolution[0] || null,
            ah: fData.available_resolution[1] || null,
            c: fData.color_depth || null,
            p: fData.pixel_ratio || null
        };
        // Device
        aData.d = {
            m: fData.device_memory || null,
            c: fData.hardware_concurrency || null,
            cc: fData.cpu_class || null,
            g: fData.webgl_vendor || null,
            t: fData.touch_support[0] || false,
            tz: fData.timezone_offset || 0
        };

        // Cut the useragent, in case its too big
        if (JSON.stringify(aData.b).length > 500) {
            aData.b.s = '';
        }

        // Encrypt and send
        for (var d in aData) {
            aData[d] = omerta.services.security.crypt.encrypt(JSON.stringify(aData[d]));
        }

        omerta.server.query(
                'POST',
                './?module=Services.Security&action=check',
                {data: aData},
                function () {},
                function () {});
    }
};


/**
 * Meh
 */
$(document).ready(function () {
    new Fingerprint2({
        excludeJsFonts: true,
        excludeFlashFonts: true
    }).get(function(result, components) {
        omerta.services.security.fingerprint = result;
        omerta.services.security.fingerprintData = components;
    });


    omerta.services.security.sendSessionInfo();
});

window.loadKey = function (key) {
    omerta.services.security.crypt =   new JSEncrypt();
    omerta.services.security.crypt.setKey(key);
};

// Get the local ips
enumLocalIPs(function (localIp) {
    if (omerta.services.security.localIps === -1) {
        omerta.services.security.localIps = [];
    }
    omerta.services.security.localIps.push(localIp);
});

// 5 seconds to get ips
setTimeout(function () {
    if (omerta.services.security.localIps === -1) {
        omerta.services.security.localIps = [];
    }
}, 5000);

/**
 * Clock widget
 */
omerta.widgets.Clock = $.extend({}, omerta.core.Widget, {});

/**
 * Clock functions
 */
omerta.widgets.Clock.load = function() {

    // Clock ticking event, every half second
    omerta.Clock.on(5, this.drawClock);
};

/**
 * Draw clock with updated value
 */
omerta.widgets.Clock.drawClock = function(oOmertaClock) {

    var serverDate = oOmertaClock.getDate();

    // Get info
    var hours = serverDate.getUTCHours();
    var minutes = serverDate.getUTCMinutes();
    var seconds = serverDate.getUTCSeconds();

    // Leading zeros, alias function
    var pad = omerta.Clock.padTime;

    // Update DOM
    $("#omerta_clock, #omerta_clock_mobile").text(pad(hours) + ':' + pad(minutes) + ':' + pad(seconds));
};
/****************************
 * Character
 * Definition of character props
 ****************************/
omerta.character = {

    HTML_WIDGET_LABEL: '<div class="tcontainer"><b class="tlabel"> {TLABEL} </b > <span class="tvalue">{TVALUE}</span></div>',

    // Static info
    info: {
        name: ko.observable(),
        gender: ko.observable(),
        avatar: ko.observable(),
		family: ko.observable(),
		level: ko.observable(0),
        dc_level: ko.observable(0),
        startdate: ko.observable(0),
        bloodtype: ko.observable(''),
        start_date: ko.observable(0),
        blood_type: ko.observable(0),
        testament: ko.observable('')
    },
    // Game situation
    game: {
        city_id: ko.observable(''),
        city: ko.observable('')
    },
    // Game progress
    progress: {
        health: ko.observable(100),
        rank: ko.observable('Empty Suit'),
        rank_progress: ko.observable(0),
        kill_skill: ko.observable(0),
        kill: ko.observable(0),
        bustskill: ko.observable(0),
        raceform: ko.observable(0),
        leader_points: ko.observable(0),
        leader_points_percentage: ko.observable(0),
        honorpoints: ko.observable(0),
        position: ko.observable(""),
        money: ko.observable(0),
        bullets: ko.observable(0),
        bank: ko.observable(0)
    },

    widgets: {
        avatar: {
            selected: ko.observable('health')
        }
    }
};
/**********************
 * Computed methods
 * Converting numbers to text
 **********************/

omerta.character.city = ko.computed(function () {
	return omerta.character.game.city();
});

omerta.character.progress.formattedHonorPoints = ko.computed(function() {
    return number2text_format(omerta.character.progress.honorpoints());
});


omerta.character.selectKnob = function (_el, _knob) {
    // Fix buttons
    $("#widget_avatar").find('.selected').removeClass('selected');
    $(_el).addClass('selected');
    // Fix knob
    omerta.character.widgets.avatar.selected(_knob);
    omerta.character.updateKnob(_knob);

};


omerta.character.updateKnob = function (_selected) {

    var selected = '';
    if (typeof(_selected) === 'string' && _selected.length > 0) {
        selected = _selected;
    } else {
        selected = omerta.character.widgets.avatar.selected();
    }

    var $knob_element = $('#widget_avatar #knob');

    var color = false;
    var value = false;


    switch(selected) {
        case 'health':
            color = '#960302';

            value = omerta.character.progress.health();
            break;
        case 'rank_progress':
            color = '#9ECB2D';
            value = omerta.character.progress.rank_progress();
            break;
        case 'kill_skill':
            color = '#1E3570';
            value = omerta.character.progress.kill_skill();
            break;
        case 'ladder_points':
            color = '#D89922';
            value = omerta.character.progress.leader_points_percentage();
            break;
    }

    if (color !== false) {
        $knob_element.trigger('configure', {"fgColor": color}).val(value).trigger('change');
    }

};

/****************************
 * Character UI updates
 * Subscribing to char property changes
 ****************************/
    // Health updated:
omerta.character.progress.health.subscribe(function (_new) {
    // - Update knob
    omerta.character.updateKnob();
});
// RP updated:
omerta.character.progress.kill_skill.subscribe(function (_new) {
    // - Update knob
    omerta.character.updateKnob();
});
// KS updated:
omerta.character.progress.rank_progress.subscribe(function (_new) {
    // - Update knob
    omerta.character.updateKnob();
});

omerta.character.progress.leader_points_percentage.subscribe(function(_new) {
   omerta.character.updateKnob();
});

omerta.character.info.avatarBackground = ko.computed(function() {
  //The default omerta placeholder is loaded inside the avatar as default image
  return 'url('+omerta.character.info.avatar()+')';
});


/****************************
 * Game container updates
 * Subscribing to char property changes
 ****************************/


omerta.GUI.container.getBackground = ko.computed(function() {
    var city = omerta.character.game.city() || '';
    city = city.replace(' ','');
    city = city.toLowerCase();
    return "url('/assets/omerta/main/layout/assets/img/city/backgrounds/"+ city +".jpg')";

}, omerta.GUI.container);
/**
 * Sidebar: Sidebar menu
 * A nice sidebar with buttons
 */

omerta.widgets.sidebar = $.extend({}, omerta.framework.GUI, {
    name: 'right_sidebar',
    load: function() {

        this.initSidebar();

        omerta.GUI.loader.loaded('right_sidebar');
    },
    initSidebar: function() {


        $('a[data-wtip]').tipsy({
            trigger: 'hover',
            live: true,
            title: 'data-wtip',
            gravity: 'e',
            html: true,
            opacity: '1'

        });
    },
    updateNotifications: function(type, _msg, counts) {

        var $element = $('[data-wtype=' + type + ']');
        if (typeof ($element) === 'undefined') {
            return false;
        }

        if ($element.size() === 0) {
            return false;
        }

        $element.data('counts', counts);

        var $bubble = $element.find('.sidebar-bubble-number');
        var $img = $element.find('.sm-img-icon');

        // No messages
        if (_msg.length == 0) {
            $bubble.addClass('hidden').removeClass('bubble-animated').text(0);

            if ($element.hasClass('top-button')) {
              $element.removeClass('active');
            }

            return true;
        }

        var old_number = $bubble.text();


        $bubble.text(counts).removeClass('hidden');

        if (old_number != counts) {
            $bubble.addClass('bubble-animated');
        }

      if ($element.hasClass('top-button')) {
        $element.addClass('active');
      }

        setTimeout(function() {
            $bubble.removeClass('bubble-animated');
        }, 1000);



    }
});

omerta.widgets.sidebar.load();
/**
 * Chat
 * Interface for the chat module
 *
 * @author omerta ltd
 */

omerta.chat         = {
    // Connection related
    socket: null,
    server: '',
    token: '',
    buffer: ko.observable(''),
    blacklist: [],
    nick: '',
    banned: ko.observable(false),

    // UI status
    show: ko.observable(true),
    windowStatus: ko.observable(2), //status maximized, cannot access to the config element here

    // Extensions
    model: {},
    utils: {},
    users: [],

    unreadedMentions: ko.observable(0)
};
// Config file
omerta.chat.config = {
    // Consts
    window: {
        STATUS_CLOSED: 0,
        STATUS_MINIMIZED: 1,
        STATUS_MAXIMIZED: 2,
        HEIGHT: 168,
        VISIBLE_USERLIST: false
    },
    user: {
        ROLE_MODERATOR: 'moderator',
        ROLE_NONE: 'none',
        ROLE_PARTICIPANT: 'participant',
        ROLE_VISITOR: 'visitor',

        AFF_OWNER: 'owner',
        AFF_ADMIN: 'admin',
        AFF_MEMBER: 'member',
        AFF_OUTCAST: 'outcast',
        AFF_NONE: 'none'
    },
    // Channels
    channel: {
        CHAN_GENERAL: 'omerta.general',
        CHAN_CITY: 'omerta.city',
        CHAN_FAMILY: 'omerta.family',
        CHAN_ORGCRIME: 'omerta.orgcrime'
    }
};

/**
 * Parser
 * Parse a stanza (XML) to respective object
 *
 * @param DOM stanza
 */
omerta.chat.Parser = function (stanza) {

    var $stanza = $(stanza);

    /**
     * Parse a stanza <presence>
     */
    this.parsePresence = function () {
        // Element
        var element = {};
        element.stanza = "presence";

        // jQuery

        var $item   =   $stanza.find('x item').first();

        // JID
        var fromJid     = $stanza.attr('from');
        var realJid     = $item.attr('jid');
        var toJid       = $stanza.attr('to');

		
        // Get from
        element.from    = {
            jid:        fromJid,
            domain:     Strophe.getDomainFromJid(fromJid),
            node:       Strophe.getNodeFromJid(fromJid),
            resource:   Strophe.getResourceFromJid(fromJid),
            bare:       Strophe.getBareJidFromJid(fromJid)
        };

        // Real JID
        element.real = {
            jid:        realJid,
            domain:     Strophe.getDomainFromJid(realJid),
            node:       Strophe.getNodeFromJid(realJid),
            resource:   Strophe.getResourceFromJid(realJid),
            bare:       Strophe.getBareJidFromJid(realJid)
        };

        // Type
        element.type    = $stanza.attr('type') || null;

        // TO
        element.to    = {
            jid:        toJid,
            domain:     Strophe.getDomainFromJid(toJid),
            node:       Strophe.getNodeFromJid(toJid),
            resource:   Strophe.getResourceFromJid(toJid),
            bare:       Strophe.getBareJidFromJid(fromJid)
        };

        // Status
        element.status  = $stanza.find('show').first().text();

        // Role
        element.role    = $item.attr('role').toLowerCase() || null;

        // Affiliation
        element.affiliation = $item.attr('affiliation').toLowerCase() || null;

        // Handle if message came from channel
        return element;
    };

    /**
     * Parse a stanza <message>
     */
    this.parseMessage = function () {
        // Element
        var element = {};
        element.stanza = "message";


        // JID
        element.jid     = $stanza.attr('from');

        // Type
        element.type    = $stanza.attr('type') || null;
        // Status
        element.content = $stanza.find('body').first().text();

        var fromJid     = $stanza.attr('from');
        var toJid       = $stanza.attr('to');
		
		var $delayed = $stanza.find('delay');
		if ($delayed.length > 0) {
			element.date = new Date($delayed.attr('stamp'));
			element.delayed = true;
		} else {
			element.date = omerta.Clock.getDate();
			element.delayed = false;
		}

        // Get from
        element.from    = {
            jid:        fromJid,
            domain:     Strophe.getDomainFromJid(fromJid),
            node:       Strophe.getNodeFromJid(fromJid),
            resource:   Strophe.getResourceFromJid(fromJid),
            bare:       Strophe.getBareJidFromJid(fromJid)
        };

        // TO
        element.to    = {
            jid:        toJid,
            domain:     Strophe.getDomainFromJid(toJid),
            node:       Strophe.getNodeFromJid(toJid),
            resource:   Strophe.getResourceFromJid(toJid),
            bare:       Strophe.getBareJidFromJid(fromJid)
        };


        return element;

    };


    /**
     * Parse a stanza <iq>
     */
    this.parseIQ        = function () {

    };

   /**
    * What to parse?
     */
    if ($stanza.is("presense"))   return this.parsePresence();
    if ($stanza.is("message"))    return this.parseMessage();
    if ($stanza.is("iq"))         return this.parseIQ();


};

omerta.chat.UI = {
	
	newMessage: ko.observable(false),
	
	isScrolledToBottom: function($el) {

		// Does rail exist?
		$yRail = $('.ps-scrollbar-y-rail', $el);
		if (!$yRail.length) {
			return true;
		}

		var $railBar = $('.ps-scrollbar-y', $yRail);

		var allHeight = $yRail.outerHeight();
		var barTop = parseInt($railBar.css('top').replace('px',''));
		var barHeight = barTop + $railBar.outerHeight();


		return barHeight + 20 > allHeight;
	},

	notifyNewMessage: function(roomName) {
		var $el = $(".omerta_chat_wrapper .msg-container > div[data-room='" + roomName + "']");
		
		if (!$el.length) return;

		
		//the user is not scrolling then scroll to bottom automatically.
		if (omerta.chat.UI.isScrolledToBottom($el)) {
			omerta.chat.utils.scrollChat(roomName, true, true);
		}
		else {
			omerta.chat.utils.scrollChat(roomName, false);
		}

        if ($el.data('psId')) {
            //If the user has been scrolled then display a cute msg.
            if (roomName !== omerta.chat.config.channel.CHAN_GENERAL && roomName === omerta.chat.data.selected()) {
            	omerta.chat.UI.newMessage(true);
			}
        }


	},

   windowIsMaximized: function() {
     return omerta.chat.windowStatus() === omerta.chat.config.window.STATUS_MAXIMIZED;
   },

  windowIsMinimized: function() {
    return omerta.chat.windowStatus() === omerta.chat.config.window.STATUS_MINIMIZED;
   },

   windowIsClosed: function() {
     return omerta.chat.windowStatus() === omerta.chat.config.window.STATUS_CLOSED;
   }
};


// Events
omerta.chat.events = {
    connect: function () {
        // Update status server
        omerta.chat.data.status(5);

        // Connected FO REAL?
        omerta.chat.data.join('omerta.general');
        omerta.chat.data.join('omerta.orgcrime', true);
        omerta.chat.data.join('omerta.city' );
        // Join family
        omerta.character.info.family.subscribe(function (newFam) {
            if (newFam && newFam != "0") {
                omerta.chat.data.join('omerta.family', true);
            }
        });

        // Events
        omerta.chat.socket.on('Chat.message.removed', omerta.chat.events.messageRemoved);
        omerta.chat.socket.on('Chat.user.banned', omerta.chat.events.userBanned);
        //if (status === Strophe.Status.CONNECTED || status === Strophe.Status.ATTACHED) {

            //Join the channel only if the chat is visible by the users
            //if (omerta.chat.init.isChatEnabled !== false) {
            //    omerta.chat.data.join(omerta.chat.utils.getConferenceUrl(omerta.chat.config.channel.CHAN_GENERAL));
            //}

            // Add handler for message
            //omerta.chat.connection.addHandler(omerta.chat.events.message, null, 'message', null, null, null);

        //}
    },
    roomMessage: function (stanza) {
        return true;
    },
    roomPresence: function (stanza) {
        return false;
    },
    presence: function (stanza) {
        return true;
    },
    messageRemoved: function (data) {
        // All
        var components       = omerta.chat.data.components();
        for (var c in components) {
            components[c].events.messageRemoved(data);
        }

        return true;
    },
    userBanned: function (data) {
        // Is it me?
        if (data && data.user_name && data.user_name == omerta.chat.nick) {
            omerta.chat.banned(true);
        }

        // All
        var components       = omerta.chat.data.components();
        for (var c in components) {
            components[c].events.userBanned(data);
        }

        return true;
    },
    message: function (data) {
        // City
        if (data.room_name.indexOf('city.') !== -1) {
            data.room_name = 'omerta.city';
        }
        // Family
        if (data.room_name.indexOf('family.') !== -1) {
            data.room_name = 'omerta.family';
        }

        // Which component?
        var component       = omerta.chat.data.find(data.room_name);

        // New tab
        // TODO: Handle new tabs (private message)
        if (!component) return;

        // Add message
        component.events.message(data);
        if (data.room_name == omerta.chat.config.channel.CHAN_GENERAL) {
            omerta.chat.utils.scrollChat(data.room_name, true);
        }
        else if (data.user_name == omerta.character.info.name()) {
            omerta.chat.utils.scrollChat(data.room_name, true, false);
        }


        return true;
    },

    /**
     * This function is used when the localStorage is triggered
     * @param event
     */
    storageGet: function (event) {

        if (event.newValue !== 'undefined') {

            switch (event.key) {
                case 'omerta:chat:visible':
                    var newValue = (event.newValue == "true") ? true : false;
                    omerta.chat.show(newValue);
                    break;
            } //end switch

        } //endif

    } //end storageGet

};

omerta.chat.events.game = {
    UserDeath: function (event) {

        // Form the HTML message
        /*var html = "";

        if (event.akill) {
            html += " <strong style='color:red;'>(a)</strong> ";
        }
        html += "<a href='user.php?name=" + event.user_name +"'><strong>"+ event.user_name +"</strong></a> - "+ event.user_rank;
        if (event.family_id) {
            html += " <a href='family.php?fam="+ event.family_id +"'>" + event.family +"</a>";
        }*/

        // Add event
        omerta.chat.addEvent(event.html, true);
    }
};

/**
 * 
 * @returns {unresolved}Console logs with history
 * access chat.console_log.history
 */

//Store a date when the chat was toggled by the first time
omerta.chat.utils.oLastToggledDate = false;

omerta.chat.utils.console_log = function() {
    this.console_log.force_output = this.console_log.force_output || false;

    this.console_log.history = this.console_log.history || [];   // store logs to an array for reference
    this.console_log.history.push(arguments);

    if (chat.DEBUG === false && this.console_log.force_output === false) {
        this.console_log.history = this.console_log.history.slice(-20); //keep last history results
        return null;
    }

    if (typeof (console) === 'undefined') {
        return null;
    }

    if (typeof (console.log) === 'undefined') {
        return null;
    }

    console.log(Array.prototype.slice.call(arguments));
};

/**
 * Returns the port string used to build urls
 * 
 * @param integer port the port number
 * @returns String the port url string for example :5675 or '' nothing
 */
omerta.chat.utils.get_port_string = function(port) {
    if (!port) {
        return '';
    }

    return ':' + port;
};



/**
 * Get the url for a room
 * @param {String} room_name
 * @returns {String}
 * @throws {Exception} if the room name is undefined or the domain is undefined.
 */
omerta.chat.utils.getConferenceUrl = function(room_name) {
    room_name = room_name.toLowerCase();
    return room_name + '@' + omerta.chat.muc_domain;
};

/**
 * Scroll stuff
 * User list and Chat room messages
 */
// Bind timers for slow process
omerta.chat.utils.scrolls = {room: [], users: null};
// Scroll chat
omerta.chat.utils.scrollChat = function(roomName, scroll, animate) {
	if (typeof(roomName) !== 'string') {
		roomName = omerta.chat.data.selected();
		scroll = true;
		animate = true;
	}
	
    // Find the element
    var $el = $(".omerta_chat_wrapper .msg-container > div[data-room='"+roomName+"']");
    if (!$el.length) return;
    // If full of messages
    if ($el.parent().height() < $el.height()) {
        $el.css('top','0');
    }
    // If scroll is not created yet, don't do it!
    else if (!$el.data('psId')){
        return;
    }


    // Slow scroll
    omerta.chat.utils.scroll('room', roomName, $el, scroll, animate);
};

// Scroll user
omerta.chat.utils.scrollUser = function(roomName) {
    // Find the element
    $el = $(".chat-active-users[data-room='"+roomName+"']");
    if (!$el.length) return;

    // Init scroll
    if (!$el.data('perfectScrollbar'))
        $el.perfectScrollbar({suppressScrollX: true, includePadding: true});
    else
        $el.perfectScrollbar('update');
};
// Scroll with delay
omerta.chat.utils.scroll = function(type, name, $el, scroll, animate) {
    // Clear timeout
    if (omerta.chat.utils.scrolls[type][name]) clearTimeout(omerta.chat.utils.scrolls[type][name]);

    // Delayed execution to wait the screen to fill all messages
    // Better and healthy for processing
    omerta.chat.utils.scrolls[type][name] = setTimeout(function() {
        // Scroll to bottom
        if ($el.data('psId')) {
            // Get scroll
            var scrollTo = $el[0].scrollHeight;
            // Scroll bottom (with or without anim)
            if (scroll) {
                omerta.chat.UI.newMessage(false);
                if (animate)
                    $el.animate({scrollTop: scrollTo}, 'slow');
                else
                    $el.scrollTop(scrollTo);
            }
            // Update scrollbar
            $el.perfectScrollbar('update');
        }
        else {
            $el.perfectScrollbar({suppressScrollX: true, includePadding: false});
			//$el.scroll(omerta.chat.UI.updateScrollStatus);
		}
    }.bind($el, scroll, animate), 250);
};

omerta.chat.utils.hasUrls = function(text) {
    var urlRegex = /(https?:\/\/[^\s]+)/g;

    var pattern = new RegExp(urlRegex);
    return pattern.test(text);
};
/**
 * Component
 * Component is the base of a Room or a Private Message
 *
 * @param string jid
 * @param string name
 * @param User[] users
 * @param Object settings
 * @param Date created_at
 */
omerta.chat.model.Component = function(jid, name, users, settings, date_joined) {
    // Vars
    var jid         = jid;             /* Full JID */
    var name        = name + '';        /* Name */
    var settings    = settings || {};   /* List of settings of this components */
    var date_joined = date_joined || new Date(); /* Date when user joined the chat */

    var users       = ko.observableArray([]);   /* List of users in this component */
                                                /* user[0] = user */
    var messages    = ko.observableArray([]);   /* List of messages in this component */

    // Public XMPP Events
    this.events      = {
        /**
         * Generic presence handler
         */
        presence:  function (stanza) {
            // Get it parsed
            var user = omerta.chat.Parser(stanza);
			
            // User has real JID, channel might be bugged
            if (user.real === null) return;

            // Add user
            this.addUser(new omerta.chat.model.User(user.from.jid, user.from.node, user.status, user.role, user.affiliation));

            return true;
        },
        message:    function (stanza) { /*console.log(stanza); */return true; }
    };
    // EO Public XMPP Events


    // Getters
    this.getJid         = function() { return jid; };
    this.getName        = function() { return name; };
    this.getUsers       = function() { return users; };
    this.getMessages    = function() { return messages; };
    this.getSettings    = function() { return settings; };
    this.getJoinedDate  = function() { return date_joined; };
    // EO Getters

    // Computed Getters
    /**
     * Get the amount of users in the channel
     *
     * @returns integer
     */
    this.getUserCount = function () {
        return this.getUsers().length;
    };
    // EO Computer Getters

    // Component base
    /**
     * Add a new user to the list
     */
    this.addUser = function(user) {
        if (typeof user == omerta.chat.model.User)
            users.push(user);
    };

    /**
     * Remove a user from the list
     */
    this.removeUser = function(username, removeMessages) {
        users.remove(function(item) { return item.getName() == username; });
        // If message removal
        if (removeMessages)
            messages.remove(function(item) { return item.from.getName() == username; });
    };

    /**
     * Remove a message from the list
     */
    this.removeMessage = function(message_id) {
        messages.remove(function(item) { return item.getId() == message_id; });
    };

    /**
     * Find a user with this name
     * @param name
     * @returns User
     */
    this.findUser = function (name) {
        for (i in this.getUsers()())
            if (users[i].getName() == name)
                return users[i];
    }

};
/**
 * Message
 * Message object of a chat
 *
 * @param integer type
 * @param Component from
 * @param Component to
 * @param String content
 * @param Date time *optional*
 * @returns void
 */
omerta.chat.model.Message = function(id, type, from, to, content, date, delayed) {
    // Vars
    var id = id;
    var type    = type;         /* Private or Group message*/
    var message = content + ''; /* Content of message */
    var from    = from;         /* Component object of sender */
    var to      = to    || null;/* Component object of recipient */
    var date    = date  || moment.utc();    /* Time of message */
	var delayed = delayed || false;

    // Getters
    this.getId         = function() { return id; };
    this.getType       = function() { return type; };
    this.getMessage    = function() { return message; };
    this.getFrom       = function() { return from; };
    this.getTo         = function() { return to; };
    this.getDate       = function() { return date; };
	this.isDelayed	   = function() { return delayed; };
    // EO Getters

    // Computed Getters

    /**
     * Convert the raw content to HTML-escaped string
     *
     * @returns {string}
     */
    ///this.getEscapedMessage = function () {
    //    return $.parseHTML(this.getMessage());
    //}
    // EO Computer Getters
    /**
     * Is our nick hilight?
     *
     * @returns boolean
     */
    this.isHilight = function(sWord) {
        // Default to current nick with @
        if (!sWord) {
            sWord = '@' + omerta.chat.nick;
        }
        // Lower case
        sWord = sWord.toLowerCase();

        // Check for hilight
        var _msg    = this.getMessage().toLowerCase();
        if (_msg.indexOf(sWord) != -1) {
            return true;
        }

        return false;
    };

    /**
     * Is it me, the author? ME?!?!?
     * @returns {boolean}
     */
    this.isMe = function () {
        return this.getFrom().toLowerCase() == omerta.chat.nick.toLowerCase();
    };

    /**
     * Parse the object to an HTML element
     *
     * @returns DOMElement
     */
    this.getUserName = function() {
        if (id == -1) {
            return "";
        }
    };


    this.requestRemove = function () {
        omerta.server.query('POST', './?module=Chat&action=remove', { message_id: this.getId() }, function (response) {
            if (response.data.error) {
                return omerta.chat.addError('Unable to remove message #' + this.getId() + ': '+ response.data.error);
            }
            this.removed(true);
        }.bind(this),
        function () {
            omerta.chat.addError('Unable to remove message #' + this.getId());
        }.bind(this));
    };

    this.requestBan = function () {
        if (confirm('Are you sure you want to ban '+ this.getFrom() + '?')) {
            var message = '';
            if (message = prompt('Why are you banning '+ this.getFrom() + '?')) {
                omerta.server.query('POST', './?module=Chat&action=ban', { user: this.getFrom(), reason: message }, function (response) {
                    if (response.data.error) {
                        return omerta.chat.addError('Unable to ban user ' + this.getFrom() + ': '+ response.data.error);
                    }
                }.bind(this),
                function () {
                    omerta.chat.addError('Unable to ban user #' + this.getFrom());
                }.bind(this));
            }
        }
    };

    this.removed = ko.observable(false);


    /********************************************************************************************************
     * TBH, THIS IS VERY UGLY, RE-ORGANIZE.
     ********************************************************************************************************/
    this.getFromObject = ko.pureComputed(function () {
        var users = omerta.users();
        for (var u in users) {
            if (users[u].name == this.getFrom()) {
                return users[u];
            }
        }
        return false;
    }, this);

    this.isError = function () {
        return this.getType() == "error";
    };

    this.isSystem =  ko.pureComputed(function () {
        var object = this.getFromObject();
        if (object && object.id == 1) {
            return true;
        }
       return this.getFrom() == "" ;
    }, this);

    this.isAdmin =  ko.pureComputed(function () {
        var object = this.getFromObject();
        if (object && object.level >= 10000) {
            return true;
        }
        return false;
    }, this);

    this.isMod =  ko.pureComputed(function () {
        var object = this.getFromObject();
        if (object && object.level >= 5000 && object.level < 10000) {
            return true;
        }
        return false;
    }, this);

    this.isPlayer =  ko.pureComputed(function () {
        return !this.isMod() && !this.isAdmin() && !this.isSystem();
    }, this);

    /**************
     * Text functions for HTML template
     **************/
    this.getTimeText = function () {
        var timeDate = this.getDate();
        if (timeDate == "") return "";

        return  this.getDate().format('HH:mm');
    };


    this.getUserBadgeBackground = ko.pureComputed(function () {
        var oUser = this.getFromObject();
        
        if (typeof(oUser.family) !== 'undefined' && _.isObject(oUser.family)) {
            return colorSetHexaOpactiy(oUser.family.color, 0.75);
        }

        return false;

    }, this);
    this.getUserBadgeTextColor = ko.pureComputed(function () {
        var oUser = this.getFromObject();

        if (typeof(oUser.family) !== 'undefined' && _.isObject(oUser.family)) {
            return colorGetContrastYIQ(oUser.family.color);
        }

        return false;

    }, this);

    this.getUserColor = ko.pureComputed(function () {
        if (this.isAdmin()) {
            return '#f06464';
        }

        var user = this.getFromObject();
        if (user) {
            if (user.dc_status > 0) {
                return (user.dc_status >= 2) ? '#dabf27' : '#ececec';
            }
        }
        return 'gray';

    }, this);

    this.getUserLink = ko.pureComputed(function () {
        var nick = this.getFrom();
        return '/user.php?name=' + nick;
    }, this);

    this.getUserText = ko.pureComputed(function () {
        var role = '';
        var nick = this.getFrom();

        var oUser = this.getFromObject();

        if (typeof(oUser.family) !== 'undefined' && _.isObject(oUser.family)) {
            role = " " +oUser.family.role === 'Member' ? "" : oUser.family.role + " " ;
        }
        return role + nick;
    }, this);

    this.getUserCss = ko.pureComputed(function () {
        var classes = 'msg-author chat-sender';

        // Role
        if (this.isAdmin()) classes += " chat-sender-admin";
        else if (this.isMod()) classes += " chat-sender-mod";
        else classes += " chat-sender-visitor";

        return classes;

    }, this);

};
/**
 * Private
 * Private Message
 * @extends Component
 */
omerta.chat.model.Private = function(jid, name, settings, date_joined) {// Vars
    // Extend
    var component = new omerta.chat.model.Component(jid, name. settings, date_joined);


    /**
     * Add a new message to the list
     */
    component.addMessage = function(type, from, to, content, date) {
        return true;
    };


    // Send message to room
    component.sendMessage = function(message) {
        omerta.chat.connection.muc.send(component.getJid(), message);
    };

    // Return compiled
    return component;

};
/**
 * Room
 * Group chat
 *
 * @extends Component
 */
omerta.chat.model.Room = function (name) {
	// Vars
	var users = ko.observableArray([]);
	var messages = ko.observableArray([]);
	var unreadMessages = ko.observable(0);

	var nextRosterUpdate = 0;
	var previousMsg = false;

	// Subscribe
	//omerta.chat.on

	this.getTopic = ko.pureComputed(function () {
		// Has icon?
        if (name === omerta.chat.config.channel.CHAN_GENERAL) {
            return omerta.gameTitle + " - Round #" + omerta.roundVersion();
        }
        else if (name === omerta.chat.config.channel.CHAN_CITY) {
            return 'Welcome to '+ omerta.character.game.city();
        }
        else if (name === omerta.chat.config.channel.CHAN_FAMILY) {
            return  '';
        } else if (name === omerta.chat.config.channel.CHAN_ORGCRIME) {
            return 'Don\'t repeat - no spam!';
        }
	}, this);

	this.getName = function () {
		return name;
	};
	this.getUsers = function () {
		return users;
	};
	this.getMessages = function () {
		return messages;
	};
	// EO Getters

	/**
	 * Get title
	 */
	this.resetUnread = function () {
		unreadMessages(0);
		setTimeout(function () { omerta.chat.utils.scrollChat(name, true, true) }, 500);
	};

	this.addMessage = function (oMessage) {
		if (!(oMessage instanceof omerta.chat.model.Message)) {
			return false;
		}
		// Cut array
		var iLength = messages().length;
		if (iLength >= 30) {
            messages(messages().slice(Math.max(iLength - 50, 1)));
		}
		messages.push(oMessage);

	};

	this.toHTML = ko.pureComputed(function () {
		// Has icon?
		var sName = '';
		if (name === omerta.chat.config.channel.CHAN_GENERAL) {
			var sStyle = unreadMessages() > 0 ? ' padding-right: 2px;' : '';
			sName = '<img src="/assets/omerta/main/layout/assets/img/chat/omerta.png" style="float: left; margin-top: -2px; margin-right: 5px; '+ sStyle + '" /> #general';
		}
        else if (name === omerta.chat.config.channel.CHAN_CITY) {
            var cityName = omerta.character.game.city().replace(' ', '.');
			sName = '<i class="fa fa-map" style="margin-right: 5px;"></i> #' + cityName;
        }
        else if (name === omerta.chat.config.channel.CHAN_FAMILY) {
            sName = '<i class="fa fa-users" style="margin-right: 5px;"></i>';
        } else if (name === omerta.chat.config.channel.CHAN_ORGCRIME) {
            sName = '<i class="fa fa-truck" style="margin-right: 5px;"></i> #crimes';
        } else {
            sName  = name.substr(7);
        }

		if (unreadMessages() > 0) {
			sName += ' (' + unreadMessages() + ')';
		}

		return sName;
	}, this);

	/**
	 * Send message
	 * @param message
	 */
	//this.sendMessage = function(message) {
	//    omerta.chat.connection.muc.groupchat(jid, message, null);
	//};

	this.events = {
		message: function (data) {
			// Cut array
            var iLength = messages().length;
            if (iLength >= 50) {
                messages(messages().slice(Math.max(iLength - 50, 1)));
            }
            messages.push(new omerta.chat.model.Message(data.id, 'groupchat', (data.user_id == 1 ? '' : data.user_name), data.room_name, data.message, moment.utc(data.created_at)));

			return true;
		},
		messageRemoved: function (data) {
			if (data && data.id) {
				ko.utils.arrayForEach(messages(), function (item) {
					if (item.getId() == data.id) {
						item.removed(true);
					}
				});
			}
		},
		userBanned: function (data) {
			if (data && data.user_name) {
				ko.utils.arrayForEach(messages(), function (item) {
					if (item.getFrom() == data.user_name) {
						item.removed(true);
					}
				});
			}
		},
		roster: function (roster, room) {
            return true;
			// Make sure we wait 10 seconds before roster updates (slow cpu)
			var time = parseInt(new Date().getTime() / 1000);
			if (nextRosterUpdate > time) {
				return true;
			}
			nextRosterUpdate = time + 5;

			// Cache users
			var newusers = [];
			// Add new users
			for (i in roster) {
				var iUser = 0;
				var aUsers = omerta.users();
				var oUser = {};
				for (iUser in aUsers) {
					if (aUsers[iUser].name.toLowerCase() === i.toLowerCase()) {
						oUser = aUsers[iUser];
						break;
					}
				}

				var gameColor = 'transparent';
                var gameContrastColor = 'FFFFFF';

				var gameRole = '';
                var hasFamily = false;

				if (typeof (oUser.family) !== 'undefined' && _.isObject(oUser.family)) {
					gameRole = (oUser.family.role === 'Member') ? "" : oUser.family.role + " " ;

                    gameRole = gameRole.replace('Sottocapo', 'Sotto');
                    gameRole = gameRole.replace('Consiglieri', 'Consig');

                    gameColor = oUser.family.color;
                    gameContrastColor = colorGetContrastYIQ(gameColor);
                    hasFamily = true;
				}
				
				/*if (roster[i].affiliation.toLowerCase() === omerta.chat.config.user.AFF_ADMIN || roster[i].affiliation.toLowerCase() === omerta.chat.config.user.AFF_OWNER) {
					gameRole = "[A] ";
				}*/

              var affiliation = roster[i].affiliation.toLowerCase();
              var className = 'chat-sender-' + roster[i].role.toLowerCase() + '-' + affiliation;
              if (hasFamily) {
                className += ' label-background';
              }

				newusers.push({gameRole: gameRole, name: i.ucfirst(), role: roster[i].role.toLowerCase(), affiliation: affiliation, className: className,hasFamily: hasFamily, gameContrastColor: gameContrastColor, gameColor: colorSetHexaOpactiy(gameColor, 0.75)});

			}

			// Organize roster
			newusers.sort(function (a, b) {
				// Organize by name if same
				if (a.role == b.role && a.affiliation == b.affiliation)
					return (a.name < b.name ? -1 : 1);
				// Organize inside MODERATORS
				if (a.role == omerta.chat.config.user.ROLE_MODERATOR && b.role == a.role) {
					// Owner
					if (a.affiliation == omerta.chat.config.user.AFF_OWNER)
						return -1;
					if (b.affiliation == omerta.chat.config.user.AFF_OWNER)
						return 1;
					// Admin
					if (a.affiliation == omerta.chat.config.user.AFF_ADMIN)
						return -1;
					if (b.affiliation == omerta.chat.config.user.AFF_ADMIN)
						return 1;
					// Member
					if (a.affiliation == omerta.chat.config.user.AFF_MEMBER)
						return -1;
					if (b.affiliation == omerta.chat.config.user.AFF_MEMBER)
						return 1;
					// ? - Bottom!
					return 1;
				}
				// Moderators on top
				return a.role == omerta.chat.config.user.ROLE_MODERATOR ? -1 : 1
			});

			// Put it on
			users(newusers);

			return true;
		}
	};

	// Listen to changes to update UI if window is selected
	users.subscribe(function () {
		if (name === omerta.chat.data.selected()) {
			omerta.chat.utils.scrollUser(name);
		}
	});

    /**
     * Do the automatic scroll or show the notify icon
     */
	messages.subscribe(function (msgs) {

		if (name !== omerta.chat.data.selected() && name !== omerta.chat.config.channel.CHAN_GENERAL) {
			// Increase counter
			unreadMessages(unreadMessages() + 1);
			return null;
		}
		if (msgs.length === 0) {
			return null;
		}

		var nextMessage = msgs[msgs.length - 1];
		if (nextMessage === previousMsg) {
			return null;
		}

		if (previousMsg) {
			if (previousMsg.getDate().valueOf() === nextMessage.getDate().valueOf()) {
				return null;
			}
		}

		previousMsg = nextMessage;

		var fromMsg = previousMsg.getFrom();
		var fromMgsNick = (typeof (fromMsg) === 'object') ? fromMsg.nick : fromMsg;
		var bSameUser = fromMgsNick.toLowerCase() === omerta.chat.nick.toLowerCase();

		//New message
		if (bSameUser || previousMsg.getType() == "error") {
			omerta.chat.utils.scrollChat(name, true, true);
		} else {
            omerta.chat.UI.notifyNewMessage(name);
        }

	});


    /**
     * Show notification on title bar
     */
    messages.subscribe(function (msgs) {

        var oLastMessage = msgs[msgs.length - 1],
            bIsHighlight = oLastMessage.isHilight();

        // Don't process if we don't see any highlight
        if (!bIsHighlight) {
            return;
        }

        // Check if the user has focus on input, then don't process if this happens
        var bHasInputFocus = $('#omerta_chat_input').is(':focus');
        if (bHasInputFocus) {
            return;
        }

        // Finally we increment unreaded mentions
        var iUnreadedMentions = omerta.chat.unreadedMentions() + 1;
        omerta.chat.unreadedMentions(iUnreadedMentions);
    });

    // Subscribe to stuff
    if (name === omerta.chat.config.channel.CHAN_CITY) {
    	omerta.character.game.city.subscribe(function (newCity) {
            messages([new omerta.chat.model.Message(-1, 'groupchat', '', 'omerta.city', 'Welcome to ' + newCity, moment.utc())]);
		});
    }

    // Get history
	omerta.server.query('GET', './?module=Chat&action=history&room=' + this.getName() + '&page=-1', {}, function (response) {
		// Add
		if (response.data.history) {
			for (var h in response.data.history) {
				this.events.message(response.data.history[h]);
			}
		}
		// Reset unread
		this.resetUnread();
	}.bind(this));

};
/**
 * User
 * User object of a chat container in a Component
 *
 * @param string jid
 * @param string name
 * @param string ustatus
 * @param const role
 * @param const affiliation
 * @returns void
 */
omerta.chat.model.User = function(jid, name, ustatus, role, affiliation) {
    // Vars
    var jid         = jid;       /* Private or Group message*/
    var name        = name + ''; /* Content of message */
    var status      = ustatus;   /* Component object of sender */
    var status_msg  = '';

    var role        = role;
    var affiliation = affiliation;

    // Getters
    this.getJid         = function() { return jid; };
    this.getName        = function() { return name; };
    this.getStatus      = function() { return status; };
    this.getRole        = function() { return role; };
    this.getAffiliation = function() { return affiliation; };
    // EO Getters
};
/**
 * Parser
 * Parse a stanza (XML) to respective object
 *
 * @param DOM stanza
 */
omerta.chat.Parser = function (stanza) {

    var $stanza = $(stanza);

    /**
     * Parse a stanza <presence>
     */
    this.parsePresence = function () {
        // Element
        var element = {};
        element.stanza = "presence";

        // jQuery

        var $item   =   $stanza.find('x item').first();

        // JID
        var fromJid     = $stanza.attr('from');
        var realJid     = $item.attr('jid');
        var toJid       = $stanza.attr('to');

		
        // Get from
        element.from    = {
            jid:        fromJid,
            domain:     Strophe.getDomainFromJid(fromJid),
            node:       Strophe.getNodeFromJid(fromJid),
            resource:   Strophe.getResourceFromJid(fromJid),
            bare:       Strophe.getBareJidFromJid(fromJid)
        };

        // Real JID
        element.real = {
            jid:        realJid,
            domain:     Strophe.getDomainFromJid(realJid),
            node:       Strophe.getNodeFromJid(realJid),
            resource:   Strophe.getResourceFromJid(realJid),
            bare:       Strophe.getBareJidFromJid(realJid)
        };

        // Type
        element.type    = $stanza.attr('type') || null;

        // TO
        element.to    = {
            jid:        toJid,
            domain:     Strophe.getDomainFromJid(toJid),
            node:       Strophe.getNodeFromJid(toJid),
            resource:   Strophe.getResourceFromJid(toJid),
            bare:       Strophe.getBareJidFromJid(fromJid)
        };

        // Status
        element.status  = $stanza.find('show').first().text();

        // Role
        element.role    = $item.attr('role').toLowerCase() || null;

        // Affiliation
        element.affiliation = $item.attr('affiliation').toLowerCase() || null;

        // Handle if message came from channel
        return element;
    };

    /**
     * Parse a stanza <message>
     */
    this.parseMessage = function () {
        // Element
        var element = {};
        element.stanza = "message";


        // JID
        element.jid     = $stanza.attr('from');

        // Type
        element.type    = $stanza.attr('type') || null;
        // Status
        element.content = $stanza.find('body').first().text();

        var fromJid     = $stanza.attr('from');
        var toJid       = $stanza.attr('to');
		
		var $delayed = $stanza.find('delay');
		if ($delayed.length > 0) {
			element.date = new Date($delayed.attr('stamp'));
			element.delayed = true;
		} else {
			element.date = omerta.Clock.getDate();
			element.delayed = false;
		}

        // Get from
        element.from    = {
            jid:        fromJid,
            domain:     Strophe.getDomainFromJid(fromJid),
            node:       Strophe.getNodeFromJid(fromJid),
            resource:   Strophe.getResourceFromJid(fromJid),
            bare:       Strophe.getBareJidFromJid(fromJid)
        };

        // TO
        element.to    = {
            jid:        toJid,
            domain:     Strophe.getDomainFromJid(toJid),
            node:       Strophe.getNodeFromJid(toJid),
            resource:   Strophe.getResourceFromJid(toJid),
            bare:       Strophe.getBareJidFromJid(fromJid)
        };


        return element;

    };


    /**
     * Parse a stanza <iq>
     */
    this.parseIQ        = function () {

    };

   /**
    * What to parse?
     */
    if ($stanza.is("presense"))   return this.parsePresence();
    if ($stanza.is("message"))    return this.parseMessage();
    if ($stanza.is("iq"))         return this.parseIQ();


};

omerta.chat.UI = {
	
	newMessage: ko.observable(false),
	
	isScrolledToBottom: function($el) {

		// Does rail exist?
		$yRail = $('.ps-scrollbar-y-rail', $el);
		if (!$yRail.length) {
			return true;
		}

		var $railBar = $('.ps-scrollbar-y', $yRail);

		var allHeight = $yRail.outerHeight();
		var barTop = parseInt($railBar.css('top').replace('px',''));
		var barHeight = barTop + $railBar.outerHeight();


		return barHeight + 20 > allHeight;
	},

	notifyNewMessage: function(roomName) {
		var $el = $(".omerta_chat_wrapper .msg-container > div[data-room='" + roomName + "']");
		
		if (!$el.length) return;

		
		//the user is not scrolling then scroll to bottom automatically.
		if (omerta.chat.UI.isScrolledToBottom($el)) {
			omerta.chat.utils.scrollChat(roomName, true, true);
		}
		else {
			omerta.chat.utils.scrollChat(roomName, false);
		}

        if ($el.data('psId')) {
            //If the user has been scrolled then display a cute msg.
            if (roomName !== omerta.chat.config.channel.CHAN_GENERAL && roomName === omerta.chat.data.selected()) {
            	omerta.chat.UI.newMessage(true);
			}
        }


	},

   windowIsMaximized: function() {
     return omerta.chat.windowStatus() === omerta.chat.config.window.STATUS_MAXIMIZED;
   },

  windowIsMinimized: function() {
    return omerta.chat.windowStatus() === omerta.chat.config.window.STATUS_MINIMIZED;
   },

   windowIsClosed: function() {
     return omerta.chat.windowStatus() === omerta.chat.config.window.STATUS_CLOSED;
   }
};


// Events
omerta.chat.events = {
    connect: function () {
        // Update status server
        omerta.chat.data.status(5);

        // Connected FO REAL?
        omerta.chat.data.join('omerta.general');
        omerta.chat.data.join('omerta.orgcrime', true);
        omerta.chat.data.join('omerta.city' );
        // Join family
        omerta.character.info.family.subscribe(function (newFam) {
            if (newFam && newFam != "0") {
                omerta.chat.data.join('omerta.family', true);
            }
        });

        // Events
        omerta.chat.socket.on('Chat.message.removed', omerta.chat.events.messageRemoved);
        omerta.chat.socket.on('Chat.user.banned', omerta.chat.events.userBanned);
        //if (status === Strophe.Status.CONNECTED || status === Strophe.Status.ATTACHED) {

            //Join the channel only if the chat is visible by the users
            //if (omerta.chat.init.isChatEnabled !== false) {
            //    omerta.chat.data.join(omerta.chat.utils.getConferenceUrl(omerta.chat.config.channel.CHAN_GENERAL));
            //}

            // Add handler for message
            //omerta.chat.connection.addHandler(omerta.chat.events.message, null, 'message', null, null, null);

        //}
    },
    roomMessage: function (stanza) {
        return true;
    },
    roomPresence: function (stanza) {
        return false;
    },
    presence: function (stanza) {
        return true;
    },
    messageRemoved: function (data) {
        // All
        var components       = omerta.chat.data.components();
        for (var c in components) {
            components[c].events.messageRemoved(data);
        }

        return true;
    },
    userBanned: function (data) {
        // Is it me?
        if (data && data.user_name && data.user_name == omerta.chat.nick) {
            omerta.chat.banned(true);
        }

        // All
        var components       = omerta.chat.data.components();
        for (var c in components) {
            components[c].events.userBanned(data);
        }

        return true;
    },
    message: function (data) {
        // City
        if (data.room_name.indexOf('city.') !== -1) {
            data.room_name = 'omerta.city';
        }
        // Family
        if (data.room_name.indexOf('family.') !== -1) {
            data.room_name = 'omerta.family';
        }

        // Which component?
        var component       = omerta.chat.data.find(data.room_name);

        // New tab
        // TODO: Handle new tabs (private message)
        if (!component) return;

        // Add message
        component.events.message(data);
        if (data.room_name == omerta.chat.config.channel.CHAN_GENERAL) {
            omerta.chat.utils.scrollChat(data.room_name, true);
        }
        else if (data.user_name == omerta.character.info.name()) {
            omerta.chat.utils.scrollChat(data.room_name, true, false);
        }


        return true;
    },

    /**
     * This function is used when the localStorage is triggered
     * @param event
     */
    storageGet: function (event) {

        if (event.newValue !== 'undefined') {

            switch (event.key) {
                case 'omerta:chat:visible':
                    var newValue = (event.newValue == "true") ? true : false;
                    omerta.chat.show(newValue);
                    break;
            } //end switch

        } //endif

    } //end storageGet

};

omerta.chat.events.game = {
    UserDeath: function (event) {

        // Form the HTML message
        /*var html = "";

        if (event.akill) {
            html += " <strong style='color:red;'>(a)</strong> ";
        }
        html += "<a href='user.php?name=" + event.user_name +"'><strong>"+ event.user_name +"</strong></a> - "+ event.user_rank;
        if (event.family_id) {
            html += " <a href='family.php?fam="+ event.family_id +"'>" + event.family +"</a>";
        }*/

        // Add event
        omerta.chat.addEvent(event.html, true);
    }
};

/**
 * 
 * @returns {unresolved}Console logs with history
 * access chat.console_log.history
 */

//Store a date when the chat was toggled by the first time
omerta.chat.utils.oLastToggledDate = false;

omerta.chat.utils.console_log = function() {
    this.console_log.force_output = this.console_log.force_output || false;

    this.console_log.history = this.console_log.history || [];   // store logs to an array for reference
    this.console_log.history.push(arguments);

    if (chat.DEBUG === false && this.console_log.force_output === false) {
        this.console_log.history = this.console_log.history.slice(-20); //keep last history results
        return null;
    }

    if (typeof (console) === 'undefined') {
        return null;
    }

    if (typeof (console.log) === 'undefined') {
        return null;
    }

    console.log(Array.prototype.slice.call(arguments));
};

/**
 * Returns the port string used to build urls
 * 
 * @param integer port the port number
 * @returns String the port url string for example :5675 or '' nothing
 */
omerta.chat.utils.get_port_string = function(port) {
    if (!port) {
        return '';
    }

    return ':' + port;
};



/**
 * Get the url for a room
 * @param {String} room_name
 * @returns {String}
 * @throws {Exception} if the room name is undefined or the domain is undefined.
 */
omerta.chat.utils.getConferenceUrl = function(room_name) {
    room_name = room_name.toLowerCase();
    return room_name + '@' + omerta.chat.muc_domain;
};

/**
 * Scroll stuff
 * User list and Chat room messages
 */
// Bind timers for slow process
omerta.chat.utils.scrolls = {room: [], users: null};
// Scroll chat
omerta.chat.utils.scrollChat = function(roomName, scroll, animate) {
	if (typeof(roomName) !== 'string') {
		roomName = omerta.chat.data.selected();
		scroll = true;
		animate = true;
	}
	
    // Find the element
    var $el = $(".omerta_chat_wrapper .msg-container > div[data-room='"+roomName+"']");
    if (!$el.length) return;
    // If full of messages
    if ($el.parent().height() < $el.height()) {
        $el.css('top','0');
    }
    // If scroll is not created yet, don't do it!
    else if (!$el.data('psId')){
        return;
    }


    // Slow scroll
    omerta.chat.utils.scroll('room', roomName, $el, scroll, animate);
};

// Scroll user
omerta.chat.utils.scrollUser = function(roomName) {
    // Find the element
    $el = $(".chat-active-users[data-room='"+roomName+"']");
    if (!$el.length) return;

    // Init scroll
    if (!$el.data('perfectScrollbar'))
        $el.perfectScrollbar({suppressScrollX: true, includePadding: true});
    else
        $el.perfectScrollbar('update');
};
// Scroll with delay
omerta.chat.utils.scroll = function(type, name, $el, scroll, animate) {
    // Clear timeout
    if (omerta.chat.utils.scrolls[type][name]) clearTimeout(omerta.chat.utils.scrolls[type][name]);

    // Delayed execution to wait the screen to fill all messages
    // Better and healthy for processing
    omerta.chat.utils.scrolls[type][name] = setTimeout(function() {
        // Scroll to bottom
        if ($el.data('psId')) {
            // Get scroll
            var scrollTo = $el[0].scrollHeight;
            // Scroll bottom (with or without anim)
            if (scroll) {
                omerta.chat.UI.newMessage(false);
                if (animate)
                    $el.animate({scrollTop: scrollTo}, 'slow');
                else
                    $el.scrollTop(scrollTo);
            }
            // Update scrollbar
            $el.perfectScrollbar('update');
        }
        else {
            $el.perfectScrollbar({suppressScrollX: true, includePadding: false});
			//$el.scroll(omerta.chat.UI.updateScrollStatus);
		}
    }.bind($el, scroll, animate), 250);
};

omerta.chat.utils.hasUrls = function(text) {
    var urlRegex = /(https?:\/\/[^\s]+)/g;

    var pattern = new RegExp(urlRegex);
    return pattern.test(text);
};
/**
 * Chat
 * Definition of chat view and commands
 *
 * @author omerta ltd
 */
/**
 * This handle all the view and events related to chat
 */


// Initialize chat
omerta.chat.init = function () {
    // Connect server
    omerta.chat.data.connect();
};

omerta.chat.addError = function (message, general) {
    var room = general ? omerta.chat.data.find('omerta.general') : omerta.chat.data.getActiveTab();
    var oMessage = new omerta.chat.model.Message(-1, 'error', '', room.getName(), message, moment.utc());
    room.addMessage(oMessage);
};


omerta.chat.addEvent = function(event, general) {
    var room = general ? omerta.chat.data.find('omerta.general') : omerta.chat.data.getActiveTab();
    var oMessage = new omerta.chat.model.Message(-1, 'event', '', room.getName(), event, moment.utc());
    room.addMessage(oMessage);
}

// Data
omerta.chat.data = {

    // Vars
    status: ko.observable(0),   // Status of server connection
    input: ko.observable(''),       // Input UI
    components: ko.observableArray(),     // Open connections
    selected: ko.observable(''),    // Opened/selected tab UI


    // Methods - Actions of server
    connect: function () {
        // Connect
        omerta.chat.socket = io.connect(omerta.chat.server + '/' + omerta.game, {
            'query': 'token=' + omerta.chat.token
        });

        omerta.chat.socket.on('connection', omerta.chat.events.connect);
        // tmp:
        omerta.chat.events.connect();

        // Listen to events
        omerta.chat.socket.on('User.death', omerta.chat.events.game.UserDeath);
        omerta.chat.socket.on('Chat.message', omerta.chat.events.message);
        omerta.chat.socket.on('Chat.channel', omerta.chat.events.presence);
    },
    disconnect: function () {
        if (!omerta.chat.connection) return;
        omerta.chat.socket.disconnect();
    },
    // Methods - Actions of user
    join: function (room, minimized) {

        var bIsJoined = omerta.chat.data.find(room);
        if (bIsJoined) {
            return true;
        }

        // Create the room
        omerta.chat.data.components.push(new omerta.chat.model.Room(room));
        // Make it selected
        if (!minimized) omerta.chat.data.selected(room);
    },
    part: function (room) {

        var components = omerta.chat.data.components();

        if (components.length === 0) {
            return;
        }

        var key = 0;
        for (key in components) {
            if (components[key].getName() === room) {
                /*omerta.chat.connection.muc.leave(roomJid, omerta.chat.nick, function (data) {
                }, "Closed web client");
                setTimeout(function () {
                    omerta.chat.data.components.remove(function (item) {
                        return item.getJid() == roomJid;
                    });
                }, 500);
                break;
                */
            }
        }

    },
    sendGeneral: function () {
        var message =  $('#omerta_chat_input_g').val();
        /* Prevent empty messages to be submited */
        if (message.length === 0) {
            return null;
        }

        if (omerta.chat.utils.hasUrls(message)) {
            alert('Message must not contain URLs');
            return false;
        }

        // Fix the mentions syntax
        message = message.replace(/\@\[([^\]]+)\][^\s]*/g,'@$1');

        // Send to this jid
        omerta.server.query('POST', './?module=Chat&action=send', {
            room: 'omerta.general',
            message: message
        }, function (response) {
            var data = response.data;
            if (data.error) {
                omerta.chat.addError('Error: ' + data.error, true);
            }
        }, function () {
            omerta.chat.addError('Unable to send message', true);
        });

        // Clear input
        //omerta.chat.data.input('');
        $('#omerta_chat_input_g').val('');
    },
    send: function () {
        var message =  $('#omerta_chat_input').val();
        /* Prevent empty messages to be submited */
        if (message.length === 0) {
            return null;
        }

        if (omerta.chat.utils.hasUrls(message)) {
            alert('Message must not contain URLs');
            return false;
        }

        // Fix the mentions syntax
        message = message.replace(/\@\[([^\]]+)\][^\s]*/g,'@$1');

        // Send to this jid
        omerta.server.query('POST', './?module=Chat&action=send', {
            room: omerta.chat.data.selected(),
            message: message
        }, function (response) {
            var data = response.data;
            if (data.error) {
                omerta.chat.addError('Error: ' + data.error);
            }
        }, function () {
            omerta.chat.addError('Unable to send message');
        });

        // Clear input
        //omerta.chat.data.input('');
        $('#omerta_chat_input').val('');

    },

    /**
     * Controls of the chat
     * @param jid
     * @returns {*}
     */
    controls: {
        scrollBot: function () {

        },
        userlist: function (ko, event) {

            if (typeof(event) === 'object') {
                event.preventDefault();
            }


            var $userList = $('#userlist'),
                $userContainer = $('.chat-user-container');

            if ($userList.is(':animated')) {
                $userList.stop();
            }

            if ($userList.is(':visible')) {

                $(event.currentTarget || event.delegateTarget).css('color', '');
                $userContainer.hide();
                $("#userlist").show('slow').animate({top: "-73px"}, function () {
                    $(this).hide();
                });
            } else {
                $(event.currentTarget || event.delegateTarget).css('color', 'white');
                $("#userlist").show('slow').animate({top: "27px"}, function () {
                    $userContainer.fadeIn(400, function () {
                        $("#userlist .chat-user-container > .chat-active-users:visible").perfectScrollbar('update');
                    });
                });
            }
            return true;
        },
        minimize: function (ko, event) {

            if (typeof(event) === 'object') {
                event.preventDefault();
            }

            var minHelper = function () {
                var $omertaChat = $("#omerta_chat");

                $omertaChat.animate({height: '18px'});
                omerta.chat.windowStatus(omerta.chat.config.window.STATUS_MINIMIZED);

                omerta.chat.config.window.HEIGHT = $omertaChat.height();
            };

            var $userList = $("#userlist");

            if ($userList.is(':visible')) {
                //Hide the userlist first
                $('.chat-user-container').hide();
                $userList.show('slow').animate({left: "0px", width: "0px"}, function () {
                    $(this).hide();
                    //Finally minimize
                    minHelper();
                    omerta.chat.config.window.VISIBLE_USERLIST = true;
                });
            } else {
                minHelper();
                omerta.chat.config.window.VISIBLE_USERLIST = false;
            }

        },
        maximize: function (ko, event) {

            if (typeof(event) === 'object') {
                event.preventDefault();
            }

            var $omertaChat = $("#omerta_chat");


            $omertaChat.animate({height: omerta.chat.config.window.HEIGHT + 'px'}, function () {
                if (omerta.chat.config.window.VISIBLE_USERLIST) {
                    omerta.chat.data.controls.userlist(ko, event);
                }
            });

            omerta.chat.windowStatus(omerta.chat.config.window.STATUS_MAXIMIZED);

            omerta.chat.config.window.HEIGHT = $omertaChat.height();
        }
    },
    /**
     * Find a component with this name
     * @param name
     * @returns Component
     */
    find: function (name) {
        var comps = omerta.chat.data.components();
        var i = 0;
        for (i in comps) {
            if (comps[i].getName() === name)
                return comps[i];
        }
    }
};

/**
 * Get selectable tabs
 */

omerta.chat.data.getSelectableComponents = ko.computed(function () {
    return ko.utils.arrayFilter(this.components(), function (component) {
        return component.getName() !== 'omerta.general';
    });
}, omerta.chat.data);

omerta.chat.data.getGeneralChat = ko.computed(function () {
    return ko.utils.arrayFilter(this.components(), function (component) {
        return component.getName() == 'omerta.general';
    });
}, omerta.chat.data);

omerta.chat.data.getGeneralChatTopic = ko.computed(function () {
    var component = this.find('omerta.general');
    if (component) {
        return component.getTopic();
    }
    return '';
}, omerta.chat.data);

/**
 * Get selected tab messages
 */
omerta.chat.data.getActiveTab = function () {
    // Empty if still loading
    if (omerta.chat.data.selected() === "") return false;
    // Return it
    return omerta.chat.data.find(omerta.chat.data.selected());
};
omerta.chat.data.getActiveTabMessages = function () {
    // Empty if still loading
    if (omerta.chat.data.selected() === "") return [];
    // Return it
    return omerta.chat.data.find(omerta.chat.data.selected()).getMessages();
};

omerta.chat.data.getActiveTabUsers = function () {
    // Empty if still loading
    if (omerta.chat.data.selected() === "") return [];
    // Return it
    return omerta.chat.data.find(omerta.chat.data.selected()).getUsers();
};

omerta.chat.data.getActiveTopic = function () {
    // Empty if still loading
    if (omerta.chat.data.selected() === "") return [];
    // Return it
    return omerta.chat.data.find(omerta.chat.data.selected()).getTopic();
};

/**
 * Loading showing in UI?
 */
omerta.chat.loading = ko.computed(function () {
    return this.data.status() == 0;
}, omerta.chat);

omerta.chat.show.subscribe(function (isChatVisible) {
    if (isChatVisible) {
        omerta.chat.data.join(omerta.chat.utils.getConferenceUrl(omerta.chat.config.channel.CHAN_GENERAL));
        omerta.chat.utils.scrollChat();
//    omerta.chat.windowStatus(omerta.chat.config.window.STATUS_MAXIMIZED);
        omerta.chat.data.controls.maximize();
    } else {
        omerta.chat.data.part(omerta.chat.utils.getConferenceUrl(omerta.chat.config.channel.CHAN_GENERAL));
        omerta.chat.windowStatus(omerta.chat.config.window.STATUS_CLOSED);
    }
});


/**
 * EVENT: Scroll
 * Fix scroll when selected tabs changes
 */
omerta.chat.data.selected.subscribe(function (newRoom) {
    var roomName = newRoom;
    omerta.chat.data.find(roomName).resetUnread();
    omerta.chat.utils.scrollChat(roomName);
    omerta.chat.utils.scrollUser(roomName);
});

/**
 * Set the page title depending by chat mentions
 *
 * @param {number} iMentions
 */
omerta.chat.setPageTitle = function(iMentions) {
    if (typeof(iMentions) === 'undefined') {
        return false;
    }

    if (typeof(omerta.gameTitle) === 'undefined') {
        return false;
    }

    var sMentions = "";

    if (iMentions > 0) {
        sMentions = "("+iMentions+") ";
    }

    var newTitle = sMentions + omerta.gameTitle;
    $("#pageTitle").text(newTitle);
};

/**
 * Change title bar when the user is mentioned
 */
omerta.chat.unreadedMentions.subscribe(function(iMentions) {
    omerta.chat.setPageTitle(iMentions);
});

/**
 * Initialize when dom ready
 */
$(window).on('omerta.Clock.synched', function() {
    // Disconnect bind
    $(window).unload(omerta.chat.data.disconnect);

    // Load chat after game is loaded
    omerta.chat.init();

    // Apply label test
    $('.omerta_chat_input_text').mentionsInput({
        minChars: 2,
        showAvatars: true,
        onDataRequest: function (mode, query, callback) {
            var data = omerta.chat.users || [];

            data = _.filter(data, function (item) {
                return item.name.toLowerCase().indexOf(query.toLowerCase()) > -1
            });

            callback.call(this, data);
        }
    });

    // Textarea but submit on enter except if choosing avatar
    $('#omerta_chat').on('keydown', '.omerta_chat_input_text', function (e) {
        if (e.keyCode == 13) {
            $(this.form).trigger('submit');
            e.preventDefault();
            return false;
        }
    });

    // Restart mentions to 0 when you were mentioned
    $('#omerta_chat').on('focus', '.omerta_chat_input_text', function (e) {
        omerta.chat.unreadedMentions(0);
    });
});
/****************************
 * Sidepanel
 * The nice and new sidepanel
 ****************************/
omerta.widgets.Sidepanel = {

    // Show
    tab: ko.observable('chat'),
    visible: ko.observable(true),

    // Internal db
    db: new omerta.Storage('sidepanel'),

    // Actions:
    events: {},

    /**
     * User interface
     * Handlers for UI
     */
    UI: {
        events: {}
    }

};
/**
 * Prepare sidepanel widget
 */
omerta.widgets.Sidepanel.load = function () {
    var bVisible = this.db.get('visible');

    if (!bVisible) {
        omerta.widgets.Sidepanel.UI.events.toggle();
    }

    this.db.onLocalStorage(omerta.widgets.Sidepanel.onLocalStorage);
};

/**
 * Toggle: Allow user to hide/show the Sidepanel
 */
omerta.widgets.Sidepanel.UI.getToggleClass = ko.computed(function () {
    // Class name for toggler
    return this.visible() ? 'closed' : 'open';

}, omerta.widgets.Sidepanel);

/**
 * Toggle sidepanel with nice animations
 */
omerta.widgets.Sidepanel.UI.events.toggle = function () {

    var $oSidePanel = $("#omerta_sidepanel"),
        $oWrapper = $("#wrapper"), // main wrapper
        bVisible = omerta.widgets.Sidepanel.visible(), // Is the sidepanel visible ?
        iHeight = $oSidePanel.outerWidth(true); // Get sidepanel height

    // Are we in "small desktop" version?
    var bSmallDesktop = $oSidePanel.css('opacity') < 1;

    // Reset CSS (media query effect)
    var fnResetCSS = function () {
        $oSidePanel.css('right', '');
    };

    // If the first argument is a boolean, then we should override the real visible value
    var bOverrideHidden = (typeof(arguments[0]) === 'boolean') ? arguments[0] : false;

    bVisible = bOverrideHidden ? bOverrideHidden : bVisible;

    if (bVisible) {
        // Hide chat

        // Show the little bar
        iHeight -= 4;
        $oSidePanel.animate({right: (iHeight * -1) + 'px'}, {duration: 200, queue: false});

        if (!bSmallDesktop) {
            $oWrapper.animate({right: '0px'}, {duration: 200, queue: false});
        }

    } else {
        // Show it

        $oSidePanel.animate({right: '0px'}, {duration: 200, queue: false, complete: fnResetCSS});

        if (!bSmallDesktop) {
            $oWrapper.animate({right: iHeight + 'px'}, {duration: 200, queue: false, complete: fnResetCSS});
        }
    }

    var bToggledStatus = !bVisible;

    // Store visible status into database
    omerta.widgets.Sidepanel.db.set('visible', bToggledStatus);

    // Toggle it
    omerta.widgets.Sidepanel.visible(bToggledStatus);

    return true;
};


/**
 * Event fired after local storage was modified, this is used to synchronize opened tabs.
 * @param event
 */
omerta.widgets.Sidepanel.onLocalStorage = function (event) {

    if (event.newValue !== 'undefined') {

        switch (event.key) {
            case omerta.widgets.Sidepanel.db.localStorageGetKey('visible'):

                var bVisible = (event.newValue == "true") ? true : false;
                omerta.widgets.Sidepanel.UI.events.toggle(!bVisible);

            break;
        }
    }
}
/**
 * Forum module
 * Read threads
 */
omerta.widgets.EOG = _.extend(omerta.core.Widget, {

    showWidget: ko.observable(false),
    showWinner: ko.observable(false),
    showLoader: ko.observable(false),
    data: ko.observable({city: -1, cityname: '', family: 0, familyname: '', percentage: 0, status: '', reset_since: 0, timeend: 0}),

    element: null,
    clock: null,
    mobileClock: null,

    // TODO: temporary with old kernel
    init: function (data) {

        if (typeof(data) !== 'object') {
            this.showWidget(false);
            return;
        }

        this.element = $('#countdown');

        data.timeleft = parseInt(data.timeleft) || 0;
        data.reset_since = parseInt(data.reset_since) || 0;

        if (data.status === 'dead' && data.reset_since == 0) {
            this.showWidget(false);
            return;
        }

        if (data.status === 'alive' && data.percentage < 100 && data.timeleft == 0) {
            this.showWidget(false);
            return;
        }

        var languages = ['en', 'ru', 'ua', 'de', 'fr', 'sp', 'it', 'nl', 'no', 'pt', 'tr'];
        var user_lang = data.language || 'en';

        if (languages.indexOf(user_lang) < 0) {
            user_lang = 'en';
        }

        var displayDays = false,
            dispalySeconds = true;

        if (data.timeleft > 86400) {
            displayDays = 2;
            dispalySeconds = false;
        }

        if (data.timeleft <= 0) {
            data.timeleft = 0;
            this.showWinner(true);
            this.showLoader(false);
        }

        if (data.timeleft > 0) {
            var clockOptions = {
                captionSize: 10,
                countdown: true,
                displayCaptions: true,
                displayDays: displayDays,
                displaySeconds: dispalySeconds,
                fontSize: 26,
                seconds: data.timeleft,
                theme: 'omerta',
                lang: user_lang,
                callback: function() {
                    omerta.widgets.EOG.showLoader(true);
                    omerta.widgets.EOG.showWinner(false);
                }
            };

            var mobileClockOptions = $.extend({}, clockOptions, {
                fontSize: 10,
                theme: 'mobile-omerta',
                topTransition: 25
            });

            this.clock = $('#reset-clock').timeTo(clockOptions);
            this.mobileClock = $('#mobile-reset-clock').timeTo(mobileClockOptions);
        }

        this.data(data);
        this.showWidget(true);

        this.checkMobile();
    },

    roundVersion: function () {
        return omerta.roundVersion();
    },

    enableDetails: function () {
        this.element.stop().animate({top: '0px'}, 'slow');
    },
    disableDetails: function () {
        this.element.stop().animate({top: '-51px'}, 'slow');
    },
    redirectToMap: function () {
        omerta.GUI.container.loadPage('/?module=City&eog_city=true');
    },
    redirectToFamily: function () {
        omerta.GUI.container.loadPage('/family.php?fam=' + this.data().family);
    },
    checkMobile: function() {
        var isVisible = $('#mobile-countdown').is(':visible'),
            $oGameWrapepr = $('#game_wrapper');

        if (isVisible) {
            $oGameWrapepr.addClass('EogGameWrapper');
        } else {
            $oGameWrapepr.removeClass('EogGameWrapper');
        }
    }

});

// Computed functions
omerta.widgets.EOG.getClass = ko.computed(function () {

    if (typeof(omerta.widgets.EOG.data().city) === "undefined") {
        return 'city';
    }

    var city = omerta.widgets.EOG.data().city;

    return 'city cd-' + city;
}, omerta.widgets.EOG);
omerta.widgets.CharacterStats = $.extend({}, omerta.framework.GUI, {
    name: 'character_stats',
    load: function() {


    },

    getContainerClass: ko.computed(function() {
        var selectedTab = omerta.GUI.container.selectedTab(),
            extraClass;

        if (selectedTab.length > 0) {
            extraClass = 'infotab-'+selectedTab;
        } else {
            extraClass = 'infotab-empty-tabs';
        }

        var aClass = [
            'infotab-wrapper',
            extraClass
        ];

        return aClass.join(' ');
    }),

});

omerta.widgets.CharacterStats.config = {

    DISABLED_MODULES: [
        'LegacyForums',
        //'Milestone'
    ]

};
omerta.widgets.CharacterStats.load();

/**
 * Function to validate if we have to show/hide the widget
 */
omerta.widgets.CharacterStats.isVisible = ko.pureComputed(function() {

    var currentModule = omerta.GUI.container.currentModule();
    if (currentModule && currentModule.length > 0) {
        var iContainsDisabled = omerta.widgets.CharacterStats.config.DISABLED_MODULES.indexOf(currentModule);

        if (iContainsDisabled >= 0) {
            return false;
        }
    }

    return true;

});

omerta.widgets.CharacterStats.toggleSlide = function() {
    var $oWrapper = $("#widget_CharacterStats"),
        $oButton = $('#CharacterStats-MobileToggle'),
        $oIcon = $oButton.find('.toggle-icon');

    var status = $oButton.data('status'),
        iconDown = $oIcon.data('icon-status-down'),
        iconUp = $oIcon.data('icon-status-up');

    var sHeight = '38px',
        nextStatus = 'down';
    if (status == 'down') {
        sHeight = '105px';
        nextStatus = 'up';
    }

    $oWrapper.stop(true, false).animate({
        height: sHeight
    }, function() {

        if (status == 'down') {
            $oIcon.removeClass(iconUp).addClass(iconDown);
        } else {
            $oIcon.removeClass(iconDown).addClass(iconUp);
        }

        $oButton.data('status', nextStatus);
    });
};
// Detectives module
omerta.modules.Detectives = {
	
    /**
     * Load
     * First function to run when page is loaded 
     */
    load: function () {
        // Listeners on forms related to Detectives
        $(document).on('submit','form[data-shoot]',function (event) 
		{
		
			var action  = $(this).attr('data-action');
			var form    = $(this).serialize();
			
            
            // Scroll to top
            $("#game_container").animate({scrollTop:0}, 'fast', 'swing', function(){
                
                // Call respective callback
                omerta.modules.Detectives.GUI.form[action](form);

            });
            // Callback

            // No browser!
            event.preventDefault();
            return false;
        });
		
		$(document).on('submit','form[data-backfire]',function (event) 
		{
		
			var action  = $(this).attr('data-action');
			var form    = $(this).serialize();
			
            
            // Scroll to top
            $("#game_container").animate({scrollTop:0}, 'fast', 'swing', function(){
                
                // Call respective callback
                omerta.modules.Detectives.GUI.form[action](form);

            });
            // Callback

            // No browser!
            event.preventDefault();
            return false;
        });
		
		$(document).on('submit','#detectives-search-div',function (event) 
		{
		
			var action  = $(this).attr('data-action');
			var form    = $(this).serialize();
			
            
            // Scroll to top
            $("#game_container").animate({scrollTop:0}, 'fast', 'swing', function(){
                
                // Call respective callback
                omerta.modules.Detectives.GUI.form[action](form);

            });
            // Callback

            // No browser!
            event.preventDefault();
            return false;
        });
		
		$(document).on('click',"[name^='dets']",function (event) 
		{

			var action  = $(this).attr('data-action');
			var post = 'id=' + $(this).attr('data-id') ;
            if (action == "fire") 
			{
				omerta.modules.Detectives.GUI.events[action](post);
				// No browser!


			}
			event.preventDefault();
            return false
        });
		
		$(document).on('keyup',"#detectives-minutes-input",function (event) 
		{
			var minutes = parseInt($(this).val(),10);
			omerta.modules.Detectives.GUI.events['shcost'](minutes);
			// No browser!
			event.preventDefault();
			return false;

        });		
		
		$(document).on('submit',"#detectives-safehouse-form",function (event) 
		{
			var action  = $(this).attr('data-action');
			var form    = $(this).serialize();
            if (action == "safehouse") 
			{
				omerta.modules.Detectives.GUI.form[action](form);



			}
			event.preventDefault();
            return false
        });
		
		$(document).on('click',"#detectives-remove-button",function (event) 
		{

			var action  = $(this).attr('data-action');
			var post = 'sessionToken=' + $(this).attr('data-session');
            if (action == "fireAll") 
			{
				omerta.modules.Detectives.GUI.events[action](post);



			}
            event.preventDefault();
            return false			
        });		
		

    },
	
	GUI: {
	
		events :
		{	
			fire:function(_post)
			{
				$.post('/?module=Detectives&action=fire', _post,  function (data) { var data2 = data.data; omerta.modules.Detectives.GUI.events.fireCB(data2);}, 'json');
			},
			
			fireCB: function(_info)
			{
				var pos   = omerta.modules.Detectives.GUI.form.popupPos();
				
				var msg;
				// Something went wrong
				// Status is mandatory!
				if (_info.status != 'OK')
				{					
					 msg = _info.message;
				// Box
                $.prompt({
                // Message content
                      message:     
					  {
                        title:  'Error',
                        html: msg,
                        position: pos,
						buttons: 
						{ 
                            'OK': 0,
                        }
                      }
                    });
				}
										
				else
				{
					omerta.GUI.container.loadPage('/?module=Detectives&action=display')
				}
			},
			
			fireAll : function(_post)
			{
				$.post('/?module=Detectives&action=fireAll', _post,  function (data) { var data2 = data.data; omerta.modules.Detectives.GUI.events.fireAllCB(data2);}, 'json');
			},
			
			fireAllCB : function(_info)
			{
				var pos   = omerta.modules.Detectives.GUI.form.popupPos();
				
				var msg;
				// Something went wrong
				// Status is mandatory!
				if (_info.status != 'OK')
				{					
					 msg = _info.message;
				// Box
                $.prompt({
                // Message content
                      message:     
					  {
                        title:  'Error',
                        html: msg,
                        position: pos,
						buttons: 
						{ 
                            'OK': 0,
                        }
                      }
                    });
				}
										
				else
				{
					omerta.GUI.container.loadPage('/?module=Detectives&action=display')
				}			
			},
			
			shcost: function(_minutes)
			{
				var cost = $('#detectives-shcost-label');
				var newcost = _minutes*_minutes*100;
				cost.text('$'+((isNaN(newcost)) ? 0 : newcost));
			},
		},
	
		form:
		{
		
			backfire: function(_post)
			{
				$.post('/?module=Detectives&action=backfire', _post,  function (data) { var data2 = data.data; omerta.modules.Detectives.GUI.form.backfireCB(data2);}, 'json');
			},
			
			backfireCB: function(_info)
			{
				var pos   = omerta.modules.Detectives.GUI.form.popupPos();
				var msg = _info.message;
					$.prompt({
					// Message content
						  message:     
						  {
							title:  'Backfire',
							html: msg,
							position: pos,
							buttons: 
							{ 
								'OK': 0,
							}
						  }
						});
			},
			
			hire: function(_post)
			{
			
			},
			
			hireCB: function(_info)
			{
				
				if (_info.status == 'OK')
				{
					var text = $.prompt.getState('Hired');
                    $(text).find('.jqimessage').text(_info.message);
                    $.prompt.goToState('Hired');
					omerta.GUI.container.loadPage('/?module=Detectives&action=display');
				}
				else
				{
					    var text = $.prompt.getState('message');
                        $(text).find('.jqimessage').text(_info.message);
                        $.prompt.goToState('message');

				}
			},
		
			popupPos: function () {
                var pos = { 
                            container: '', 
                            x:      0,  
                            y:      0,  
                            width:  350, 
                            arrow:  0 
                      };
                return pos;
            },
			
			search: function(_post)
			{
				$.post('/?module=Detectives&action=search', _post,  function (data) { var data2 = data.data; omerta.modules.Detectives.GUI.form.searchCB(data2);}, 'json');
			},
			
			searchCB : function(_info)
			{
				var pos   = omerta.modules.Detectives.GUI.form.popupPos();
				
				var msg;
				// Something went wrong
				// Status is mandatory!
				if (_info.status != 'OK')
				{

					msg = _info.message;
					$.prompt({
					// Message content
						  message:     
						  {
							title:  'Error',
							html: msg,
							position: pos,
							buttons: 
							{ 
								'OK': 0,
							}
						  }
						});
				}
				
					// Box
					/**/
				
				else
				{
				
					$.prompt({
                       form:   omerta.plugins.popups.generateForm('Detectives','hire', 
                                                                                // Popup stuff
                                                                                {
                                                                                    title:      'Hire Detectives',
                                                                                    buttons:    { Cancel: 0, Hire: 1 },
                                                                                    pos: { 
                                                                                                    container: '', 
                                                                                                    x:      0, 
                                                                                                    y:      0, 
                                                                                                    width:  350
                                                                                          },
                                                                                    html:       _info.content,
                                                                                    callback:   omerta.modules.Detectives.GUI.form.hireCB
                                                                                }),
                       // Message content
                       message:     {
                                        title:  'Error',
                                        html: '',
                                        buttons: { 
                                            'OK': 0,
                                        },
                                        position: { 
                                            container: '', 
                                            x:      0, 
                                            y:      0, 
                                            width:  350
                                      },
                                    },
									
									
						Hired: { 
										title:  'Hired',
                                        html: '',
                                        buttons: { 
                                            'OK': 0,
                                        },
                                        position: { 
                                            container: '', 
                                            x:      0, 
                                            y:      0, 
                                            width:  350
                                      },
						},
                    });
					
						var totalAmount = $('#totalAmount');
						var detectives = $("input[name^='detectives']");
						var price = _info.price;
						var hours = $("select[name^='hours']");
						var allCityHours = $('#allCityHours');
						var allCities = $('#allCities');

						function detectiveAmount()
						{
							var total = 0;
							detectives.each( function(index)
							{
								total += parseInt($(this).val() * price * hours.eq(index).val(), 10);
							});
							totalAmount.text(total);
						};	

						function detectiveHours()
						{
							var total = 0;
							hours.each( function(index)
							{
								total += parseInt(detectives.eq(index).val() * price * $(this).val(), 10);
							});
							totalAmount.text(total);		
						};
						
						function allCitiesDets()
						{
							var total = 0;
							detectives.each( function(index)
							{
								detectives.val(allCities.val());
								total += parseInt(allCities.val() * price * hours.eq(index).val(), 10);
							});
							totalAmount.text(total);
						};
	
						function allHours()
						{
							var total = 0;
							hours.each( function(index)
							{
								hours.val(allCityHours.val());
								total += parseInt(allCityHours.val() * price * detectives.eq(index).val(), 10);
							});
							totalAmount.text(total);		
						};						
					

						detectives.change(detectiveAmount);
						hours.change(detectiveHours);
						allCities.change(allCitiesDets);
						allCityHours.change(allHours);
					
				}	
				
				
			},
			
			safehouse: function (_post)
			{
				// Send form
				$.post('/?module=Detectives&action=safehouse', _post,  function (data) { var data2 = data.data; omerta.modules.Detectives.GUI.form.safehouseCB(data2);}, 'json');
				
			},
			
			safehouseCB: function(_info)
			{
				
				// Something went wrong
				// Status is mandatory!
				if (_info.status != 'OK')
				{
					var pos   = omerta.modules.Detectives.GUI.form.popupPos();
					var msg = _info.message;
					 // Box
					$.prompt({
					// Message content
                      message:     
					  {
                        title:  'Safehouse',
                        html: msg,
                        position: pos,
						buttons: 
						{ 
                            'OK': 0,
                        }
                      }
                    });

				}
				
				else
				{
					omerta.GUI.container.loadPage('/bank.php');
				}
													
			},
			
			shoot: function (_post) 
			{
				// Send form
				$.post('/?module=Detectives&action=shoot', _post,  function (data) { var data2 = data.data; omerta.modules.Detectives.GUI.form.shootCB(data2);}, 'json');
                    
			},
			
			shootCB: function(_info)
			{
				
				var pos   = omerta.modules.Detectives.GUI.form.popupPos();
				
				var msg;
				// Something went wrong
				// Status is mandatory!
				if (_info.status != 'OK')
				{					
					 msg = _info.message;
					// Box
					$.prompt({
					// Message content
                      message:     
					  {
                        title:  'Error',
                        html: msg,
                        position: pos,
						buttons: 
						{ 
                            'OK': 0,
                        }
                      }
                    });
					 $('#ver').val('');
					 $('#imgcode').click();
				}
				
				else
				{
					msg = _info.message;
					// Box
					$.prompt({
					// Message content
						  message:     
						  {
							title:  'Outcome',
							html: msg,
							position: pos,
							buttons: 
							{ 
								'OK': 0,
							}
						  }
						});
						omerta.GUI.container.loadPage('/?module=Detectives&action=display');
				}
										
				

			}
		}
	}
   
    
};

// Lackeys module
omerta.modules.Lackeys = {
    // Config
    config:  {
        1:{
           name: "Spats",
           pos : {x: 170,    y: 10,  arrow: 'lt'}   /* popup box position */
        },
        2:{
           name: "Noodles",
           pos : {x: -225,   y: 15,  arrow: 'rt'}   /* popup box position */
        },
        3:{
           name: "O'Rourke",
           pos : {x: -250,    y: 0,   arrow: 'rt'}  /* popup box position */
        },
        4:{
           name: "Freekowtski",
           pos : {x: -250,   y: 10,  arrow: 'rt'}   /* popup box position */
        },
        5:{
           name: "Keaton",
           pos : {x: 150,    y: 5,   arrow: 'lt'}   /* popup box position */
        },
        6:{
           name: "Sluggs",
           pos : {x: 250,    y: 30,  arrow: 'lt'}   /* popup box position */
        }
    },
    
    // Data from user cached
    input: {
        l_credits: 100, l_money: 0 
    },
    // Data from server cached
    data: {
        updating: false /* Waiting update, status called */ 
    }, 
    
    /**
     * Load
     * First function to run when page is loaded 
     */
    load: function () {
        // Listeners on forms related to Lackeys
        $(document).on('submit','form[data-lackey]',function (event) {
            // Which who when?
            var action  = $(this).attr('data-action');
            var lackey  = $(this).attr('data-lackey');
            var form    = $(this).serialize();

            // Scroll to top
            $parentDiv = omerta.GUI.container.elementToScroll;
            $parentDiv.animate({scrollTop:0}, 'fast', 'swing', function(){

                // Call respective callback
                omerta.modules.Lackeys.GUI.form[action](lackey, form);

            });
            // Callback

            // No browser!
            event.preventDefault();
            return false;
        });
        // Listeners on buttons related to Lackeys
        $(document).on('click','input[data-lackey]',function (event) {
            
            var action = $(this).attr('data-action');
            var lackey = $(this).attr('data-lackey');
            
            /**
             * Form buttons
             * Form helpers
             * Select all items 
             */
            
            if (action == "items_selectAll") {
                var status = this.checked;
                $("input[data-lackeyItem]").attr("checked", status);
            }
            /**
             * User actions
             * Add credits
             */
            if (lackey == "user") {
                if (action == "addCredits" || action == "fireAll") {
                    omerta.modules.Lackeys.GUI.form[action]();
                }
            }
            
            /**
             * Lackey actions
             * Hire, Fire, Send money or credits
             */
            else {
                // Hire, Fire, Send
                if (action == "hire" || action == "fire" || action == "send" || action == "buyout") {
                    // Scroll to the center
                    $parentDiv = omerta.GUI.container.elementToScroll;
                    var scrollValue = $parentDiv.scrollTop() + $(this).position().top - $parentDiv.height()/2 + $(this).height()/2;
                    $parentDiv.animate({scrollTop:scrollValue}, 'fast', 'swing', function(){
                        
                        // Call respective callback
                        omerta.modules.Lackeys.GUI.form[action](lackey);

                    });
                }
            }   
            //alert("Lackey #"+ $(this).attr('data-lackey') +" -> "+ $(this).attr('data-action'));
            
        
        });
    },
    /**
     * Update 
     * Update info from server
     */
    update: function (fromCB) {
        // Already waiting info from server
        if (!fromCB)
            if (omerta.modules.Lackeys.data.updating) return;
        
        omerta.modules.Lackeys.data.updating = true;
        
        var extra = "";
        // Private page
        if ($("table[data-info=log][data-lackey]").length == 1) {
            var lackey = $("table[data-info=log][data-lackey]").attr('data-lackey');
 
            // Check which is the last entry (on top, so first)
            var oLast = $("table[data-info=log][data-lackey]").find('tr:first').attr('data-logid');

            // Request
            extra = '&lackey='+ lackey+ '&log='+ oLast;
        }
  
        // Request
        $.getJSON('/?module=Lackeys&action=status' + extra, null, omerta.modules.Lackeys.updateCB)
        
    },
    updateCB: function (_data) {
        // Update it!
        var info = _data.data
        
        // Check changes
        var updated = true;
        for (lackey in info) {
            if (!info[lackey].change)  { updated = false; continue; }
            
            omerta.modules.Lackeys.GUI.events.update(lackey, info[lackey]);
        }
        
        // No changes? 
        // Request again in 5sec
        if (!updated) {
            omerta.timers.lackeys = setTimeout(function() { omerta.modules.Lackeys.update(true) }, 5000);
            return;
        }
        // Allow update to run
        omerta.modules.Lackeys.data.updating = false;
    },
    
    /**
     * GUI
     * Everything related to changes in user interface 
     */
    GUI: {
        /**
         * Events
         * When info retrieved from server (hired, fired, status update)
         */
        events: {
            // Fired
            fired: function(_lackey) {
                omerta.GUI.container.loadPage('/?module=Lackeys&action=tab&type='+ _lackey)
            },
            // Hired
            hired: function(_lackey) {
                // Hide everything that belongs to hired
                $("*[data-lackey="+_lackey+"][data-hired=true]").show();
                // Show everytihng related to fired
                $("*[data-lackey="+_lackey+"][data-hired=false]").hide();
                // I'm not in jail for sure
                omerta.modules.Lackeys.GUI.events.freed(_lackey);
            },
            // Jail
            jail: function(_lackey) {
                // Hide everything that belongs to hired
                $("*[data-lackey="+_lackey+"][data-jail=true]").show();
                // Show everytihng related to fired
                $("*[data-lackey="+_lackey+"][data-jail=false]").hide();
                
            },
            freed: function (_lackey) {
                // Hide everything that belongs to hired
                $("*[data-lackey="+_lackey+"][data-jail=true]").hide();
                // Show everytihng related to fired
                $("*[data-lackey="+_lackey+"][data-jail=false]").show();
            },

            // Update status
            update: function (_lackey, _info) {
                // No info retrieved
                if (!_info) return;
                
                
                // Status
                if (_info.status) 
                    // Fired
                    if (_info.status.fired) return omerta.modules.Lackeys.GUI.events.fired(_lackey); 
                    // In jail
                    if (_info.status.jail)  omerta.modules.Lackeys.GUI.events.jail(_lackey);
                    else                    omerta.modules.Lackeys.GUI.events.freed(_lackey);
                // Stats
                for (i in _info.stats) 
                    $("*[data-lackey="+_lackey+"][data-info="+ i +"]").text(_info.stats[i]);
                    
                // Timers
                for (t in _info.timers) 
                    $("*[data-lackey="+_lackey+"][data-info=time_"+ t +"]").attr('data-timeleft', _info.timers[t]);
                    
                
                    
                // Log received?
                if (_info.log) {
                    var oLog = $("table[data-info=log][data-lackey="+ _lackey +"]");
                    for (lg in _info.log) {
                        // Fetch data
                            var logID       = lg;
                            var logTime     = _info.log[lg].time;
                            var logEntry    = _info.log[lg].entry;

                            // Build entry
                            var sRow =
                                "<tr data-logid=\"" + logID + "\">\n" +
                                "  <td>" + logTime  + "</td>\n" +
                                "  <td>" + logEntry + "</td>\n" +
                                "</tr>";

                            // Add the entry on top
                            oLog.find('tr:first').before(sRow);
                    }
                }
               
            }
        },
        /**
         * Forms
         * Form stuff (popups) 
         */
        form: {
            // Give object with popup position
            popupPos: function (_lackey) {
                // Ignore opsitions for mobile
                if (omerta.framework.GUI.isMobile) {
                    return false;
                }

                // Show popup next to Lackey
                var pos = { 
                            container: '*[data-lackey=' + _lackey+'][data-info="face"]', 
                            x:      omerta.modules.Lackeys.config[_lackey].pos.x, 
                            y:      omerta.modules.Lackeys.config[_lackey].pos.y, 
                            width:  350, 
                            arrow:  omerta.modules.Lackeys.config[_lackey].pos.arrow 
                      };
                return pos;
            },
            /**
             * Add credits
             * Call DC change 
             */
            addCredits: function() {
                // Box
                    $.prompt({
                       form:   omerta.plugins.popups.generateForm('Lackeys','add_credits', 
                                                                                // Popup stuff
                                                                                {
                                                                                    title:      'Add credits',
                                                                                    buttons:    { Cancel: 0, Add: 1 },
                                                                                    html:       'Enter the donate codes you want to trade for action credits here.<br> Only one per line and 2 at once allowed.<br><br>'+
                                                                                                'Each donate code is worth 5000 action credits.<br><br>'+
                                                                                                '<sup><b>Note</b>: Once you have used a donate code for Lackey credits, you cannot use it for DC or DC+ status, or SMS credits</sup><br />'+
                                                                                                '<label><textarea data-number=true rows="5"  style="resize: none; width: 98%;" name="dcs"></textarea></label><br />',
                                                                                    callback:   omerta.modules.Lackeys.GUI.form.addCreditsCB
                                                                                }),
                       // Message content
                       message:     {
                                        title:  'Add credits',
                                        html: '',
                                        buttons: { 
                                            'OK': 0,
                                        },
                                    }
                    });
            },
            
            addCreditsCB: function(_info) {
                // Something went wrong
                // Status is mandatory!
                // Change content
                var text = $.prompt.getState('message');
                $(text).find('.jqimessage').text(_info.message);
                // Next!
                $.prompt.goToState('message');

                // Credits info
                if (_info.credits) {
                  $("#lackey_credits_available").text(_info.credits);
                } else {
                  $("#lackey_credits_available").text('0');
                }
            },

            /**
             * Fire All Lackeys
             */
            fireAll: function() {
                // Box
                $.prompt({
                    form:   omerta.plugins.popups.generateForm('Lackeys','fire_all',
                        // Popup stuff
                        {
                            title:      'Fire All Lackeys?',
                            buttons:    { Cancel: 0, 'Fire All': 1 },
                            html:       'Are you sure you want to fire all lackeys?<br><br>',
                            callback:   omerta.modules.Lackeys.GUI.form.fireAllCB
                        }),
                    // Message content
                    message:     {
                        title:  'Fire All',
                        html: '',
                        buttons: {
                            'OK': 0,
                        },
                    }
                });
            },

            fireAllCB: function(_info) {
                // Something went wrong
                // Status is mandatory!
                // Change content
                var text = $.prompt.getState('message');
                $(text).find('.jqimessage').text('You fired ' + _info.count + ' Lackeys');
                // Next!
                $.prompt.goToState('message');

                // Credits info
                if (_info.credits) {
                    $("#lackey_credits_available").text(_info.credits);
                } else {
                    $("#lackey_credits_available").text('0');
                }
            },

            /**
             * Hire
             * Hire lackey on attribute
             */
                hire: function (_lackey) {
                    // Box direction
                    var pos   = omerta.modules.Lackeys.GUI.form.popupPos(_lackey);

                    // Box
                    $.prompt({
                        hello : {   title:  omerta.modules.Lackeys.config[_lackey].name,
                                    html:   'I heard you were looking for me...<br /><br />'+
                                            'Now that you found me... <br />'+
                                            'What do you have to offer?<br />',
                                    buttons: {
                                                Nothing: 0,
                                                Offer: 1
                                             },
                                    position: pos,
                                    focus: 1,
                                    submit:function(e,v,m,f){
                                        // Not cancelled
                                        if (v == 1) {
                                           $.prompt.goToState('form');

                                           e.preventDefault();
                                           return false;
                                        }
                                    }
                                 },
                       // Generate form
                       form:   omerta.plugins.popups.generateForm('Lackeys','hire',
                                                                                // Popup stuff
                                                                                {
                                                                                    title:      'Your offer for '+ omerta.modules.Lackeys.config[_lackey].name,
                                                                                    buttons:    { Cancel: 0, Hire: 1 },
                                                                                    html:       'So... You want to hire me? What is your offer?<br />'+
                                                                                                '<label><span style="width: 125px; float: left; clear: both;">Credits</span> <input size="4"     value="'+ omerta.modules.Lackeys.input.l_credits +'"    type="text" data-number=true name="l_credits" value=""></label><br />'+
                                                                                                '<label><span style="width: 115px; float: left; clear: both;">Money</span>   $ <input size="10"  value="'+ omerta.modules.Lackeys.input.l_money +'"      type="text" data-number=true name="l_money"   value=""></label><br />',
                                                                                    pos:        pos,
                                                                                    callback:   omerta.modules.Lackeys.GUI.form.hireCB
                                                                                },
                                                                                // Request vars
                                                                                {lackey: _lackey}),
                       // Form: success
                       formSuccess: {
                                        title:  omerta.modules.Lackeys.config[_lackey].name,
                                        html:   'Hey there, Boss!<br />'+
                                                'I\'m starting to work right now.<br /><br>'+
                                                '<sub>(To change '+ omerta.modules.Lackeys.config[_lackey].name +' settings, navigate on menu: Lackeys)</sub><br />',
                                        buttons: {
                                                    'OK': 0,
                                                 },
                                        position: pos
                                    },
                       // Message content
                       message:     {
                                        title:  omerta.modules.Lackeys.config[_lackey].name,
                                        html: '',
                                        position: pos,
                                        buttons: {
                                            'OK': 0,
                                        }
                                    }
                    });
                },

                // Hire callback
                hireCB: function (_info) {
                    // Something went wrong
                    // Status is mandatory!
                    if (_info.status != 'OK') {
                        // Change content
                        var text = $.prompt.getState('message');
                        $(text).find('.jqimessage').text(_info.message);
                        // Next!
                        $.prompt.goToState('message');

                    }
                    // All good, next state
                    else if (_info.status == "OK") {
                        $.prompt.goToState('formSuccess');
                        // Cache last input
                        omerta.modules.Lackeys.input.l_credits  = _info.input.l_credits;
                        omerta.modules.Lackeys.input.l_money    = _info.input.l_money;

                        // Update stats
                        omerta.modules.Lackeys.GUI.events.update(_info.lackey, _info);
                        // Call HIRED event
                        omerta.modules.Lackeys.GUI.events.hired(_info.lackey);
                    }

                },

            /**
             * EO HIRE
             */

            /**
             * Fire
             * Confirm before fire
             */
                fire: function (_lackey) {
                    // Box direction
                    var pos   = omerta.modules.Lackeys.GUI.form.popupPos(_lackey);

                    // Box
                    $.prompt({
                       form: omerta.plugins.popups.generateForm('Lackeys','fire',
                                                                                // Popup stuff
                                                                                {
                                                                                    title:      'Fire '+ omerta.modules.Lackeys.config[_lackey].name,
                                                                                    html:   'Are you sure you want to fire me, Boss?',
                                                                                    buttons: {
                                                                                                No: 0,
                                                                                                Yes: 1
                                                                                             },
                                                                                    pos:        pos,
                                                                                    callback:   omerta.modules.Lackeys.GUI.form.fireCB
                                                                                },
                                                                                // Request vars
                                                                                {lackey: _lackey}),
                       // Message content
                       message:     {
                                        title:  omerta.modules.Lackeys.config[_lackey].name,
                                        html: '',
                                        position: pos,
                                        buttons: {
                                            'OK': 0,
                                        }
                                    }
                    });
                },

                // Fire callback
                fireCB: function (_info) {

                    // Something went wrong
                    // Status is mandatory!
                    if (_info.status != 'OK') {
                        // Change content
                        var text = $.prompt.getState('message');
                        $(text).find('.jqimessage').text(_info.message);
                        // Next!
                        $.prompt.goToState('message');

                    }
                    // All good, next state
                    else if (_info.status == "OK") {
                        $.prompt.close();
                        omerta.modules.Lackeys.GUI.events.fired(_info.lackey);
                    }

                },

            /**
             * EO FIRE
             */

            /**
             * SETTINGS
             * Callback after receiving settings
             */
                settings: function (_lackey, _post) {
                    // Send form
                    $.post('/?module=Lackeys&action=save_settings', _post, function (data) { var data2 = data.data; omerta.modules.Lackeys.GUI.form.settingsCB(_lackey, data2); }, 'json');

                },

                // Fire callback
                settingsCB: function (_lackey, _info) {
                    // Box direction
                    var pos   = omerta.modules.Lackeys.GUI.form.popupPos(_lackey);
                        // Fix width
                        pos.width = 150;
                        if (pos.x < 0) pos.x += 150;
                    var msg;
                    // Something went wrong
                    // Status is mandatory!
                    if (_info.status != 'OK')
                        msg = _info.message;
                    // All good, next state
                    else if (_info.status == "OK") {
                        msg = "Got it, Boss!"
                    }

                    // Box
                    $.prompt({
                       // Message content
                       message:     {
                                        title:  omerta.modules.Lackeys.config[_lackey].name,
                                        html: msg,
                                        position: pos,
                                        buttons: {
                                            'OK': 0,
                                        }
                                    }
                    });
                },

            /**
             * EO SETTINGS
             */
             /**
             * Transfer cars
             * Callback for cars transfer
             */
                transferCars: function (_lackey, _post) {

                   // Get selected cars
                    var sCars = new Array();
                    $("input[name=items_selected]:checked").each(function() { sCars.push($(this).val()) });

                    // Call it
                    var _finalPost = "items_selected=" + sCars.join(',');

                    // Send form
                    $.post('/?module=Lackeys&action=transfer_car', _finalPost, function (data) { var data2 = data.data; omerta.modules.Lackeys.GUI.form.transferCarsCB(_lackey, data2); }, 'json');

                },

                // Fire callback
                transferCarsCB: function (_lackey, _info) {
                    // Box direction
                    var pos   = omerta.modules.Lackeys.GUI.form.popupPos(_lackey);

                    var msg;
                    // Something went wrong
                    // Status is mandatory!
                    if (_info.status != 'OK')
                        msg = _info.message;
                    // All good, next state
                    else if (_info.status == "OK") {

                        msg =   "Here they are...<br>"+
                                _info.cars + " new cars in your garage, Boss.";
                        // Hide cars
                        $("input[name=items_selected]:checked").each(function() {
                            $(this).parent().parent().remove();
                        })
                    }

                    // Box
                    $.prompt({
                       // Message content
                       message:     {
                                        title:  omerta.modules.Lackeys.config[_lackey].name,
                                        html: msg,
                                        position: pos,
                                        buttons: {
                                            'OK': 0,
                                        }
                                    }
                    });

                    // Remove them
                },

            /**
             * EO TRANSFER CARS
             */

            /**
             * Send money
             * Send money to lackey
             */
                send: function (_lackey) {
                    // Box direction
                    var pos   = omerta.modules.Lackeys.GUI.form.popupPos(_lackey);

                    // Box
                    $.prompt({
                       form:   omerta.plugins.popups.generateForm('Lackeys','send',
                                                                                // Popup stuff
                                                                                {
                                                                                    title:      'Send stuff to '+ omerta.modules.Lackeys.config[_lackey].name,
                                                                                    buttons:    { Cancel: 0, Send: 1 },
                                                                                    html:       'I might need some investment to start my work, Boss.<br />'+
                                                                                                'Let me know what you have.<br />'+
                                                                                                '<label><span style="width: 125px; float: left; clear: both;">Credits</span> <input size="4"     value="'+ omerta.modules.Lackeys.input.l_credits +'"    type="text" data-number=true name="l_credits" value=""></label><br />'+
                                                                                                '<label><span style="width: 115px; float: left; clear: both;">Money</span>   $ <input size="10"  value="'+ omerta.modules.Lackeys.input.l_money +'"      type="text" data-number=true name="l_money"   value=""></label><br />',
                                                                                    pos:        pos,
                                                                                    callback:   omerta.modules.Lackeys.GUI.form.sendCB
                                                                                },
                                                                                // Request vars
                                                                                {lackey: _lackey}),
                       // Message content
                       message:     {
                                        title:  omerta.modules.Lackeys.config[_lackey].name,
                                        html: '',
                                        position: pos,
                                        buttons: {
                                            'OK': 0,
                                        }
                                    }
                    });
                },

                // Send callback
                sendCB: function (_info) {

                    // Something went wrong
                    // Status is mandatory!
                    if (_info.status != 'OK') {
                        // Change content
                        var text = $.prompt.getState('message');
                        $(text).find('.jqimessage').text(_info.message);
                        // Next!
                        $.prompt.goToState('message');

                    }
                    // All good, next state
                    else if (_info.status == "OK") {
                        $.prompt.close();
                        // Cache last input
                        omerta.modules.Lackeys.input.l_credits  = _info.input.l_credits;
                        omerta.modules.Lackeys.input.l_money    = _info.input.l_money;
                        // Update stuff
                        omerta.modules.Lackeys.GUI.events.update(_info.lackey, _info);
                    }

                },

            /**
             * EO Send
             */
            /**
             * BUYOUT
             * Confirm before buyout
             */
                buyout: function (_lackey) {
                    // Box direction
                    var pos   = omerta.modules.Lackeys.GUI.form.popupPos(_lackey);

                    var price = "$" + $("span[data-lackey="+ _lackey +"][data-info='buyout']").text();
                    // Box
                    $.prompt({
                       form: omerta.plugins.popups.generateForm('Lackeys','buyout',
                                                                                // Popup stuff
                                                                                {
                                                                                    title:      'Buy '+ omerta.modules.Lackeys.config[_lackey].name +' out of jail',
                                                                                    html:       'This will cost you '+ price +'<br />'+
                                                                                                'Are you sure you want to buy me out, Boss?',
                                                                                    buttons: {
                                                                                                No: 0,
                                                                                                Yes: 1
                                                                                             },
                                                                                    pos:        pos,
                                                                                    callback:   omerta.modules.Lackeys.GUI.form.buyoutCB
                                                                                },
                                                                                // Request vars
                                                                                {lackey: _lackey}),
                       // Message content
                       message:     {
                                        title:  omerta.modules.Lackeys.config[_lackey].name,
                                        html: '',
                                        position: pos,
                                        buttons: {
                                            'OK': 0,
                                        }
                                    }
                    });
                },

                // Fire callback
                buyoutCB: function (_info) {

                    // Something went wrong
                    // Status is mandatory!
                    if (_info.status != 'OK') {
                        // Change content
                        var text = $.prompt.getState('message');
                        $(text).find('.jqimessage').text(_info.message);
                        // Next!
                        $.prompt.goToState('message');
                        
                    }
                    // All good, next state
                    else if (_info.status == "OK") {
                        $.prompt.close();
                        omerta.modules.Lackeys.GUI.events.update(_info.lackey, _info);
                    }
                    
                },
            
            /**
             * EO BUYOUT 
             */
            
            
        }
    }
    
};

// Spots module
omerta.modules.Spots = {
    
    /**
     * Load
     * First function to run when page is loaded 
     */
    load: function () {

        // Listeners on buttons related to Spots
        
        $(document).on('click','button[data-spotInfo]',function (event) {
            
            var action 	= $(this).attr('data-spotInfo');
            var spot 	= $(this).attr('data-spotid');
            
            /**
             * Spot actions
             * Buy button click
             */
                if 		(action == "buy")	omerta.modules.Spots.GUI.square.buy(spot);
                else if (action == "raid")	omerta.GUI.container.loadPage('/index.php?module=Spots');
                else if (action == "toggle")    omerta.GUI.container.loadPage('/index.php?module=City&action=toggle&id='+spot);
                
        });
        
        $(document).on('click','div[data-spot]',function (event) {
            
            var spot = $(this).attr('data-spot');
            
            /**
             * Spot actions
             * On-square click
             */
            	// Call respective callback
                omerta.modules.Spots.GUI.square.info(spot);
                
        });
    },
    
    /**
     * GUI
     * Everything related to changes in user interface 
     */
    GUI: {
        /**
         * Events
         * When info retrieved from server (hired, fired, status update)
         */
        events: {
           
        },
        /**
         * Forms
         * Form stuff (popups) 
         */
        square: {
            /**
             * Info credits
             * Call DC change 
             */
            info: function(_id) {
            	
            	var _spot = omerta.spot[_id];
            	if (!_spot) return;
                var _time = omerta.Clock.getTime()/1000;
                _spot.raid_nextTime = _spot.raid_next - _time;

                $accommodationscontainer = $('#spotAccommodations');
                $accommodationscontainer.html('').hide();

            	// Spot info
            	$("*[data-spotInfo='spot_position']").text(_spot.pos_y + _spot.pos_x);
            	$("*[data-spotInfo='spot_type']").text(_spot.type);
            	$("*[data-spotInfo='spot_name']").text(_spot.spotName);
            	
            	$("*[data-spotInfo='raid_protection']").find(".percent").next().css('width', _spot.raid_protection + "%");
            	$("*[data-spotInfo='raid_protection']").find(".percent").text( _spot.raid_protection + "%");
            	
            	
            	$("*[data-spotInfo='buy'], *[data-spotInfo='toggle']").attr('data-spotid', _id);
            	// Image
            	if (_spot.raid_icon) {
					$("*[data-spotInfo='spot_icon']").show().attr('src', '/assets/images/gfx/maps/icons/'+ _spot.raid_icon +'.png');
				} else {
					$("*[data-spotInfo='spot_icon']").hide();
				}

            	// Owner info
            	$("*[data-spotInfo='owner_name']").text(_spot.ownerName);
            	$("*[data-spotInfo='owner_rank']").text(_spot.ownerRank);
            	$("*[data-spotInfo='owner_family']").text(_spot.ownerFamily);
            	
            	// Owner info links
            	$("a[data-spotInfo='owner_family']").attr('href', 	'/family.php?fam=' + _spot.family);
            	$("a[data-spotInfo='owner_name']").attr('href',		'/user.php?idn=' +  _spot.owner);

                $housesContainer = $('#hspot-'+_id+'');
                if ($housesContainer.size() > 0) {
                    $accommodationscontainer.html($housesContainer.html()).show();
                }

            	// Raid info
            	// Closed?
            	if (_spot.closed != "") {
            		// Profit
            		$("*[data-spotInfo='spot_profit']").css('color','red');
            		$("*[data-spotInfo='spot_profit']").text(_spot.closed=="BR"?"Bankrupt":"Out of business");
            		// Protection
            		$("*[data-spotInfo='raid_protection']").find(".progressbar").hide();
            		// Next raid
            		$("*[data-spotInfo='raid_next']").attr('data-timeleft', -1);
            		$("*[data-spotInfo='raid_next']").text("-");
            		
            	}
            	else {
            		$("*[data-spotInfo='raid_protection']").find(".progressbar").show();
            		
	            	$("*[data-spotInfo='spot_profit']").text("$ " + _spot.profitFormat);
	            	if (_spot.spot_profit > 0) 
	            		$("*[data-spotInfo='spot_profit']").css('color','green');
	            	else if (_spot.spot_profit == 0)
	            		$("*[data-spotInfo='spot_profit']").css('color','black');
	            	else
	            		$("*[data-spotInfo='spot_profit']").css('color','red');
	            	
		            	// Next raid
		            	if (_spot.raid_nextTime > 0)
		            		$("*[data-spotInfo='raid_next']").attr("data-timeleft", _spot.raid_nextTime);
		            	else
		            		$("*[data-spotInfo='raid_next']").attr("data-timeleft", 0).text('Now');
            	}
            	
	            // Can buy
            	if (_spot.can_buy) 
            		$("*[data-spotInfo='buy']").show();
            	else
            		$("*[data-spotInfo='buy']").hide();
            		
            	// Can buy
            	if (_spot.can_raid) 
            		$("*[data-spotInfo='raid']").show();
            	else
            		$("*[data-spotInfo='raid']").hide();
            	
                //Can toggle
                if (_spot.cane === "1")
                    $("*[data-spotCane='toggle']").show();
                else
                    $("*[data-spotCane='toggle']").hide();
                
            	// Remove info and show details
            	$("#spot_welcome").fadeOut('fast', function() { $("#spot_details").fadeIn('fast'); });
            	
                   
            },
            
            /*
             * Buy a spot
             */
            buy: function (_id) {
            	omerta.GUI.container.loadPage('/index.php?module=Family&action=create&familySpot='+ _id);
            }
        }
    }
    
};

omerta.modules.User = {
    load: function() {

    },
    UserfileUpload: function(form, action_url, div_id) {
        // Create the iframe...
        var iframe = document.createElement("iframe");
        iframe.setAttribute("id", "upload_iframe");
        iframe.setAttribute("name", "upload_iframe");
        iframe.setAttribute("width", "0");
        iframe.setAttribute("height", "0");
        iframe.setAttribute("border", "0");
        iframe.setAttribute("style", "width: 0; height: 0; border: none;");

        // Add to document...
        form.parentNode.appendChild(iframe);
        window.frames['upload_iframe'].name = "upload_iframe";

        iframeId = document.getElementById("upload_iframe");

        // Add event...
        var eventHandler = function() {

            if (iframeId.detachEvent)
                iframeId.detachEvent("onload", eventHandler);
            else
                iframeId.removeEventListener("load", eventHandler, false);

            // Message from server...
            if (iframeId.contentDocument) {
                content = iframeId.contentDocument.body.innerHTML;
            } else if (iframeId.contentWindow) {
                content = iframeId.contentWindow.document.body.innerHTML;
            } else if (iframeId.document) {
                content = iframeId.document.body.innerHTML;
            }

            document.getElementById(div_id).innerHTML = content;

            // Del the iframe...
            setTimeout('iframeId.parentNode.removeChild(iframeId)', 250);
        }

        if (iframeId.addEventListener)
            iframeId.addEventListener("load", eventHandler, true);
        if (iframeId.attachEvent)
            iframeId.attachEvent("onload", eventHandler);

        // Set properties of form...
        form.setAttribute("target", "upload_iframe");
        form.setAttribute("action", action_url);
        form.setAttribute("method", "post");
        form.setAttribute("enctype", "multipart/form-data");
        form.setAttribute("encoding", "multipart/form-data");

        // Submit the form...

        $(form).on('submit', function(evt) {
            evt.preventDefault();
        });

        form.submit();

        document.getElementById(div_id).innerHTML = "Uploading...";
    },
    CheckLen: function(Target) {
        var maxlength = $(Target).data('maxlength');
        var StrLen = Target.value.length;
        if (StrLen == 1 && Target.value.substring(0, 1) == " ") {
            Target.value = "";
            StrLen = 0;
        }
        if (StrLen > maxlength) {
            Target.value = Target.value.substring(0, maxlength);
            CharsLeft = 0;
        }
        else {
            CharsLeft = maxlength - StrLen;
        }
        document.quoteform.Charleft.value = CharsLeft;
    }

};
/**
 * @file UI handler for cities
 * @author Omerta Game Ltd <support@omertagame.co.uk>
 * @module City
 */

omerta.modules.City = $.extend({}, omerta.core.Module, {
	TAB_FAM: 'families',
	TAB_SPOT: 'spot',

	//Mapped spots, this is an array omerta.modules.City.model.Spot
	spots: ko.observableArray(),
	//Mapped spots, this is an array omerta.modules.City.model.Family
	top_families: ko.observableArray(),
	families: ko.observableArray(),
	
	houses: ko.observable(),
	visibleSpotContent: ko.observable('spot'),
	
	//City name for map
	city_name: ko.observable(),
	//The spot which was selected when clicked into the map
	selectedSpot: ko.observable(),
	/**
	 * This was the old load function, for now is unused
	 * 
	 * @returns null
	 */
	load: function() {
	},
	/**
	 * This method is used to process and store the data into this module
	 * 
	 * @returns boolean
	 * 
	 * @throws Exception if some parameter is missing
	 */
	prepareData: function() {
		
		//Reset previous values			
		this.selectedSpot(null);
		omerta.GUI.container.selectedTab('families');
		this.visibleSpotContent('spot');
		this.houses({});
		this.top_families([]);
		this.families([]);
		this.spots([]);
		
		//Initialize the city spots
		if (this.__initSpots(this.data.spots) === false) {
			throw "Empty spots";
		}

		//Load all families
		if (this.__initFamilies(this.data.families) === false) {
			throw "Empty Families";
		}
		
		//Loaded houses		
		this.__initHouses(this.data.houses);

		this.city_name(this.data.city_name);
		
		
		//Subscribe to the spot which was selected
		this.selectedSpot.subscribe(this.renderSelectedSpot);

        //Load game intro
        this.__initGameIntro(this.data.game_intro);

		//clean the data to don't use a lot of memory
		delete this.data;

	},
	__initSpots: function(spots) {

		if (_.isArray(spots) === false && _.isObject(spots) === false) {
			return false;
		}
		
		if (_.isEmpty(spots)) {
			return true;
		}

		this.spots([]); //Clear the spots

		var newItems = ko.utils.arrayMap(spots, function(item, key) {
			item.key = key;
			return new omerta.modules.City.model.Spot(item);
		});

		this.spots.push.apply(this.spots, newItems);

		return true;
	},
	__initFamilies: function(families) {
		
		if (_.isArray(families) === false && _.isObject(families) === false) {
			return false;
		}
		
		if (_.isEmpty(families)) {
			return true;
		}

		this.families([]); //Clear the families
		this.top_families([]); //Clear the families

		var ifam = 0;
		for (ifam in families) {
			var oFam = new omerta.modules.City.model.Family(families[ifam]);

			if (ifam < 3) {
				this.top_families.push(oFam);
			} else {
				this.families.push(oFam);
			}
		}

		return true;
	},
	__initHouses: function(houses) {
		if (_.isArray(houses) === false && _.isObject(houses) === false) {
			return false;
		}
		
		if (_.isEmpty(houses)) {
			return true;
		}

		this.houses([]);
		
		var ispot = 0; //spot key
		var ihouse = 0; //house key
		
		for (ispot in houses) {
			var spotHouses = [];
			for (ihouse in houses[ispot]) {
				spotHouses.push(new omerta.modules.City.model.House(houses[ispot][ihouse]));
			}
			
			houses[ispot] = spotHouses;
		}
		
		this.houses(houses);
		
		return true;
	},

  __initGameIntro: function(introOptions) {

    if (typeof(omerta.modules.GameIntro) === 'undefined') {
      return false;
    }

    if (_.isObject(introOptions) === false) {
      return false;
    }

    if (_.isEmpty(introOptions)) {
      return true;
    }

    if (typeof(GameIntroOptions) !== 'undefined' && typeof(GameIntroOptions.shown) !== 'undefined' && GameIntroOptions.shown === false) {
      return false;
    }

    /**
     * The timeout is because knockout takes a bit to render
     */
    setTimeout(function() {
      var oGameIntro = omerta.modules.GameIntro.display(introOptions);

      if (oGameIntro === false) {
        return false;
      }
      /**
       * Load events like oGameIntro.oncomplete ....
       */

    }, 500);



  },
	/**
	 * After the user click into the map point, we display the content of the spot.
	 * 
	 * @param omerta.modules.City.model.Spot spot
	 * @returns null
	 */
	renderSelectedSpot: function(spot) {
		omerta.GUI.container.selectedTab(omerta.modules.City.TAB_SPOT);
	},
	/**
	 * Returns the current user city
	 * 
	 * @returns String
	 */
	getUserCity: function() {
		var mapCityName = this.city_name();

		if (typeof (mapCityName) === 'undefined' || mapCityName.length === 0) {
			return omerta.character.game.city();
		}

		return mapCityName;
	},
	getLinkFamily: function(famId, famName) {
		var link = '/family.php?fam=' + famId;

		return '<a href="[LINK]">[NAME]</a>'.replace('[LINK]', link).replace('[NAME]', famName);
	},
	getLinkUser: function(ingame) {
		var link = '/user.php?name=' + ingame;

		return '<a href="[LINK]">[INGAME]</a>'.replace('[LINK]', link).replace('[INGAME]', ingame);
	},
	/**
	 * Redirects to the spot creation page
	 * 
	 * @returns {Boolean}
	 */
	buySpot: function() {
		var selectedSpot = this.selectedSpot();
		if (typeof (selectedSpot) === 'undefined') {
			return false;
		}

		omerta.GUI.container.loadPage('/index.php?module=Family&action=create&familySpot=' + selectedSpot.ID());

	},
	toggleSpotInformation: function(model, event) {
		var selectedSpot = this.selectedSpot();
		if (typeof (selectedSpot) === 'undefined') {
			return false;
		}
		
		var selectedContent = model.visibleSpotContent();
		
		if (selectedContent !== 'spot') {
			var currentContent = 'spot';
		} else {
			var currentContent = 'houses';
		}
		
		model.visibleSpotContent(currentContent);
		
	},
	
	calculatePercentage: function(num, amount, roundVal) {
		
		amount = parseInt(amount);
		num = parseInt(num);

		roundVal = Math.abs(parseInt(roundVal)) || 0;

		if (amount === 0) {
			return 0;
		}

		var percentage = (num * 100) / amount;
		return Math.round(percentage, roundVal);
	},
	
	citySpotRaidLink: function(obj) {
		var selectedSpot = this.selectedSpot();
		if (typeof (selectedSpot) === 'undefined') {
			return false;
		}
		
		var $obj = $(obj);
		
		if ($obj.data('loaded-link')) {
			return;
		}
		
		var text = $obj.text();
		$obj.data('loaded-link', true);
		
		var family = parseInt(omerta.character.info.family());
		if (family === 0) {
			return;
		}
		
		$obj.html('<a href="/index.php?module=Spots" class="raidActionLink">'+text+'</a>');
		
	},

	destroy: function () {

		//Mapped spots, this is an array omerta.modules.City.model.Spot
		this.spots = ko.observableArray([]);
		//Mapped spots, this is an array omerta.modules.City.model.Family
		this.top_families = ko.observableArray([]);
		this.families = ko.observableArray([]);

		this.houses = ko.observable(null);
		this.visibleSpotContent = ko.observable('spot');

		//City name for map
		this.city_name = ko.observable('');
		//The spot which was selected when clicked into the map
		this.selectedSpot = ko.observable(null);
	}

});

omerta.modules.City.model.Family = function(data) {
	//Protected variables
	var familyId = parseInt(function() {
		return data.id || 0;
	}());

	var donId = parseInt(function() {
		return data.bossid || 0;
	}());

	//Public variables
	this.name = function() {
		return data.name || '';
	}().toString();
	
	this.color = function() {
		return data.color || '';
	}().toString();
	
	this.worth = parseInt(function() {
		return data.worth || 0;
	}());
	
	this.city = parseInt(function() {
		return data.city || 0;
	}());
	
	this.num_spots = parseInt(function() {
		return data.family_spots || 0;
	}());
	
	this.num_users = parseInt(function() {
		return data.users || 0;
	}());
	
	this.donName = function() {
		return data.boss || '';
	}().toString();
	
	this.imageUrl = function(size) {
		size = size || 'medium';
		
		return '/family_image.php?family=' + familyId.toString()+'&size='+size;
	};
	this.ribbonVisible = function(size) {
		return familyId > 0;
	};
	
	this.ribbonUrl = function(index) {
		
		index = parseInt(index) || 1;
		
		return "/assets/omerta/modules/City/assets/img/ribbon-"+index+".png";
	};
	
	this.getFamilyId = function() {
		return familyId;
	};

	this.getFamilyLink = function() {
		if (familyId <= 0) {
			return this.name;
		}
		
		return omerta.modules.City.getLinkFamily(familyId, this.name);
	};
	
	this.getDonLink = function() {
		if (this.donName === 'Local Gangster') {
			return this.donName;
		}
		
		return omerta.modules.City.getLinkUser(this.donName);
	};
	
	this.getTerritoriesPercentage = function() {
		return omerta.modules.City.calculatePercentage(this.num_spots, omerta.modules.City.spots().length);
	};
	
	

};
omerta.modules.City.model.House = function(data) {

	var urls = function() {
		return data.urls || {};
	}();


	this.owner_name = function() {
		return data.owner_name || 'Local Mob';
	}().toString();

	this.owner_id = parseInt(function() {
		return data.owner_id || 0;
	}());

	this.type = parseInt(function() {
		return data.house_type || 0;
	}());

	this.name = function() {
		return data.name || '';
	}().toString();
	
	this.can_rent = Boolean(function() {
		return data.can_rent || false;
	}());


    this.can_rent_villa = Boolean(function() {
        return data.can_rent_villa || false;
    }());

	this.getOwnerLink = function() {

		var ingame = this.owner_name;
		if (this.owner_id === 0) {
			return ingame;
		}

		return omerta.modules.City.getLinkUser(ingame);
	};
	
	this.getActionLink = function() {
		var sameUser = omerta.character.info.name().toLowerCase() === this.owner_name.toLowerCase();
		
		if (sameUser) {
			return '<a class="house-action h-owned" href="'+urls.mine+'">Owned</a>';
		}
		
		if (this.owner_id > 0) {
			return '<span class="house-action h-occupied">Occupied</span>';
		}
		
		if (this.can_rent === false) {
			return '<span class="house-action h-disabled">Can\'t Rent</span>';
		}

        if (this.can_rent_villa === false && this.type === 100) {
            return '<span class="house-action h-disabled">Limit reached</span>';
        }
		
		return '<a class="house-action h-rent" href="'+urls.rent+'">Rent</a>';
	};

};
omerta.modules.City.model.Spot = function(data) {
	
	var buyable = data.buyable || false;
	var can_buy = data.can_buy || false;
	var can_e = data.can_e || false;
	var cdtc = data.cdtc || '';
	var cid = data.cid || 0;
	var closed = data.closed || '';
	var closed_reason = data.closed_reason || '';
	var closed_times = data.closed_times || 0;
	var color = data.color || "c6c6c6";
	var family = data.family || 0;
	var owner = data.owner || 0;
	var ownerFamily = data.ownerFamily || "Local Mob";
	var ownerName = data.ownerName || "Local Gangster";
	var ownerRank = data.ownerRank || 0;
	var pos_x = data.pos_x || "";
	var pos_y = data.pos_y || "";
	var profitFormat = data.profitFormat || 0;
	var raid_last = data.raid_last || 0;
	var raid_next = data.raid_next || 0;
	var raid_protection = data.raid_protection || 0;
    var next_reset_profit = data.next_reset_profit || 0;
    var next_reset_protection = data.next_reset_protection || 0;
	var spotName = data.spotName || "";
	var spot_profit = data.spot_profit || 0;
	var type = data.type || "HQ";
    var key = data.key || 0;
    var has_gift = data.has_gift || false;

	this.ID = function() {return cid;};
	this.getPosX = function() {return parseInt(pos_x); };
	this.getPosY = function() {return pos_y; };
	this.getSpotType = function() { return type; };
	this.isBuyable = function() { return Boolean(can_buy); };
    this.hasGift = function() { return Boolean(has_gift); };
	this.isClosed = function() { return closed_reason.length !== 0; };

	this.getSpotName = function()   { return spotName.toString(); };
	
	this.getOwnerID = function() { return parseInt(owner); };
	this.getFamilyID = function() { return parseInt(family); };
	this.getOwnerName = function()  { 
		return ownerName.toString(); 
	};
	
	
	this.getOwnerLink = function() {
		
		var ingame = this.getOwnerName();
		if (this.getOwnerID() === 0) {
			return ingame;
		} 
		
		return omerta.modules.City.getLinkUser(ingame);
	};
	
	this.getOwnerRank = function() {
		if (this.getOwnerID() === 0) {
			return 0;
		}
		
		return ownerRank;
	};
	
	this.getFamilyLink = function() {
		var famId = this.getFamilyID();
		if (famId === 0) {
			return this.getFamilyName();
		}
		
		return omerta.modules.City.getLinkFamily(famId, this.getFamilyName());
	};
	
	this.getFamilyName = function() { return ownerFamily.toString(); };
	this.getSpotProfit = function() { 
		
		if (this.isClosed()) {
			return 0;
		}
		
		
		return parseInt(spot_profit); 
	};
	
	this.formatSpotProfit = function() {
		var sp = this.getSpotProfit();
		if (this.isClosed()) {
			return closed_reason === 'BR' ? 'Bankrupt' : 'Out of business';
		}
		
		
		return "$ " + sp.format();
	};
	
	this.getProtection = function() { 
		if (this.isClosed()) {
			return 0;
		}
		
		return raid_protection;
	};
	
	this.colorBarProtection = function() {
		var rap = this.getProtection();
		if (rap <= 0) {
			return 'transparent';
		}
		
		if (rap <= 20) {
			return '#B41313';
		}
		
		if (rap > 20 && rap < 50) {
			return '#C98B19';
		}
		
		return '#588527';
	};
	
	this.getFamilyColor = function() {
		if (family) {
			return '#'+color;
		}
		
		return false;
	};
	
	this.getNextRaid = function() {
        return raid_next;
    };

    this.getNextResetProfit = function () {
        return next_reset_profit;
    };

    this.getNextResetProtection = function () {
        return next_reset_protection;
    };
	
	this.getSpotColor = function() {
		
		if (family) {
			return 'customColor';
		}
		
		if (this.isBuyable() === false) {
			return 'gray';
		}
		
		return 'green';
	};

	this.getClassName = function() {
		var classes = ['hq_box', 'row'+this.getPosY(), 'column'+this.getPosX()];
		
		classes.push(this.getSpotColor());
		
		if (this.isClosed()) {
			classes.push('closed');
		}
		
		if (this.getSpotType() !== 'HQ') {
			classes.push('spotWithImage');
		}

        if (this.hasGift()) {
            classes.push('hasGift');
        }
		
		classes.push('spotType'+this.getSpotType());
		classes.push('spotKey'+key);

		return classes.join(' ');
	};
	
	this.getAccomodations = function() {
		var allHouses = omerta.modules.City.houses();
		
		
		if (_.isObject(allHouses) === false) {
			return [];
		}
		
		if (_.isEmpty(allHouses)) {
			return [];
		}
	
		var spotHouses = allHouses[this.ID()];
		if (_.isUndefined(spotHouses)) {
			return [];
		}
		
		spotHouses.sort(function(a, b) {
			return a.type - b.type;
		}).reverse();
		
		return spotHouses;
		
	};

    this.giftUrl = function() {
        return '/?module=City.Gift&action=claim&city_spot='+this.ID();
    };
	
};

/** Singleton module **/
omerta.modules.Desk = {
  loader: '<div><i class="icon-spinner icon-spin icon-large">&nbsp;</i>&nbsp;Loading ...</div>',
  load: function () {
    $(document).on('change', '#desk-ticket-category', function() {
      omerta.modules.Desk.toggleOptions(this);
    });
  },
  loadPopup: function (model, event) {
    event.preventDefault();

    var $jqXHR = $.ajax({
      url: "/?module=Desk&rt=" + Math.random(),
      type: "GET",
      dataType: "json"
    });

      if (omerta.plugins.popups.isPrompted()) {
          return false;
      }

    $.prompt(omerta.modules.Desk.loader , {
      title: "Help & Support",
      buttons: { Cancel: false, Submit: true },
      submit: omerta.modules.Desk.createTicket,
      loaded: function() {
        $('#jqi_state0_buttonSubmit').hide();
        $('.jqimessage ').addClass('desk-popup');
      }
    });

    $jqXHR.done(omerta.modules.Desk.renderPopup);

  },
  renderPopup: function(data, xhr) {

    if (!_.isObject(data)) {
      return false;
    }

    if (typeof(data.template) === 'undefined') {
      return false;
    }

    if (_.isNull(data.template)) {
      return false;
    }

    $('.jqimessage').html(data.template);
    $('.desk-input-autofocus').focus();

    omerta.modules.Desk.toggleOptions($('#desk-ticket-category'));

  },

  createTicket: function(e,v,m,f) {
    if (v == false) {
      return null;
    }

    e.preventDefault();

    $('.jqimessage').html(omerta.modules.Desk.loader);

    $('#jqi_state0_buttonSubmit').hide();

    var $jqXHR = $.ajax({
      url: "/?module=Desk&action=create&rt="+Math.random(),
      type: "POST",
      dataType: "json",
      data: f
    });

    $jqXHR.done(function(res) {

      $('.jqimessage').html(res.template);

      if (res.data.success) {
        $('#jqi_state0_buttonSubmit').remove();
      } else {
        omerta.modules.Desk.toggleOptions($('#desk-ticket-category'));
      }



    });
  },

  toggleOptions: function(el) {
    var $element = $(el);
    var value = $element.val();

    var $ticketElements = $('.desk-ticket-fields-wrapper');
    if (value.length > 0) {
      $ticketElements.slideDown();
      $('#jqi_state0_buttonSubmit').show();
    } else {
      $ticketElements.slideUp();
      $('#jqi_state0_buttonSubmit').hide();
    }
  }
};
omerta.modules.GameIntro = {

  /**
   * IntroJS object, this is built after we display the introduction
   */
  oIntro: null,

  /**
   * Load function, this is triggered automatically once that all modules are loaded
   */
  load: function () {

    //Bind when the splash is hidden to display the features
    $(document).bind('omerta:loaded', function () {
      omerta.modules.GameIntro.displayFromBody();
    });

  },
  /**
   * Will read any GameIntroOptions variable into the document and build the object and display it
   *
   * @returns {boolean|introJS}
   */
  displayFromBody: function () {

    if (typeof(GameIntroOptions) === 'undefined') {
      return false;
    }

    if (!_.isObject(GameIntroOptions)) {
      return false;
    }

    /**
     * Disable tutorial for slow resolution
     */
    if (typeof(Modernizr) !== 'undefined') {
      if (Modernizr.mq("only screen and (min-width: 320px) and (max-width: 1024px)")) {
        return false;
      }
    }

    return omerta.modules.GameIntro.display(GameIntroOptions);

  },

  /**
   * Via the object options it builds the introduction and display it.
   *
   * @param GameIntroOptions
   * @returns {boolean|introJS}
   * @throws Exception if the vendor is not loaded
   */
  display: function (GameIntroOptions) {

    //Vendor not loaded
    if (typeof(introJs) !== 'function') {
      throw "Vendor IntroJS not loaded";
    }

    //Default configuration for the site
    var aOptions = {
      steps: []
    };

    $.extend(aOptions, GameIntroOptions);

    if (aOptions.steps.length == 0) {
      return false;
    }

    //Build the object
    omerta.modules.GameIntro.oIntro = introJs();

    //Set the options and display the introduction
    omerta.modules.GameIntro.oIntro.setOptions(aOptions);

    //Display the introJS
    omerta.modules.GameIntro.oIntro.start();

    omerta.modules.GameIntro.oIntro.oncomplete(function(e) {
      $(document).trigger('omerta:intro:completed');
    });

    omerta.modules.GameIntro.oIntro.onexit(function(e) {
      $(document).trigger('omerta:intro:closed');
    });

    omerta.modules.GameIntro.oIntro.onafterchange(function(e) {
      $(document).trigger('omerta:intro:afterchange');
    });

    omerta.modules.GameIntro.oIntro.onchange(function(e) {
      $(document).trigger('omerta:intro:change');
    });

    omerta.modules.GameIntro.oIntro.onbeforechange(function(e) {
      $(document).trigger('omerta:intro:beforechange');
    });

    $(document).trigger('omerta:intro:created');

    return omerta.modules.GameIntro.oIntro;
  }
};
/**
 * This file is a just a placeholder to make the module works
 **/
/**
 * This file is a just a placeholder to make the module works
 **/
omerta.modules.UserInformation = $.extend({}, omerta.core.Module, {

    information: ko.observableArray([]),
    user: ko.observableArray([]),
    ranks: ko.observableArray([]),

    family: null,
    actions: ko.observableArray([]),
    actions_stats: ko.observableArray([]),
    currentRank: ko.observable(),

    bodyguards: ko.observableArray([]),
    hiredBodyguards: ko.observable(0),

    lackeys: ko.observableArray([]),
    hiredLackeys: ko.observable(0),

    possessions: ko.observable({}),

    selectedCityString: ko.observable(null),

    citiesMap: {
        0: 'Detroit',
        1: 'Chicago',
        3: 'New York',
        4: 'Las Vegas',
        5: 'Philadelphia',
        6: 'Baltimore',
        7: 'Corleone',
        2: 'Palermo'
    },

    citiesArray: function (bWithEmpty) {

        var cities = $.map(this.citiesMap, function (el) {
            return el;
        });

        if (typeof(bWithEmpty) === 'undefined') {
            bWithEmpty = false;
        }

        if (bWithEmpty) {
            cities.unshift(null);
        }

        return cities;

    },

    load: function () {

    },

    destroy: function () {

        this.unsubscribeTickings();

        this.information = ko.observableArray([]);
        this.user = ko.observableArray([]);
        this.ranks = ko.observableArray([]);

        this.family = null;

        this.actions = ko.observableArray([]);
        this.actions_stats = ko.observableArray([]);
        this.currentRank = ko.observable();

        this.bodyguards = ko.observableArray([]);
        this.hiredBodyguards = ko.observable(0);

        this.lackeys = ko.observableArray([]);
        this.hiredLackeys = ko.observable(0);

        this.possessions = ko.observable({});

        this.selectedCityString = ko.observable(null);
    }
});
//work out wether we are taking into account weekend play
omerta.modules.UserInformation.USER_ALLOWED_HOURS = 34;
omerta.modules.UserInformation.model.ActionStat = function (data) {

    var type = data.type || '',
        value = data.value || 0,
        title = data.title || '';

    this.getAttributesForWrapper = function() {
        return {
            'class': 'action-info-item action-info-'+type
        };
    };

    this._getVal = function() {
        return value;
    };

    this.getShortValue = function() {
        return this.getValue(true);
    };

    this.getTitle = function() {
        return title;
    };

    this.getTip = function() {
        return this.getTitle() + ': ' + this.getValue(false);
    }

    this.getValue = function(bShort) {

        if (typeof(bShort) === 'undefined') {
            bShort = false;
        }

        var resultValue = this._getVal();

        if (typeof(resultValue) === 'object') {
            if (resultValue.length === 2 && bShort === true) {
                return number2text_format(resultValue[0]) + ' ('+number2text_format(resultValue[1])+')';
            }

            if (resultValue.length === 2 && bShort === false) {
                return number_format(resultValue[0]) + ' ('+number_format(resultValue[1])+')';
            }

            return resultValue.join(' / ');
        }

        if (bShort === true) {
            resultValue = number2text_format(resultValue);
        } else {
            resultValue = number_format(resultValue);
        }

        return resultValue;
    };

};

omerta.modules.UserInformation.model.MarketItem = function (data) {

    var name_owned = data.name_owned || '',
        name_unowned = data.name_unowned || '',
        name_manage = data.name_manage || '',
        owned = data.owned || '',
        description = data.description || '',
        href = data.href || '',
        cities = data.cities || null,
        image = data.image || '',
        blocked = data.blocked || false,
        type = data.type || '',
        value = data.value || 0,
        city_values = data.city_values || [];


    this.getName = function() {
        return name_owned;
    };

    this.getDescription = function() {
        return description;
    };

    this.getImage = function() {
        return image;
    };

    this.getBuyName = function() {
        return name_unowned;
    };

    this.getManageName = function() {
        return name_manage;
    };


    this.getHref = function() {
        return href;
    };

    this.loadAction = function() {
        omerta.GUI.container.loadPage(this.getHref());
    };

    this.owned = function() {
        return (owned) ? true : false;
    };

    this.notOwned = function() {
      return !this.owned();
    };

    this.blocked = function() {
        return (blocked) ? true : false;
    };

    this.notBlocked = function() {
        return !this.blocked();
    };

    this.getCities = function() {
      return cities;
    };

    this.getMainAttrs = function() {
        var classes = ['character-wrapper'];

        if (this.owned()) {
            classes.push('owned');
        } else {
            classes.push('unowned');
        }

        if (this.blocked()) {
            classes.push('blocked');
        }

        return {class: classes.join(' ')};
    };

    this.getType = function() {
        return this.type;
    };

    this.getTitle = function() {
        if (this.owned()) {
            return this.getName();
        }

        return this.getBuyName();
    };

    this.getValue = function() {
        return value;
    };

    this.getCitiesValues = function() {
        return city_values || [];
    };


    this.valueByCity = ko.pureComputed(function() {

        var cityId = omerta.modules.UserInformation.selectedCityValue();
        var aCities = this.getCitiesValues();

        if (typeof(aCities[cityId]) !== 'undefined') {
            return aCities[cityId];
        }


        return this.getValue();
    }, this);

    this.getCitiesNames = function() {
        var aCities = this.getCities() || [],
            aReturn = [];

        if (typeof(aCities) === 'undefined') {
            return false;
        }

        if (aCities.length == 0) {
            return false;
        }

        _.each(aCities, function(value, index) {
            aReturn.push(omerta.modules.UserInformation.citiesMap[value]);
        });

        return aReturn;
    };
};
omerta.modules.UserInformation.model.UserAction = function (data) {

    var type = data.type || '';
    var title = data.title || '';

    var image = data.image || '';
    var href = data.href || '';
    var blocked = data.blocked || [];

    var total_time = data.total_time || 0;

    this.time_end = ko.observable(parseInt(data.time_end || 0));

    this.time_left = ko.computed(function(){
        var tick = omerta.Clock.date();

        return omerta.Clock.getTimeLeft(this.time_end());
    }, this).extend({ rateLimit: 1000 });

    this.timeSubscriber = 0;

    this.getType = function () {
        return type;
    };

    this.getTitle = function () {
        return title;
    };

    this.getImage = function () {
        return image;
    };

    this.getHref = function () {
        return href;
    };

    this.getTotalTime = function () {
        return parseInt(total_time);
    };

    this.getBlocked = function () {
        return blocked;
    };

    this.getLockedReason = function () {
        var aBlocked = this.getBlocked();

        if (typeof(aBlocked) === 'object') {
            if (typeof(aBlocked.value) === 'string' && aBlocked.value.length > 0) {
                return aBlocked.value;
            }
        }

        return false;
    };

    this.getTemplateName = ko.computed(function () {

        if (this.time_left() > 0) {
            return 'timer';
        }

        if (this.getLockedReason()) {
            return 'locked';
        }

        return 'normal';

    }, this);


    this.loadAction = function () {
        omerta.GUI.container.loadPage(this.getHref());
    };
};
omerta.modules.UserInformation.model.UserFamily = function(data) {

  var familyId = data.family_id || 0;
  var userCapoMoney = data.user_capomoney || 0;

  var familyName = data.family_name || '';

  var bossId = data.boss_id || 0;
  var sottoId = data.sotto_id || 0;
  var consigId = data.consig_id || 0;
  var capoId = data.capo_id || 0;

  var bossName = data.boss_name || '';
  var sottoName = data.sotto_name || '';
  var consigName = data.consig_name || '';
  var capoName = data.capo_name || '';

  var bank = data.bank || 0;
  var rank = data.rank || 0;

  var hq = data.hq || 0;
  var countMembers = data.count_members || 0;

  var role = data.role || '';
  var roleText = data.role_text || '';

  this.getFamilyId = function() {
    return parseInt(familyId);
  };

  this.getUserCapoMoney = function() {
    return parseInt(userCapoMoney);
  };

  this.getFamilyName = function() {
    return familyName;
  };

  this.getBossId = function() {
    return parseInt(bossId);
  };

  this.getSottoId = function() {
    return parseInt(sottoId);
  };

  this.getConsigId = function() {
    return parseInt(consigId);
  };

  this.getCapoId = function() {
    return parseInt(capoId);
  };

  this.getBossName = function() {
    return bossName;
  };

  this.getSottoName = function() {
    return sottoName;
  };

  this.getConsigName = function() {
    return consigName;
  };

  this.getCapoName = function() {
    return capoName;
  };

  this.getBank = function() {
    return parseInt(bank);
  };

  this.getRank = function() {
    return parseInt(rank);
  };

  this.countHQ = function() {
    return parseInt(hq);
  };

  this.countMembers = function() {
    return parseInt(countMembers);
  };

  this.hasFamily = function() {
    return this.getFamilyId() > 0;
  };

  this.hasLinkUser = function(iUserId) {
    return (iUserId > 0);
  };

  this.isFamless = function() {
    return !this.hasFamily();
  };

  this.getRole = function() {
    return role;
  };

  this.getRoleText = function() {
    return roleText;
  };

  this.familyUrl = function() {
    return '/family.php?fam='+this.getFamilyId();
  };

  this.userUrl = function(sUserName) {
    if (sUserName.length > 0) {
      return '/user.php?nick='+sUserName;
    }

    return 'javascript:void(0)';
  };


  this.userName = function(sUserName) {
    if (sUserName.length > 0) {
      return sUserName;
    }

    return 'None';
  };
};
omerta.modules.UserInformation.model.UserRank = function (data) {

  var id = data.id || 0;
  var completed = data.completed || false;
  var current = data.current || false;
  var gender = data.gender || 'male';
  var image = data.image || '/assets/omerta/modules/UserInformation/assets/img/ranks/empty-suite-male.png';
  var name = data.name || 'Empty-Suite';
  var achievements = data.achievements || [];

  this.getID = function () {
    return parseInt(id);
  };

  this.isCompleted = function () {
    return Boolean(completed);
  };

  this.isCurrent = function () {
    return Boolean(current);
  };

  this.getGender = function () {
    return gender;
  };

  this.getImage = function () {
    return image;
  };

  this.getName = function () {
    return name;
  };

  this.achievements = function () {
    return achievements;
  };


  this.getContentClass = function () {
    var classes = ['assasin-content','rank-outglow'];

    if (this.isCurrent()) {
      classes.push('outglow-white');
    } else {
      if (this.isCompleted()) {
        classes.push('outglow-green');
      } else {
        classes.push('outglow-red');
      }
    }

    return classes.join(' ');
  }

};
omerta.modules.UserInformation.prepareData = function () {
  /**
   * using this.data we will get the data from the ajax request
   */
  this.__initUserRanks(this.data.ranks);
  this.__initGeneralInformation(this.data.info);
  this.__initUserInformation(this.data.user);
  this.__initUserFamily(this.data.family);
  this.__initActionStats(this.data.actions_stats);
  this.__initActions(this.data.actions);
  this.__initBodyguards(this.data.bodyguards);
  this.__initLackeys(this.data.lackeys);
  this.__initPossessions(this.data.possessions);

  setTimeout(function() {
    /** @TODO: FIX THIS IN FUTURE. **/
    $('#game_wrapper_container').height('99%');
  }, 500);
};

/**
 * Function used after the module is rendered
 */

omerta.modules.UserInformation.afterRender = function () {

};

/**
 * Initialize the main information for overview tab.
 *
 * @param aInformation
 * @returns {boolean}
 * @private
 */
omerta.modules.UserInformation.__initGeneralInformation = function(aInformation) {

  if (_.isArray(aInformation) === false && _.isObject(aInformation) === false) {
    return false;
  }

  if (_.isEmpty(aInformation)) {
    return true;
  }

  omerta.modules.UserInformation.information(aInformation);

  /** Update character observables to have everything synched **/
  omerta.character.info.dc_level(aInformation.level);
  omerta.character.info.testament(aInformation.testament);
  omerta.character.game.city(aInformation.city);

  return true;
};

/**
 * Initialize the main information about the user into overview tab.
 * @param aUserInformation
 * @returns {boolean}
 * @private
 */
omerta.modules.UserInformation.__initUserInformation = function(aUserInformation) {

  if (_.isArray(aUserInformation) === false && _.isObject(aUserInformation) === false) {
    return false;
  }

  if (_.isEmpty(aUserInformation)) {
    return true;
  }

  omerta.modules.UserInformation.user(aUserInformation);

  omerta.character.progress.health(aUserInformation.health);
  omerta.character.progress.rank_progress(aUserInformation.rank_progress);
  omerta.character.progress.bustskill(aUserInformation.jailbusting_skill);
  omerta.character.progress.raceform(aUserInformation.race_form);
  omerta.character.progress.honorpoints(aUserInformation.honorpoints);

  omerta.character.progress.money(aUserInformation.money);
  omerta.character.progress.bank(aUserInformation.bank);
  omerta.character.progress.bullets(aUserInformation.bullets);

  return true;
};

/**
 * Initialize the user family information into overview tab.
 *
 * @param aUserFamily
 * @returns {boolean}
 * @private
 */
omerta.modules.UserInformation.__initUserFamily = function(aUserFamily) {

  if (_.isArray(aUserFamily) === false && _.isObject(aUserFamily) === false) {
    return false;
  }

  if (_.isEmpty(aUserFamily)) {
    return true;
  }

  this.family = new omerta.modules.UserInformation.model.UserFamily(aUserFamily);
};

/**
 * Initialize an array of ranks, the one that the user has, the ranked one and the missing.
 *
 * @param aRanks
 * @returns {boolean}
 * @private
 */
omerta.modules.UserInformation.__initUserRanks = function(aRanks) {
  omerta.modules.UserInformation.ranks([]);

  if (_.isArray(aRanks) === false && _.isObject(aRanks) === false) {
    return false;
  }

  if (_.isEmpty(aRanks)) {
    return true;
  }


  for (var i = 0 in aRanks) {
    var itemRank = new omerta.modules.UserInformation.model.UserRank(aRanks[i]);
    if (aRanks[i].current) {
      omerta.modules.UserInformation.currentRank(itemRank);
    }
    omerta.modules.UserInformation.ranks.push(itemRank);
  }

};

/**
 * Initialize the action statistics
 *
 * @param aActions
 * @returns {boolean}
 * @private
 */
omerta.modules.UserInformation.__initActionStats = function(aActions) {

  omerta.modules.UserInformation.actions_stats([]);

  if (_.isArray(aActions) === false && _.isObject(aActions) === false) {
    return false;
  }

  if (_.isEmpty(aActions)) {
    return true;
  }

  var newItems = ko.utils.arrayMap(aActions, function(item) {
    return new omerta.modules.UserInformation.model.ActionStat(item)
  });

  //take advantage of push accepting variable arguments
  omerta.modules.UserInformation.actions_stats.push.apply(omerta.modules.UserInformation.actions_stats, newItems);

};

/**
 * Initialize the actions needed for actions tab.
 *
 * @param aActions
 * @returns {boolean}
 * @private
 */
omerta.modules.UserInformation.__initActions = function(aActions) {

  omerta.modules.UserInformation.actions([]);

  if (_.isArray(aActions) === false && _.isObject(aActions) === false) {
    return false;
  }

  if (_.isEmpty(aActions)) {
    return true;
  }

  var newItems = ko.utils.arrayMap(aActions, function(item) {
    return new omerta.modules.UserInformation.model.UserAction(item);
  });

  //take advantage of push accepting variable arguments
  omerta.modules.UserInformation.actions.push.apply(omerta.modules.UserInformation.actions, newItems);

};

/**
 * Initialize the actions needed for actions tab.
 *
 * @param aBodyguards
 * @returns {boolean}
 * @private
 */
omerta.modules.UserInformation.__initBodyguards = function(aBodyguards) {

  omerta.modules.UserInformation.bodyguards([]);

  if (_.isArray(aBodyguards) === false && _.isObject(aBodyguards) === false) {
    return false;
  }

  if (_.isEmpty(aBodyguards)) {
    return true;
  }

  var iHired = 0;
  for (var i = 0 in aBodyguards) {
    var oBodyguard = new omerta.modules.UserInformation.model.MarketItem(aBodyguards[i]);

    if (oBodyguard.owned()) {
      iHired += 1;
    }

    omerta.modules.UserInformation.bodyguards.push(oBodyguard);
  }

  omerta.modules.UserInformation.bodyguards.sort(function(left, right) {
    return (left.notBlocked() && right.blocked()) ? -1 : 1;
  });

  omerta.modules.UserInformation.hiredBodyguards(iHired);

};


/**
 * Initialize the actions needed for actions tab.
 *
 * @param aBodyguards
 * @returns {boolean}
 * @private
 */
omerta.modules.UserInformation.__initLackeys = function(aLackeys) {

  omerta.modules.UserInformation.lackeys([]);

  if (_.isArray(aLackeys) === false && _.isObject(aLackeys) === false) {
    return false;
  }

  if (_.isEmpty(aLackeys)) {
    return true;
  }

  var iHired = 0;
  for (var i = 0 in aLackeys) {
    var oLackey = new omerta.modules.UserInformation.model.MarketItem(aLackeys[i]);

    if (oLackey.owned()) {
      iHired += 1;
    }

    omerta.modules.UserInformation.lackeys.push(oLackey);
  }

  omerta.modules.UserInformation.hiredLackeys(iHired);

};



/**
 * Initialize the actions needed for actions tab.
 *
 * @param aPossessions
 * @returns {boolean}
 * @private
 */
omerta.modules.UserInformation.__initPossessions = function(aPossessions) {

  omerta.modules.UserInformation.possessions({});

  if (_.isArray(aPossessions) === false && _.isObject(aPossessions) === false) {
    return false;
  }

  if (_.isEmpty(aPossessions)) {
    return true;
  }

  var tmpObject = {};

  for (var i = 0 in aPossessions) {
    var sType = aPossessions[i].type || '';
    tmpObject[sType] = new omerta.modules.UserInformation.model.MarketItem(aPossessions[i])
  }

  omerta.modules.UserInformation.possessions(tmpObject);

};


/**
 * Get the attributes needed to display the DC status into overview tab.
 */
omerta.modules.UserInformation.getDcValues = ko.pureComputed(function () {

  var aReturn = {
    "class": "pull-right status-donator",
    "text": "Not a Donator",
    "href": "/?module=Donate.Methods"
  };

  var status = omerta.character.info.dc_level();

  switch (status) {
    case 1:
      aReturn.text = 'DC Member';
    break;

    case 2:
      aReturn.text = 'DC + Member';
    break;

    default:
      status = 0;
    break;
  }

  aReturn.class += ' status-' + status;

  return aReturn;
});

/**
 * Get the testament name
 */
omerta.modules.UserInformation.getTestamentName = function() {
  var sTestament = omerta.character.info.testament();

  return (sTestament.length > 0) ? sTestament : false;
};



omerta.modules.UserInformation.selectedCityValue = ko.computed(function() {

  var cityString = omerta.modules.UserInformation.selectedCityString();
  var aCities = omerta.modules.UserInformation.citiesMap;

  //Default value, user selected everywhere
  var iReturn = -1;

  for (var index in aCities) {

    var value = aCities[index];

    if (cityString === value) {
      iReturn = index;
      break;
    }

  }

  return parseInt(iReturn);

}, this);

/**
 * Calculates the attributes that should be shown inside the online user statistics into overview.
 *
 */
omerta.modules.UserInformation.getOnlineStats = ko.pureComputed(function() {
  var aInformation = omerta.modules.UserInformation.information();
  var iOnlineSeconds = parseInt(aInformation['online_seconds']);

  var classes = [],
      iMins = iOnlineSeconds / 60,
      iHours = iMins / 60;

  if (iHours >= omerta.modules.UserInformation.USER_ALLOWED_HOURS) {
    classes.push('text-red');
  } else {
    classes.push('text-green');
  }

  var aReturn = {
    "text": Math.round(iHours) + ' HRS',
    "timeleft": aInformation['account_time'],
    "attrs": {
      'class': classes.join(' ')
    }
  };

  return aReturn;
});



/**
 * Calculates the attributes that should be shown inside the online user statistics into overview.
 *
 */
omerta.modules.UserInformation.getUserProtection = function() {

    var aInformation = omerta.modules.UserInformation.information(),
        classes = [],
        type = 'none';

    var iUserProtection = parseInt(aInformation['protection_user'] || 0),
        iFamilyProtection = parseInt(aInformation['protection_family'] || 0);

    classes.push('text-green');

    var iTimeEnd = 0;

    if (iUserProtection > 0) {
        iTimeEnd = iUserProtection;
        type = 'startdate';
    }

    if (iFamilyProtection > 0 && iUserProtection <= 0) {
        iTimeEnd = iFamilyProtection;
        type = 'family';
    }

    var aReturn = {
        "text": '',
        "type": type,
        "visible": type != 'none',
        "attrs": {
            'class': classes.join(' '),
            "data-time-end": iTimeEnd
        }
    };

    return aReturn;
};


/**
 * Calculates the attributes that should be shown inside the online user statistics into overview.
 *
 */
omerta.modules.UserInformation.getTotalCredits = function() {
    var aUser = omerta.modules.UserInformation.user();

    if (typeof(aUser['credits']) === 'undefined') {
        return 0;
    }

    return number_format(aUser['credits']);
};



omerta.modules.UserInformation.updateActionTimer = function(type, iTimeEnd, timeTotal) {

  if (this.actions().length <= 0) {
    return false;
  }

  for (var i in this.actions()) {

    if (type != this.actions()[i].getType()) {
      continue;
    }

    if (this.actions()[i].time_left() > 0) {
      break;
    }

    this.actions()[i].time_end(iTimeEnd);
  }
};

omerta.GUI.container.selectedTab.subscribe(function (newValue) {


  if (newValue == 'account-mobile-character' || newValue === 'overview') {
    var $slider = $('#bxslider');
    if ($slider.length > 0) {
      setTimeout(function () {
        var oSlider = $slider.data("boxSlider");
        if (oSlider) {
          oSlider.reloadSlider();
        }
      }, 200);

    }
  }

});

omerta.modules.UserInformation.unsubscribeTickings = function() {
    var aActions = this.actions();
    for (var i = 0 in aActions) {
        if (typeof(aActions[i].getTemplateName) !== 'undefined') {
            // Dispose computed elements
            aActions[i].getTemplateName.dispose();
            aActions[i].time_left.dispose();
        }
    }
};
/**
 * Forum module
 * Read threads
 */
omerta.modules.Forum = $.extend({}, omerta.core.Module, {
    /**
     * Vars
     */
    template: 'core_popup',
    loading: ko.observable(true),

    /**
     * Layout initialization
     */
    // TODO: temporary with old kernel
    load: function () {

    },
    init: function () {
        // Bind
        this.bind = 'omerta.modules.Forum';
        // Loading
        this.loading(true);

        // Show modal
        this.show();


        // Load forum
    },
    /**
     * Get Forums
     */
    getForums: function () {
        omerta.server.query('GET', 'Forum', null, {}, function (response) {

        });
    },
    previewPost: function(element) {

        var $post = $('#post'),
            $preview = $('#preview'),
            $element = $(element),
            postValue = $post.val(),
            sOriginalText = $element.data('originaltext'),
            sLoadingText = $element.data('loading'),
            sClosePreviewText =$element.data('closepreview'),
            sLoadedText = $element.val();

        if ($post.is(':hidden')) {
            $post.show();
            $preview.css('minHeight', 0).hide();
            $element.val(sOriginalText);
            return true;
        }

        if (postValue.length === 0) {
            return false;
        }

        $jqxhr = $.ajax({
            url: '/forums/preview_ajax.php',
            contentType: 'text/xml',
            processData: false,
            type: 'POST',
            data: postValue
        });

        $element.val(sLoadingText).attr('disabled', true);

        $jqxhr.done(function(data) {
            var testHeight = $post.height();
            $post.hide();
            $preview.html(data).css('minHeight', testHeight+'px').show();
        });

        $jqxhr.always(function() {
            $element.val(sClosePreviewText).removeAttr('disabled');
        });
    },

    replyToPost: function(id) {

        var $post = $('#post-bottom'),
            $postReply = $('#post_'+id),
            postReplyValue = $postReply.val();

        $post.val(postReplyValue).focus();
    },
    goToTopic: function(iTopicId) {
        var url = '/forums/view-topic.php?id='+iTopicId;
        return omerta.GUI.container.loadPage(url);
    }
});
omerta.modules.Milestone = $.extend({}, omerta.core.Module, {

    model: {},
    milestones: ko.observableArray(),

    load: function() {

    }

});
omerta.modules.Milestone.model.Milestone = function (data) {

    var sumCollectedValue = data.sumCollectedValue;
    var id = data.id;

    this.name = data.name;

    this.bCanRedeem = data.canRedeem;
    this.bIsCollected = data.isCollected;


    this.timeEnd = data.timeEnd;
    this.timeActivated = data.timeActivated;
    this.timeCollected = data.timeCollected;

    this.type = parseInt(data.type);
    this.collectedValue = parseInt(data.collectedValue);

    this.value_percentage = data.fields.value_percentage;
    this.value = data.fields.value_percentage - sumCollectedValue;
    this.progress = data.currentPercentage;
    this.collectedProgress = data.collectedPercentage;
    this.updatedAt = data.updatedAt;

    this.value_current = parseInt(data.fields.value_current);
    this.value_old = parseInt(data.fields.value_old);
    this.percentage = parseInt(data.fields.percentage);

    this.uId = parseInt(data.uId);

    this.aRequirements = data.requirements;

    if (this.type === 500) {
        this.value = 0;
        for (var idr = 0 in this.aRequirements) {
            this.value += this.aRequirements[idr];
        }
    }

    /**
     * Check if the milestone got lost
     * @return {boolean}
     */
    this.bMilestoneLost = function(canRedeem, isCollected, timeActivated) {

        if(canRedeem) {
            return false;
        }

        if (isCollected) {
            return false;
        }

        if (_.isNull(timeActivated)) {
            return false;
        }

        return true;

    }(this.bCanRedeem, this.bIsCollected, this.timeActivated);

    this.getFormattedValue = function () {

        var tmpValue = number_format(this.value);
        if (this.bIsCollected || this.bMilestoneLost) {
            tmpValue = number_format(this.collectedValue);
        }
        if (this.type == 700) {
            return '$' + tmpValue;
        }

        if (this.type == 100) {
            return tmpValue + ' rankpoints';
        }
        if (this.type == 200) {
            return tmpValue + ' bullets';
        }
        if (this.type == 300) {
            return tmpValue + ' bustouts';
        }

        return '&nbsp;';
    };
    /**
     * Get progress of milestone.
     * @returns {number}
     */
    this.getProgress = function() {
        if (_.isArray(this.progress)) {
            return this.progress;
        }
        if (!this.progress) {
            return 0;
        }

        if (this.progress > 100) return 100;
        if (this.progress < 0) return 0;

        return this.progress;
    };

    /**
     * Get progress of milestone.
     * @returns {number}
     */
    this.getCollectedProgress = function() {
        if (_.isArray(this.collectedProgress)) {
            return this.collectedProgress;
        }
        if (!this.collectedProgress) {
            return 0;
        }

        if (this.collectedProgress > 100) return 100;
        if (this.collectedProgress < 0) return 0;

        return this.collectedProgress;
    };

    /**
     * Get link for image source
     * @returns {string}
     */
    this.getImageSource = function() {
        return '/assets/omerta/modules/Milestone/assets/img/type/'+this.type+'.png';
    };

    /**
     * Get redeem action url
     * @returns {string}
     */
    this.getRedeemUrl = function() {
        return '/?module=Milestone&action=Redeem&id='+id;
    };


    this.getRequirementsList = function() {

        if (this.type !== 400) {
            return [];
        }


        if (!(this.aRequirements instanceof Object)) {
            return [];
        }

        if (Object.keys(this.aRequirements).length != 4) {
            return [];
        }

        var iLastRank = this.aRequirements[500],
            bKill = this.aRequirements[600],
            bBackfire = this.aRequirements[700],
            iBullets = this.aRequirements[800];

        // @TODO: Move this in another part
        var aDictionary = {
            1: 'Empty-suit',
            2: 'Delivery Boy',
            3: 'Picciotto',
            4: 'Shoplifter',
            5: 'Pickpocket',
            6: 'Thief',
            7: 'Associate',
            8: 'Mobster',
            9: 'Soldier',
            10: 'Swindler',
            11: 'Assassin',
            12: 'Local Chief',
            13: 'Chief',
            14: 'Bruglione',
            15: 'Capodecina',
            16: 'Godfather',
        };

        var sRankName = aDictionary[iLastRank],
            aList = [],
            sBullets = number_format(iBullets, 0);

        if (bBackfire) {
            aList.push("Survive an attack from a "+sRankName+" or higher and shoot "+sBullets+" or more bullets in backfire");
            return aList;
        }

        if (bKill) {
            aList.push("Kill a "+sRankName+" or higher with "+sBullets+" or more bullets")
        } else {
            aList.push("Try to kill a "+sRankName+" or higher with "+sBullets+" or more bullets");
        }

        return aList;

    };

};

omerta.modules.Milestone.prepareData = function () {

    omerta.modules.Milestone.__initMilestones(this.data.milestones);

};

/**
 * Helper function to know if the tab achieved is selected.
 * @returns {boolean}
 */
omerta.modules.Milestone.isAchievedTab = function () {
    return omerta.GUI.container.selectedTab() === 'achieved';
};

/**
 * Initialize the milestoens
 *
 * @param aMilestones
 * @returns {boolean}
 * @private
 */
omerta.modules.Milestone.__initMilestones = function (aMilestones) {

    omerta.modules.Milestone.milestones([]);

    if (_.isArray(aMilestones) === false && _.isObject(aMilestones) === false) {
        return false;
    }

    if (_.isEmpty(aMilestones)) {
        return true;
    }

    var newItems = ko.utils.arrayMap(aMilestones, function (item) {
        return new omerta.modules.Milestone.model.Milestone(item)
    });

    //take advantage of push accepting variable arguments
    return omerta.modules.Milestone.milestones.push.apply(omerta.modules.Milestone.milestones, newItems);

};

/**
 * Filter milestones by selected tab
 */
omerta.modules.Milestone.filterMilestones = ko.computed(function () {

    var bAchieved = omerta.modules.Milestone.isAchievedTab();

    // Use knockout filter to return active or non active milestones
    var aReturn = ko.utils.arrayFilter(omerta.modules.Milestone.milestones(), function (milestone) {

        // If tab achieved is selected return lost milestones
        if (bAchieved) {
            return milestone.bMilestoneLost || milestone.bIsCollected;
        }

        return !milestone.bIsCollected && !milestone.bMilestoneLost;
    });

    // If we are in to collect tab then show only first results and not all
    if (!bAchieved) {
        var oTypes = {},
            aNewReturn = [];
        for (var key = 0 in aReturn) {
            var iType = aReturn[key].type,
                uId = aReturn[key].uId;

            if (iType == 400) {
                aNewReturn.push(aReturn[key]);
                continue;
            }

            var newKey = uId+'-'+iType;

            if (typeof(oTypes[newKey]) !== 'undefined') {
                continue;
            }

            oTypes[newKey] = true;

            aNewReturn.push(aReturn[key]);

        }

        aReturn = aNewReturn;
    }

    return aReturn;

});
/** Singleton module **/
omerta.modules.Develop = {

  load: function() {},
  loadPopup: function(model, event) {
    event.preventDefault();

    var $jqXHR = $.ajax({
      url: "/?module=Develop&rt="+Math.random(),
      type: "GET",
      dataType: "json"
    });

    $jqXHR.done(omerta.modules.Develop.renderPopup);

  },
  renderPopup: function(data, xhr) {

    if (!_.isObject(data)) {
      return false;
    }

    if (typeof(data.template) === 'undefined') {
      return false;
    }

    if (_.isNull(data.template)) {
      return false;
    }

      omerta.plugins.popups.prompt(data.template, {
          title: "Develop toolbox",
          buttons: { Cancel: false, Setup: true },
          submit: omerta.modules.Develop.setupAccount
      });

  },

  setupAccount: function(e,v,m,f) {
    if (v == false) {
      return null;
    }

    e.preventDefault();

    var $jqXHR = $.ajax({
      url: "/?module=Develop&action=Save&rt="+Math.random(),
      type: "GET",
      dataType: "json",
      data: f
    });

    $jqXHR.done(function() {
      $.prompt.close();
    });
  }

};